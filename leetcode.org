#+FILETAG: :learning:note:
#+LATEX_HEADER: \usepackage{amsmath}

* Introduction
This is the main file that contains all the problems and their solutions.
Each problem is organised as follows:
- Problem number Problem name         :problem_tag:
- Description (Basic info)
  - Examples
- Solution (Tackling process)
  - Problem category
  - Algorithm (written by me)
  - Code (written by me)
  - Complexity
    - Time complexity
    - Space complexity
  - Leetcode solution
    - Time complexity
    - Space complexity
- More analysis (Thoughts)
  - General thoughts
  - Related problems
* Problems
Here we start to finish our problems ðŸ˜ˆ.
** Imports for typing
#+caption: imports for typing
#+name: imports for typing
#+begin_src ein-python :session localhost :results output code :noweb yes
from typing import List, Tuple, Set
#+end_src

#+caption: imports for typing-results

#+RESULTS: imports for typing
** DONE 1313 Decompress Run-length encoded list                 :array:easy:
*** Description
:LOGBOOK:
CLOCK: [2020-04-16 Thu 20:09]--[2020-04-16 Thu 20:13] =>  0:04
:END:
We are given a list ~nums~ of integers representing a list compressed with run-length encoding.

Consider each adjacent pair of elements ~[freq, val]=[nums[2*i], nums[2*i+1]], i>=0~.
For each such pair, there are ~freq~ elements with value ~val~ concatenated in a sublist.
Concatenate all the sublists from left to right to generate the decompressed list.

Return the decompressed list.

Constraints:
1. 2 <= nums.length <= 100
2. nums.length % 2 == 0
3. 1 <= nums[i] <= 100
**** Examples:
#+name: 1313 Decompress Run-length encoded list example
#+caption: 1313 Decompress Run-length encoded list example
#+begin_example
Input: nums = [1,2,3,4]
Output: [2,4,4,4]
Explanation: The first pair [1,2] means we have freq = 1 and val = 2 so we generate the array [2].
The second pair [3,4] means we have freq = 3 and val = 4 so we generate [4,4,4].
At the end the concatenation [2] + [4,4,4] is [2,4,4,4].

Input: nums = [1,1,2,3]
Output: [1,3,3]
#+end_example

*** Solution

**** Problem category
Just an array problem.
**** Algorithm
:LOGBOOK:
CLOCK: [2020-04-16 Thu 20:13]--[2020-04-16 Thu 20:15] =>  0:02
:END:
We can use ~for i in range(len(nums), 2)~ and create a sublist for all ~nums[i-1], nums[i]~.
Finally we concatenate these sublists.
**** Code
:LOGBOOK:
CLOCK: [2020-04-16 Thu 20:15]--[2020-04-16 Thu 20:19] =>  0:04
:END:
#+name: 1313 Decompress Run-length encoded list my solution
#+caption: 1313 Decompress Run-length encoded list my solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>

def decompress_RLE_list(nums: List[int]) -> List[int]:
    res = []
    for i in range(0, len(nums), 2):
        sub_lst = [nums[i+1] for j in range(nums[i])]
        res = res+sub_lst
    return res
print(decompress_RLE_list([1,1,2,3]))
#+end_src

#+RESULTS: 1313 Decompress Run-length encoded list my solution
#+begin_src none
[1, 3, 3]
#+end_src

**** Complexity
***** Time complexity:
:LOGBOOK:
CLOCK: [2020-04-16 Thu 20:25]--[2020-04-16 Thu 20:25] =>  0:00
CLOCK: [2020-04-16 Thu 20:21]--[2020-04-16 Thu 20:25] =>  0:04
:END:
$O(M)\text{, where } M=\sum_{i=0,2,4...}^{len(nums)-2}nums[i]$, the summation corresponds to the outer ~for~ loop, we simply sum up the time it takes to build each sub list.
***** Space complexity: 
$O(M)\text{, where } M=\sum_{i=0,2,4...}^{len(nums)-2}nums[i]$

**** Leetcode solution
Not available.
#+name: 1313 Decompress Run-length encoded list leetcode solution
#+caption: 1313 Decompress Run-length encoded list leetcode solution
#+begin_src ein-python :session localhost :results output code

#+end_src

***** Time complexity:

***** Space complexity: 

*** More analysis
**** General thoughts
To concatenate lists in Python.
#+caption: concatenate lists
#+name: concatenate lists
#+begin_src ein-python :session localhost :results output code 
lst1=[1,2,3]
lst2=[3,3,3]
print(lst1+lst2)
#+end_src

#+RESULTS: concatenate lists
#+begin_src none
[1, 2, 3, 3, 3, 3]
#+end_src

#+caption: concatenate lists-results
**** Related problems


** DONE 1295 Find numbers with even number of digits            :array:easy:
*** Description
:LOGBOOK:
CLOCK: [2020-04-16 Thu 20:51]--[2020-04-16 Thu 20:53] =>  0:02
:END:
Given an array ~nums~ of integers, return how many of them contain an *even number* of digits.

Constraints:
1. 1 <= nums.length <= 500
2. 1 <= nums[i] <= 10^5
**** Examples:
#+name: 1295 Find numbers with even number of digits example
#+caption: 1295 Find numbers with even number of digits example
#+begin_example
Input: nums = [12,345,2,6,7896]
Output: 2
Explanation: 
12 contains 2 digits (even number of digits). 
345 contains 3 digits (odd number of digits). 
2 contains 1 digit (odd number of digits). 
6 contains 1 digit (odd number of digits). 
7896 contains 4 digits (even number of digits). 
Therefore only 12 and 7896 contain an even number of digits.

Input: nums = [555,901,482,1771]
Output: 1 
Explanation: 
Only 1771 contains an even number of digits.
#+end_example

*** Solution

**** Problem category

**** Algorithm
:LOGBOOK:
CLOCK: [2020-04-16 Thu 20:53]--[2020-04-16 Thu 20:54] =>  0:01
:END:
We simply loop the ~nums~ and check each number.
We can use this to get the number of all digits of a number: ~len(str(num))~.
**** Code
:LOGBOOK:
CLOCK: [2020-04-16 Thu 20:56]--[2020-04-16 Thu 20:57] =>  0:01
:END:
#+name: 1295 Find numbers with even number of digits my solution
#+caption: 1295 Find numbers with even number of digits my solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>

def find_numbers(nums: List[int]) -> int:
    res = 0
    for ele in nums:
        if len(str(ele)) % 2 == 0:
            res += 1
    return res
print(find_numbers([1,2,3]))
print(find_numbers([11,2,3]))
#+end_src

#+RESULTS: 1295 Find numbers with even number of digits my solution
#+begin_src none
0
1
#+end_src

**** Complexity
***** Time complexity:
$O(N)$.
***** Space complexity: 
$O(N)$.

**** Leetcode solution
Not available.
#+name: 1295 Find numbers with even number of digits leetcode solution
#+caption: 1295 Find numbers with even number of digits leetcode solution
#+begin_src ein-python :session localhost :results output code

#+end_src

***** Time complexity:

***** Space complexity: 

*** More analysis
**** General thoughts
Pretty straightforward.
**** Related problems


** DONE 1365 How many numbers are smaller than the current number :array:easy:
*** Description
Given the array ~nums~, for each ~nums[i]~, find out how many numbers in the array are smaller than it.
That is, for each ~nums[i]~, you have to count the number of valid ~j~'s, such that ~j != i and nums[j] < nums[i]>~.

Return the answer in an array.

Constraints:

1. 2 <= nums.length <= 500
2. 0 <= nums[i] <= 100
**** Examples:
#+name: 1365 How many numbers are smaller than the current number example
#+caption: 1365 How many numbers are smaller than the current number example
#+begin_example
Input: nums = [8,1,2,2,3]
Output: [4,0,1,1,3]
Explanation: 
For nums[0]=8 there exist four smaller numbers than it (1, 2, 2 and 3). 
For nums[1]=1 does not exist any smaller number than it.
For nums[2]=2 there exist one smaller number than it (1). 
For nums[3]=2 there exist one smaller number than it (1). 
For nums[4]=3 there exist three smaller numbers than it (1, 2 and 2).

Input: nums = [6,5,4,8]
Output: [2,1,0,3]

Input: nums = [7,7,7,7]
Output: [0,0,0,0]
#+end_example

*** Solution

**** Problem category

**** Algorithm
:LOGBOOK:
CLOCK: [2020-04-16 Thu 21:17]--[2020-04-16 Thu 21:19] =>  0:02
:END:
We first sort ~nums~, and get ~sorted_nums~.
We loop through ~sorted_nums~, and get ~smaller_count~ mapping in the form of ~{num: smaller_count}~.
We then loop ~nums~ and get ~smaller_count~ of each ~num~, store them in ~res~.
**** Code
:LOGBOOK:
CLOCK: [2020-04-16 Thu 21:20]--[2020-04-16 Thu 21:26] =>  0:06
:END:
#+name: 1365 How many numbers are smaller than the current number my solution
#+caption: 1365 How many numbers are smaller than the current number my solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>

def smaller_numbers_than_current(nums: List[int]) -> List[int]:
    import math
    sorted_nums = sorted(nums)

    smaller_counts = {}
    for i, e in enumerate(sorted_nums):
        smaller_counts[e] = min(smaller_counts.get(e, math.inf), i)

    res = []
    for num in nums:
        res.append(smaller_counts[num])

    return res
print(smaller_numbers_than_current([2,2,3,4,1]))
#+end_src

#+RESULTS: 1365 How many numbers are smaller than the current number my solution
#+begin_src none
[1, 1, 3, 4, 0]
#+end_src

**** Complexity
***** Time complexity:
$O(N\log{N})$.
***** Space complexity: 
$O(N)$.

**** Leetcode solution
Not available.
#+name: 1365 How many numbers are smaller than the current number leetcode solution
#+caption: 1365 How many numbers are smaller than the current number leetcode solution
#+begin_src ein-python :session localhost :results output code

#+end_src

***** Time complexity:

***** Space complexity: 

*** More analysis
**** General thoughts
The best time complexity we can do is $O(N\log N)$.
**** Related problems


** DONE 1409 Queries on a permutation with key                :array:medium:
*** Description
:LOGBOOK:
CLOCK: [2020-04-17 Fri 08:47]--[2020-04-17 Fri 08:53] =>  0:06
:END:
Given the array ~queries~ of positive integers between ~1~ and ~m~, you have to process all ~queries[i]~ (from ~i=0~ to ~i=queries.length-1~) according to the following rules:
1. in the beginning, you have the permutation ~P=[1,2,3,...,m]~.
2. For the current ~i~, find the position of ~queries[i]~ in the permutation ~P~ (indexing from 0) and then move this at the begining of the permutation ~P~. Notice that the position of ~queries[i]~ in ~P~ is the result for ~queries[i]~.

Return an array containing the result for the given ~queries~.

Constraints:

1. 1 <= m <= 10^3
2. 1 <= queries.length <= m
3. 1 <= queries[i] <= m
**** Examples:
#+name: 1409 Queries on a permutation with key example
#+caption: 1409 Queries on a permutation with key example
#+begin_example
Input: queries = [3,1,2,1], m = 5
Output: [2,1,2,1] 
Explanation: The queries are processed as follow: 
For i=0: queries[i]=3, P=[1,2,3,4,5], position of 3 in P is 2, then we move 3 to the beginning of P resulting in P=[3,1,2,4,5]. 
For i=1: queries[i]=1, P=[3,1,2,4,5], position of 1 in P is 1, then we move 1 to the beginning of P resulting in P=[1,3,2,4,5]. 
For i=2: queries[i]=2, P=[1,3,2,4,5], position of 2 in P is 2, then we move 2 to the beginning of P resulting in P=[2,1,3,4,5]. 
For i=3: queries[i]=1, P=[2,1,3,4,5], position of 1 in P is 1, then we move 1 to the beginning of P resulting in P=[1,2,3,4,5]. 
Therefore, the array containing the result is [2,1,2,1].  

Input: queries = [4,1,2,2], m = 4
Output: [3,1,2,0]

Input: queries = [7,5,5,8,3], m = 8
Output: [6,5,0,7,5]
#+end_example

*** Solution

**** Problem category

**** Algorithm
:LOGBOOK:
CLOCK: [2020-04-17 Fri 08:53]--[2020-04-17 Fri 09:01] =>  0:08
:END:
We can use brute force.
We loop through queries ~for i, e in enumerate(queries)~, then have an inner loop ~for j, e_p in enumerate(p_copy)~, when ~e_p==e~, we do ~P.pop(j)~, ~P.insert(0, e_p)~, and ~res.append(j)~.
**** Code
:LOGBOOK:
CLOCK: [2020-04-17 Fri 09:01]--[2020-04-17 Fri 09:05] =>  0:04
:END:
#+name: 1409 Queries on a permutation with key my solution
#+caption: 1409 Queries on a permutation with key my solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>

def process_queries(queries: List[int], m: int) -> List[int]:
    res = []

    p = list(range(1, m+1))
    p_copy = p.copy()
    for i, e in enumerate(queries):
        p_copy = p.copy()
        for j, e_p in enumerate(p_copy):
            if e_p == e:
                p.pop(j)
                p.insert(0, e_p)
                res.append(j)

    return res

print(process_queries([3,1,2,1],5))
#+end_src

#+RESULTS: 1409 Queries on a permutation with key my solution
#+begin_src none
[2, 1, 2, 1]
#+end_src

**** Complexity
***** Time complexity:
$O(N\times M)\text{ , where }N=len(queries), M=m$.
***** Space complexity: 
$O(M)$.
**** Leetcode solution
:LOGBOOK:
CLOCK: [2020-04-17 Fri 09:33]--[2020-04-17 Fri 09:34] =>  0:01
:END:
Not available.

Here is one interesting solution from the discussion forum.
#+name: 1409 Queries on a permutation with key discussion solution
#+caption: 1409 Queries on a permutation with key discussion solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>

def process_queries(queries: List[int], m: int) -> List[int]:
    # the original code uses
    # def process(arr, idx), which is quite confusing
    # as we are trying to find the idx of an element
    def process(arr, elem):
        ans = arr.index(elem)
        arr.insert(0, arr.pop(ans))
        return ans

    m = [x for x in range(1, m+1)]
    return [process(m, i) for i in queries]

print(process_queries([3,1,2,1],5))
#+end_src

#+RESULTS: 1409 Queries on a permutation with key discussion solution
#+begin_src none
[2, 1, 2, 1]
#+end_src

***** Time complexity:
$O(N\times M)\text{ , where }N=len(queries), M=m$.

***** Space complexity: 
$O(M)$.

*** More analysis
**** General thoughts
**** Related problems

** 1329 Sort the matrix diagonally
This is based on an incorrect understanding of the problem description.
See [[*1329 Sort the matrix diagonally 2]] for a correct understanding and solution.
*** Description
:LOGBOOK:
CLOCK: [2020-04-17 Fri 09:55]--[2020-04-17 Fri 09:57] =>  0:02
:END:
Given a ~m*n~ matrix ~mat~ of integers, sort it diagonally in ascending order from the top-left to the bottom-right then return the sorted array.

Constraints:
1. m == mat.length
2. n == mat[i].length
3. 1 <= m, n <= 100
4. 1 <= mat[i][j] <= 100
**** Examples:
#+name: 1329 Sort the matrix diagonally example
#+caption: 1329 Sort the matrix diagonally example
#+begin_example
Input: mat = [[3,3,1,1],[2,2,1,2],[1,1,1,2]]
Output: [[1,1,1,1],[1,2,2,2],[1,2,3,3]]
#+end_example

*** Solution

**** Problem category

**** Algorithm
:LOGBOOK:
CLOCK: [2020-04-17 Fri 10:10]--[2020-04-17 Fri 10:17] =>  0:07
:END:
We first concatenate all lists in the matrix, then sort it to get ~sorted_lst~.
+Then we re-construct the resulting matrix and return it.+
Then we create a new empty ~m*n~ matrix ~res~ filled with ~None~.
We then loop through ~sorted_lst~, and fill the first row of ~res~, then the first column, then second row, second column...
Recall that a 2D array can be mapped to a 1D array.
**** Code
:LOGBOOK:
CLOCK: [2020-04-17 Fri 10:17]--[2020-04-17 Fri 10:41] =>  0:24
CLOCK: [2020-04-17 Fri 10:00]--[2020-04-17 Fri 10:04] =>  0:04
:END:
#+name: 1329 Sort the matrix diagonally my solution
#+caption: 1329 Sort the matrix diagonally my solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>

def diagonal_sort(mat: List[List[int]]) -> List[List[int]]:
    import itertools

    m = len(mat)
    n = len(mat[0])
    res = [[None for i in range(n)] for j in range(m)]
    sorted_lst = sorted(itertools.chain(*mat))

    cur_col = 0
    cur_row = 0

    idx = 0
    while cur_col < n or cur_row < m:
        if cur_col < n:
            for moving_col in range(cur_col, n):
                res[cur_row][moving_col] = sorted_lst[idx]
                idx += 1

            # cur_row+1 so that it does not overwrite
            # the first data in the column
        if cur_row < m:
            for moving_row in range(cur_row+1, m):
                res[moving_row][cur_col] = sorted_lst[idx]
                idx += 1

        cur_col = min(n-1, cur_col+1)
        cur_row = min(m-1, cur_row+1)
        if cur_col == n-1 and cur_row == m-1 and res[m-1][n-1] is not None:
            break
    return res
#print(diagonal_sort([[2,1],[3,2],[3,2]]))
#print(diagonal_sort([[1,2,1],[3,2,4],[7,7,4]]))
#print(diagonal_sort([[3,3,1,1],[2,2,1,2],[1,1,1,2]]))
print(diagonal_sort(
    [[11,25,66,1,69,7],[23,55,17,45,15,52],[75,31,36,44,58,8],[22,27,33,25,68,4],[84,28,14,11,5,50]]
))
#+end_src

#+RESULTS: 1329 Sort the matrix diagonally my solution
#+begin_src none
[[1, 4, 5, 7, 8, 11], [11, 22, 23, 25, 25, 27], [14, 28, 36, 44, 45, 50], [15, 31, 52, 58, 66, 68], [17, 33, 55, 69, 75, 84]]
#+end_src

**** Complexity
***** Time complexity:

***** Space complexity: 

**** Leetcode solution

#+name: 1329 Sort the matrix diagonally leetcode solution
#+caption: 1329 Sort the matrix diagonally leetcode solution
#+begin_src ein-python :session localhost :results output code

#+end_src

***** Time complexity:

***** Space complexity: 

*** More analysis
**** General thoughts
**** Related problems

** DONE 1329 Sort the matrix diagonally 2                     :array:medium:
*** Description

Given a ~m*n~ matrix ~mat~ of integers, sort it diagonally in ascending order from the top-left to the bottom-right then return the sorted array.

Constraints:
1. m == mat.length
2. n == mat[i].length
3. 1 <= m, n <= 100
4. 1 <= mat[i][j] <= 100

**** Examples:
#+name: 1329 Sort the matrix diagonally 2 example
#+caption: 1329 Sort the matrix diagonally 2 example
#+begin_example
Input: mat = [[3,3,1,1],[2,2,1,2],[1,1,1,2]]
Output: [[1,1,1,1],[1,2,2,2],[1,2,3,3]]
#+end_example

*** Solution

**** Problem category

**** Algorithm
:LOGBOOK:
CLOCK: [2020-04-17 Fri 13:47]--[2020-04-17 Fri 13:53] =>  0:06
:END:
With the existing ~mat~, we want to sort each existing diagonal so that they are ascend from top-left to bottom right. We do not want to sort the entire matrix.

We need to first get all the starting cell of each diagonal list ~(x, y)~.
With it, we can easily get the diagonal list by adding 1 to both ~x~ and ~y~.
We then sort each diagonal list and put them back to the ~mat~.
**** Code
#+name: 1329 Sort the matrix diagonally 2 my solution
#+caption: 1329 Sort the matrix diagonally 2 my solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>

def diagonal_sort(mat: List[List[int]]) -> List[List[int]]:
    n = len(mat)
    m = len(mat[0])

    def sort_list(head: Tuple[int]) -> None:
        res = []
        x, y = head
        while x < n and y < m:
            res.append(mat[x][y])
            x+=1
            y+=1

        res.sort()
        res = iter(res)
        x, y = head
        while x < n and y < m:
            mat[x][y] = next(res)
            x+=1
            y+=1

    diagonal_heads = [(x, y) for x in range(n) for y in range(m)]

    for head in diagonal_heads:
        sort_list(head)
        
    return mat
print(diagonal_sort([[4,2,3],[1,3,4]]))
print(diagonal_sort([[2,1],[3,2],[3,2]]))
print(diagonal_sort([[1,2,1],[3,2,4],[7,7,4]]))
print(diagonal_sort([[3,3,1,1],[2,2,1,2],[1,1,1,2]]))
print(diagonal_sort(
    [[11,25,66,1,69,7],[23,55,17,45,15,52],[75,31,36,44,58,8],[22,27,33,25,68,4],[84,28,14,11,5,50]]
))
#+end_src

#+RESULTS: 1329 Sort the matrix diagonally 2 my solution
#+begin_src none
[[3, 2, 3], [1, 4, 4]]
[[2, 1], [2, 2], [3, 3]]
[[1, 2, 1], [3, 2, 4], [7, 7, 4]]
[[1, 1, 1, 1], [1, 2, 2, 2], [1, 2, 3, 3]]
[[5, 17, 4, 1, 52, 7], [11, 11, 25, 45, 8, 69], [14, 23, 25, 44, 58, 15], [22, 27, 31, 36, 50, 66], [84, 28, 75, 33, 55, 68]]
#+end_src

**** Complexity
:LOGBOOK:
CLOCK: [2020-04-17 Fri 14:24]--[2020-04-17 Fri 14:30] =>  0:06
CLOCK: [2020-04-17 Fri 14:24]--[2020-04-17 Fri 14:24] =>  0:00
:END:
***** Time complexity:
:LOGBOOK:
CLOCK: [2020-04-17 Fri 15:00]--[2020-04-17 Fri 15:15] =>  0:15
:END:
This is a bit hard to analyse, but the basic idea is to add up all the time taken to sort all diagonal lists. The total number of such lists is $m+n-1$.
By observation, we can get that the number of the longest diagonal list(s) in the matrix is $|n-m+1|$.
The number of remaining lists would be $m+n-1-|n-m+1|$, which gives us either $2\times (m-1)$ or $2\times (n-1)$.

Therefore, our formula to calculate the total time required by the algorithm is as follows:


$O(2\times (\sum_{i=1}^{\min(n,m)-1} i\log i)+|n-m+1|\times \min(m,n)\times \log{\min(m,n)})$.
***** Space complexity: 

$O(\sqrt{m\times n})$.
**** Leetcode solution
Not available.

Interesting one [[https://leetcode.com/problems/sort-the-matrix-diagonally/discuss/489846/Several-Python-solutions][here]].
#+name: 1329 Sort the matrix diagonally 2 leetcode solution
#+caption: 1329 Sort the matrix diagonally 2 leetcode solution
#+begin_src ein-python :session localhost :results output code
def diagonal_sort(mat):
    m, n = len(mat), len(mat[0])

    def sort(i, j):
        ij = zip(range(i, m), range(j, n))
        vals = iter(sorted(mat[i][j] for i, j in ij))
        for i, j in ij:
            mat[i][j] = next(vals)

    for i in range(m): sort(i, 0)
    for j in range(m): sort(0, j)

    return mat

print(diagonal_sort([[4,2,3],[1,3,4]]))
print(diagonal_sort([[2,1],[3,2],[3,2]]))
print(diagonal_sort([[1,2,1],[3,2,4],[7,7,4]]))
print(diagonal_sort([[3,3,1,1],[2,2,1,2],[1,1,1,2]]))
print(diagonal_sort(
    [[11,25,66,1,69,7],[23,55,17,45,15,52],[75,31,36,44,58,8],[22,27,33,25,68,4],[84,28,14,11,5,50]]
))
#+end_src

#+RESULTS: 1329 Sort the matrix diagonally 2 leetcode solution
#+begin_src none
[[4, 2, 3], [1, 3, 4]]
[[2, 1], [3, 2], [3, 2]]
[[1, 2, 1], [3, 2, 4], [7, 7, 4]]
[[3, 3, 1, 1], [2, 2, 1, 2], [1, 1, 1, 2]]
[[11, 25, 66, 1, 69, 7], [23, 55, 17, 45, 15, 52], [75, 31, 36, 44, 58, 8], [22, 27, 33, 25, 68, 4], [84, 28, 14, 11, 5, 50]]
#+end_src

***** Time complexity:

***** Space complexity: 

*** More analysis
**** General thoughts
**** Related problems

** 1395 Count number of teams                                 :array:medium:
*** Description
:LOGBOOK:
CLOCK: [2020-04-17 Fri 19:38]--[2020-04-17 Fri 19:43] =>  0:05
:END:
There are ~n~ soldiers standing in a line. Each soldier is assigned a *unique* ~rating~ value.

You have to form a team of 3 soldiers amongst them under the following rules:
1. Choose 3 soldiers with index(i, j, k) with rating ~(rating[i], rating[j], rating[k])~.
2. A team is valid if: ~(rating[i]<rating[j]<rating[k])~ or ~rating[i]>rating[j]>rating[k]~, where ~0<=i<j<k<n~.

Soldiers can be part of multiple teams.

Return the number of teams you can form given the conditions.

Constraints:
1. n == rating.length
2. 1 <= n <= 200
3. 1 <= rating[i] <= 10^5
**** Examples:
#+name: 1395 Count number of teams example
#+caption: 1395 Count number of teams example
#+begin_example
Input: rating = [2,5,3,4,1]
Output: 3
Explanation: We can form three teams given the conditions. (2,3,4), (5,4,1), (5,3,1). 

Input: rating = [2,1,3]
Output: 0
Explanation: We can't form any team given the conditions.

Input: rating = [1,2,3,4]
Output: 4
#+end_example

*** Solution

**** Problem category

**** Algorithm
:LOGBOOK:
CLOCK: [2020-04-17 Fri 19:43]--[2020-04-17 Fri 19:45] =>  0:02
:END:
We return ~False~ for all ~n<3~.

This is a combination problem. We need to try all combinations of the list.
**** Code
:LOGBOOK:
CLOCK: [2020-04-17 Fri 19:46]--[2020-04-17 Fri 19:50] =>  0:04
:END:
#+name: 1395 Count number of teams my solution
#+caption: 1395 Count number of teams my solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>
def num_teams(rating: List[int]) -> int:
    if len(rating) < 3:
        return 0

    from itertools import combinations

    count = 0
    for comb in combinations(rating, 3):
        if comb[0] < comb[1] < comb[2] or comb[0]>comb[1]>comb[2]:
            count += 1


    return count
print(num_teams([2,5,3,4,1]))
print(num_teams([2,1,3]))
print(num_teams([1,2,3,4]))
print(num_teams([0,1]))
#+end_src

#+RESULTS: 1395 Count number of teams my solution
#+begin_src none
3
0
4
0
#+end_src

**** Complexity
***** Time complexity:
:LOGBOOK:
CLOCK: [2020-04-17 Fri 20:02]--[2020-04-17 Fri 20:04] =>  0:02
:END:
$O(C_{n}^{3})$, i.e. $O(n^3)$.
***** Space complexity: 

$O(1)$.
**** Leetcode solution
Not available.

Discussions include the use of dynamic programming and backtracking.

Here we try backtracking.
#+name: 1395 Count number of teams backtracking solution
#+caption: 1395 Count number of teams backtracking solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>

#+end_src

***** Time complexity:

***** Space complexity: 

*** More analysis
**** General thoughts
:LOGBOOK:
CLOCK: [2020-04-17 Fri 20:17]
:END:
Brute-forcing this problem should be prohibited as this is medium level problem.
We should try to use some better algorithms to solve it.
**** Related problems


* Data structures
This section contains widely used data structures and related problems.
* Algorithms
This section contains widely used algorithms and related problems.
** Sorting
*** Insertion sort
In-place sort.
Easy to implement.
#+caption: Insertion sort
#+name: Insertion sort
#+begin_src ein-python :session localhost :results output code 
def insertion_sort(arr):
    i = 0
    while i < len(arr):
        j = i
        while j > 0 and arr[j-1] > arr[j]:
            temp = arr[j-1]
            arr[j-1] = arr[j]
            arr[j] = temp
            j -= 1

        i+=1

    return arr
print(insertion_sort([2,1,3,4,2,5]))
#+end_src

#+RESULTS: Insertion sort
#+begin_src none
[1, 2, 2, 3, 4, 5]
#+end_src

#+caption: Insertion sort-results
* Techniques
This section contains techniques that do not make a full algorithm and related problems.
** General
** Python
