#+FILETAG: :learning:note:
#+AUTHOR: Yi Wang
#+TITLE: Leetcode, Data structure and Algorithm
#+LATEX_HEADER: \usepackage{amsmath}
#+OPTIONS: toc:2 H:5
#+SETUPFILE: ../../orgs/theme-readtheorg.setup
# HTML_HEAD: <link rel="stylesheet" href="http://dakrone.github.io/org.css" type="text/css" />

* Introduction
This is the main file that contains all the problems and their solutions.
Each problem is organised as follows:
- Problem number Problem name         :problem_tag:
- Description (Basic info)
  - Examples
- Solution (Tackling process)
  - Problem category
  - Algorithm (written by me)
  - Code (written by me)
  - Complexity
    - Time complexity
    - Space complexity
  - Leetcode solution
    - Time complexity
    - Space complexity
- More analysis (Thoughts)
  - General thoughts
  - Related problems
* Problems
Here we start to finish our problems ðŸ˜ˆ.
** Imports for typing
#+caption: imports for typing
#+name: imports for typing
#+begin_src ein-python :session localhost :results output code :noweb yes
from typing import List, Tuple, Set
#+end_src

#+caption: imports for typing-results

#+RESULTS: imports for typing
** DONE 1313 Decompress Run-length encoded list                 :array:easy:
*** Description
:LOGBOOK:
CLOCK: [2020-04-16 Thu 20:09]--[2020-04-16 Thu 20:13] =>  0:04
:END:

We are given a list ~nums~ of integers representing a list compressed with run-length encoding.

Consider each adjacent pair of elements ~[freq, val]=[nums[2*i], nums[2*i+1]], i>=0~.
For each such pair, there are ~freq~ elements with value ~val~ concatenated in a sublist.
Concatenate all the sublists from left to right to generate the decompressed list.

Return the decompressed list.

Constraints:
1. 2 <= nums.length <= 100
2. nums.length % 2 == 0
3. 1 <= nums[i] <= 100
**** Examples:
#+name: 1313 Decompress Run-length encoded list example
#+caption: 1313 Decompress Run-length encoded list example
#+begin_example
Input: nums = [1,2,3,4]
Output: [2,4,4,4]
Explanation: The first pair [1,2] means we have freq = 1 and val = 2 so we generate the array [2].
The second pair [3,4] means we have freq = 3 and val = 4 so we generate [4,4,4].
At the end the concatenation [2] + [4,4,4] is [2,4,4,4].

Input: nums = [1,1,2,3]
Output: [1,3,3]
#+end_example

*** Solution

**** Problem category
Just an array problem.
**** Algorithm
:LOGBOOK:
CLOCK: [2020-04-16 Thu 20:13]--[2020-04-16 Thu 20:15] =>  0:02
:END:
We can use ~for i in range(len(nums), 2)~ and create a sublist for all ~nums[i-1], nums[i]~.
Finally we concatenate these sublists.
**** Code
:LOGBOOK:
CLOCK: [2020-04-16 Thu 20:15]--[2020-04-16 Thu 20:19] =>  0:04
:END:
#+name: 1313 Decompress Run-length encoded list my solution
#+caption: 1313 Decompress Run-length encoded list my solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>

def decompress_RLE_list(nums: List[int]) -> List[int]:
    res = []
    for i in range(0, len(nums), 2):
        sub_lst = [nums[i+1] for j in range(nums[i])]
        res = res+sub_lst
    return res
print(decompress_RLE_list([1,1,2,3]))
#+end_src

#+RESULTS: 1313 Decompress Run-length encoded list my solution
#+begin_src none
[1, 3, 3]
#+end_src

**** Complexity
***** Time complexity:
:LOGBOOK:
CLOCK: [2020-04-16 Thu 20:25]--[2020-04-16 Thu 20:25] =>  0:00
CLOCK: [2020-04-16 Thu 20:21]--[2020-04-16 Thu 20:25] =>  0:04
:END:
$O(M)\text{, where } M=\sum_{i=0,2,4...}^{len(nums)-2}nums[i]$, the summation corresponds to the outer ~for~ loop, we simply sum up the time it takes to build each sub list.
***** Space complexity: 
$O(M)\text{, where } M=\sum_{i=0,2,4...}^{len(nums)-2}nums[i]$

**** Leetcode solution
Not available.
#+name: 1313 Decompress Run-length encoded list leetcode solution
#+caption: 1313 Decompress Run-length encoded list leetcode solution
#+begin_src ein-python :session localhost :results output code

#+end_src

***** Time complexity:

***** Space complexity: 

*** More analysis
**** General thoughts
To concatenate lists in Python.
#+caption: concatenate lists
#+name: concatenate lists
#+begin_src ein-python :session localhost :results output code 
lst1=[1,2,3]
lst2=[3,3,3]
print(lst1+lst2)
#+end_src

#+RESULTS: concatenate lists
#+begin_src none
[1, 2, 3, 3, 3, 3]
#+end_src

#+caption: concatenate lists-results
**** Related problems


** DONE 1295 Find numbers with even number of digits            :array:easy:
*** Description
:LOGBOOK:
CLOCK: [2020-04-16 Thu 20:51]--[2020-04-16 Thu 20:53] =>  0:02
:END:
Given an array ~nums~ of integers, return how many of them contain an *even number* of digits.

Constraints:
1. 1 <= nums.length <= 500
2. 1 <= nums[i] <= 10^5
**** Examples:
#+name: 1295 Find numbers with even number of digits example
#+caption: 1295 Find numbers with even number of digits example
#+begin_example
Input: nums = [12,345,2,6,7896]
Output: 2
Explanation: 
12 contains 2 digits (even number of digits). 
345 contains 3 digits (odd number of digits). 
2 contains 1 digit (odd number of digits). 
6 contains 1 digit (odd number of digits). 
7896 contains 4 digits (even number of digits). 
Therefore only 12 and 7896 contain an even number of digits.

Input: nums = [555,901,482,1771]
Output: 1 
Explanation: 
Only 1771 contains an even number of digits.
#+end_example

*** Solution

**** Problem category

**** Algorithm
:LOGBOOK:
CLOCK: [2020-04-16 Thu 20:53]--[2020-04-16 Thu 20:54] =>  0:01
:END:
We simply loop the ~nums~ and check each number.
We can use this to get the number of all digits of a number: ~len(str(num))~.
**** Code
:LOGBOOK:
CLOCK: [2020-04-16 Thu 20:56]--[2020-04-16 Thu 20:57] =>  0:01
:END:
#+name: 1295 Find numbers with even number of digits my solution
#+caption: 1295 Find numbers with even number of digits my solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>

def find_numbers(nums: List[int]) -> int:
    res = 0
    for ele in nums:
        if len(str(ele)) % 2 == 0:
            res += 1
    return res
print(find_numbers([1,2,3]))
print(find_numbers([11,2,3]))
#+end_src

#+RESULTS: 1295 Find numbers with even number of digits my solution
#+begin_src none
0
1
#+end_src

**** Complexity
***** Time complexity:
$O(N)$.
***** Space complexity: 
$O(N)$.

**** Leetcode solution
Not available.
#+name: 1295 Find numbers with even number of digits leetcode solution
#+caption: 1295 Find numbers with even number of digits leetcode solution
#+begin_src ein-python :session localhost :results output code

#+end_src

***** Time complexity:

***** Space complexity: 

*** More analysis
**** General thoughts
Pretty straightforward.
**** Related problems


** DONE 1365 How many numbers are smaller than the current number :array:easy:
*** Description
Given the array ~nums~, for each ~nums[i]~, find out how many numbers in the array are smaller than it.
That is, for each ~nums[i]~, you have to count the number of valid ~j~'s, such that ~j != i and nums[j] < nums[i]>~.

Return the answer in an array.

Constraints:

1. 2 <= nums.length <= 500
2. 0 <= nums[i] <= 100
**** Examples:
#+name: 1365 How many numbers are smaller than the current number example
#+caption: 1365 How many numbers are smaller than the current number example
#+begin_example
Input: nums = [8,1,2,2,3]
Output: [4,0,1,1,3]
Explanation: 
For nums[0]=8 there exist four smaller numbers than it (1, 2, 2 and 3). 
For nums[1]=1 does not exist any smaller number than it.
For nums[2]=2 there exist one smaller number than it (1). 
For nums[3]=2 there exist one smaller number than it (1). 
For nums[4]=3 there exist three smaller numbers than it (1, 2 and 2).

Input: nums = [6,5,4,8]
Output: [2,1,0,3]

Input: nums = [7,7,7,7]
Output: [0,0,0,0]
#+end_example

*** Solution

**** Problem category

**** Algorithm
:LOGBOOK:
CLOCK: [2020-04-16 Thu 21:17]--[2020-04-16 Thu 21:19] =>  0:02
:END:
We first sort ~nums~, and get ~sorted_nums~.
We loop through ~sorted_nums~, and get ~smaller_count~ mapping in the form of ~{num: smaller_count}~.
We then loop ~nums~ and get ~smaller_count~ of each ~num~, store them in ~res~.
**** Code
:LOGBOOK:
CLOCK: [2020-04-16 Thu 21:20]--[2020-04-16 Thu 21:26] =>  0:06
:END:
#+name: 1365 How many numbers are smaller than the current number my solution
#+caption: 1365 How many numbers are smaller than the current number my solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>

def smaller_numbers_than_current(nums: List[int]) -> List[int]:
    import math
    sorted_nums = sorted(nums)

    smaller_counts = {}
    for i, e in enumerate(sorted_nums):
        smaller_counts[e] = min(smaller_counts.get(e, math.inf), i)

    res = []
    for num in nums:
        res.append(smaller_counts[num])

    return res
print(smaller_numbers_than_current([2,2,3,4,1]))
#+end_src

#+RESULTS: 1365 How many numbers are smaller than the current number my solution
#+begin_src none
[1, 1, 3, 4, 0]
#+end_src

**** Complexity
***** Time complexity:
$O(N\log{N})$.
***** Space complexity: 
$O(N)$.

**** Leetcode solution
Not available.
#+name: 1365 How many numbers are smaller than the current number leetcode solution
#+caption: 1365 How many numbers are smaller than the current number leetcode solution
#+begin_src ein-python :session localhost :results output code

#+end_src

***** Time complexity:

***** Space complexity: 

*** More analysis
**** General thoughts
The best time complexity we can do is $O(N\log N)$.
**** Related problems


** DONE 1409 Queries on a permutation with key                :array:medium:
*** Description
:LOGBOOK:
CLOCK: [2020-04-17 Fri 08:47]--[2020-04-17 Fri 08:53] =>  0:06
:END:
Given the array ~queries~ of positive integers between ~1~ and ~m~, you have to process all ~queries[i]~ (from ~i=0~ to ~i=queries.length-1~) according to the following rules:
1. in the beginning, you have the permutation ~P=[1,2,3,...,m]~.
2. For the current ~i~, find the position of ~queries[i]~ in the permutation ~P~ (indexing from 0) and then move this at the begining of the permutation ~P~. Notice that the position of ~queries[i]~ in ~P~ is the result for ~queries[i]~.

Return an array containing the result for the given ~queries~.

Constraints:

1. 1 <= m <= 10^3
2. 1 <= queries.length <= m
3. 1 <= queries[i] <= m
**** Examples:
#+name: 1409 Queries on a permutation with key example
#+caption: 1409 Queries on a permutation with key example
#+begin_example
Input: queries = [3,1,2,1], m = 5
Output: [2,1,2,1] 
Explanation: The queries are processed as follow: 
For i=0: queries[i]=3, P=[1,2,3,4,5], position of 3 in P is 2, then we move 3 to the beginning of P resulting in P=[3,1,2,4,5]. 
For i=1: queries[i]=1, P=[3,1,2,4,5], position of 1 in P is 1, then we move 1 to the beginning of P resulting in P=[1,3,2,4,5]. 
For i=2: queries[i]=2, P=[1,3,2,4,5], position of 2 in P is 2, then we move 2 to the beginning of P resulting in P=[2,1,3,4,5]. 
For i=3: queries[i]=1, P=[2,1,3,4,5], position of 1 in P is 1, then we move 1 to the beginning of P resulting in P=[1,2,3,4,5]. 
Therefore, the array containing the result is [2,1,2,1].  

Input: queries = [4,1,2,2], m = 4
Output: [3,1,2,0]

Input: queries = [7,5,5,8,3], m = 8
Output: [6,5,0,7,5]
#+end_example

*** Solution

**** Problem category

**** Algorithm
:LOGBOOK:
CLOCK: [2020-04-17 Fri 08:53]--[2020-04-17 Fri 09:01] =>  0:08
:END:
We can use brute force.
We loop through queries ~for i, e in enumerate(queries)~, then have an inner loop ~for j, e_p in enumerate(p_copy)~, when ~e_p==e~, we do ~P.pop(j)~, ~P.insert(0, e_p)~, and ~res.append(j)~.
**** Code
:LOGBOOK:
CLOCK: [2020-04-17 Fri 09:01]--[2020-04-17 Fri 09:05] =>  0:04
:END:
#+name: 1409 Queries on a permutation with key my solution
#+caption: 1409 Queries on a permutation with key my solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>

def process_queries(queries: List[int], m: int) -> List[int]:
    res = []

    p = list(range(1, m+1))
    p_copy = p.copy()
    for i, e in enumerate(queries):
        p_copy = p.copy()
        for j, e_p in enumerate(p_copy):
            if e_p == e:
                p.pop(j)
                p.insert(0, e_p)
                res.append(j)

    return res

print(process_queries([3,1,2,1],5))
#+end_src

#+RESULTS: 1409 Queries on a permutation with key my solution
#+begin_src none
[2, 1, 2, 1]
#+end_src

**** Complexity
***** Time complexity:
$O(N\times M)\text{ , where }N=len(queries), M=m$.
***** Space complexity: 
$O(M)$.
**** Leetcode solution
:LOGBOOK:
CLOCK: [2020-04-17 Fri 09:33]--[2020-04-17 Fri 09:34] =>  0:01
:END:
Not available.

Here is one interesting solution from the discussion forum.
#+name: 1409 Queries on a permutation with key discussion solution
#+caption: 1409 Queries on a permutation with key discussion solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>

def process_queries(queries: List[int], m: int) -> List[int]:
    # the original code uses
    # def process(arr, idx), which is quite confusing
    # as we are trying to find the idx of an element
    def process(arr, elem):
        ans = arr.index(elem)
        arr.insert(0, arr.pop(ans))
        return ans

    m = [x for x in range(1, m+1)]
    return [process(m, i) for i in queries]

print(process_queries([3,1,2,1],5))
#+end_src

#+RESULTS: 1409 Queries on a permutation with key discussion solution
#+begin_src none
[2, 1, 2, 1]
#+end_src

***** Time complexity:
$O(N\times M)\text{ , where }N=len(queries), M=m$.

***** Space complexity: 
$O(M)$.

*** More analysis
**** General thoughts
**** Related problems

** 1329 Sort the matrix diagonally
This is based on an incorrect understanding of the problem description.
See [[*1329 Sort the matrix diagonally 2]] for a correct understanding and solution.
*** Description
:LOGBOOK:
CLOCK: [2020-04-17 Fri 09:55]--[2020-04-17 Fri 09:57] =>  0:02
:END:
Given a ~m*n~ matrix ~mat~ of integers, sort it diagonally in ascending order from the top-left to the bottom-right then return the sorted array.

Constraints:
1. m == mat.length
2. n == mat[i].length
3. 1 <= m, n <= 100
4. 1 <= mat[i][j] <= 100
**** Examples:
#+name: 1329 Sort the matrix diagonally example
#+caption: 1329 Sort the matrix diagonally example
#+begin_example
Input: mat = [[3,3,1,1],[2,2,1,2],[1,1,1,2]]
Output: [[1,1,1,1],[1,2,2,2],[1,2,3,3]]
#+end_example

*** Solution

**** Problem category

**** Algorithm
:LOGBOOK:
CLOCK: [2020-04-17 Fri 10:10]--[2020-04-17 Fri 10:17] =>  0:07
:END:
We first concatenate all lists in the matrix, then sort it to get ~sorted_lst~.
+Then we re-construct the resulting matrix and return it.+
Then we create a new empty ~m*n~ matrix ~res~ filled with ~None~.
We then loop through ~sorted_lst~, and fill the first row of ~res~, then the first column, then second row, second column...
Recall that a 2D array can be mapped to a 1D array.
**** Code
:LOGBOOK:
CLOCK: [2020-04-17 Fri 10:17]--[2020-04-17 Fri 10:41] =>  0:24
CLOCK: [2020-04-17 Fri 10:00]--[2020-04-17 Fri 10:04] =>  0:04
:END:
#+name: 1329 Sort the matrix diagonally my solution
#+caption: 1329 Sort the matrix diagonally my solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>

def diagonal_sort(mat: List[List[int]]) -> List[List[int]]:
    import itertools

    m = len(mat)
    n = len(mat[0])
    res = [[None for i in range(n)] for j in range(m)]
    sorted_lst = sorted(itertools.chain(*mat))

    cur_col = 0
    cur_row = 0

    idx = 0
    while cur_col < n or cur_row < m:
        if cur_col < n:
            for moving_col in range(cur_col, n):
                res[cur_row][moving_col] = sorted_lst[idx]
                idx += 1

            # cur_row+1 so that it does not overwrite
            # the first data in the column
        if cur_row < m:
            for moving_row in range(cur_row+1, m):
                res[moving_row][cur_col] = sorted_lst[idx]
                idx += 1

        cur_col = min(n-1, cur_col+1)
        cur_row = min(m-1, cur_row+1)
        if cur_col == n-1 and cur_row == m-1 and res[m-1][n-1] is not None:
            break
    return res
#print(diagonal_sort([[2,1],[3,2],[3,2]]))
#print(diagonal_sort([[1,2,1],[3,2,4],[7,7,4]]))
#print(diagonal_sort([[3,3,1,1],[2,2,1,2],[1,1,1,2]]))
print(diagonal_sort(
    [[11,25,66,1,69,7],[23,55,17,45,15,52],[75,31,36,44,58,8],[22,27,33,25,68,4],[84,28,14,11,5,50]]
))
#+end_src

#+RESULTS: 1329 Sort the matrix diagonally my solution
#+begin_src none
[[1, 4, 5, 7, 8, 11], [11, 22, 23, 25, 25, 27], [14, 28, 36, 44, 45, 50], [15, 31, 52, 58, 66, 68], [17, 33, 55, 69, 75, 84]]
#+end_src

**** Complexity
***** Time complexity:

***** Space complexity: 

**** Leetcode solution

#+name: 1329 Sort the matrix diagonally leetcode solution
#+caption: 1329 Sort the matrix diagonally leetcode solution
#+begin_src ein-python :session localhost :results output code

#+end_src

***** Time complexity:

***** Space complexity: 

*** More analysis
**** General thoughts
**** Related problems

** DONE 1329 Sort the matrix diagonally 2                     :array:medium:
*** Description

Given a ~m*n~ matrix ~mat~ of integers, sort it diagonally in ascending order from the top-left to the bottom-right then return the sorted array.

Constraints:
1. m == mat.length
2. n == mat[i].length
3. 1 <= m, n <= 100
4. 1 <= mat[i][j] <= 100

**** Examples:
#+name: 1329 Sort the matrix diagonally 2 example
#+caption: 1329 Sort the matrix diagonally 2 example
#+begin_example
Input: mat = [[3,3,1,1],[2,2,1,2],[1,1,1,2]]
Output: [[1,1,1,1],[1,2,2,2],[1,2,3,3]]
#+end_example

*** Solution

**** Problem category

**** Algorithm
:LOGBOOK:
CLOCK: [2020-04-17 Fri 13:47]--[2020-04-17 Fri 13:53] =>  0:06
:END:
With the existing ~mat~, we want to sort each existing diagonal so that they are ascend from top-left to bottom right. We do not want to sort the entire matrix.

We need to first get all the starting cell of each diagonal list ~(x, y)~.
With it, we can easily get the diagonal list by adding 1 to both ~x~ and ~y~.
We then sort each diagonal list and put them back to the ~mat~.
**** Code
#+name: 1329 Sort the matrix diagonally 2 my solution
#+caption: 1329 Sort the matrix diagonally 2 my solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>

def diagonal_sort(mat: List[List[int]]) -> List[List[int]]:
    n = len(mat)
    m = len(mat[0])

    def sort_list(head: Tuple[int]) -> None:
        res = []
        x, y = head
        while x < n and y < m:
            res.append(mat[x][y])
            x+=1
            y+=1

        res.sort()
        res = iter(res)
        x, y = head
        while x < n and y < m:
            mat[x][y] = next(res)
            x+=1
            y+=1

    diagonal_heads = [(x, y) for x in range(n) for y in range(m)]

    for head in diagonal_heads:
        sort_list(head)
        
    return mat
print(diagonal_sort([[4,2,3],[1,3,4]]))
print(diagonal_sort([[2,1],[3,2],[3,2]]))
print(diagonal_sort([[1,2,1],[3,2,4],[7,7,4]]))
print(diagonal_sort([[3,3,1,1],[2,2,1,2],[1,1,1,2]]))
print(diagonal_sort(
    [[11,25,66,1,69,7],[23,55,17,45,15,52],[75,31,36,44,58,8],[22,27,33,25,68,4],[84,28,14,11,5,50]]
))
#+end_src

#+RESULTS: 1329 Sort the matrix diagonally 2 my solution
#+begin_src none
[[3, 2, 3], [1, 4, 4]]
[[2, 1], [2, 2], [3, 3]]
[[1, 2, 1], [3, 2, 4], [7, 7, 4]]
[[1, 1, 1, 1], [1, 2, 2, 2], [1, 2, 3, 3]]
[[5, 17, 4, 1, 52, 7], [11, 11, 25, 45, 8, 69], [14, 23, 25, 44, 58, 15], [22, 27, 31, 36, 50, 66], [84, 28, 75, 33, 55, 68]]
#+end_src

**** Complexity
:LOGBOOK:
CLOCK: [2020-04-17 Fri 14:24]--[2020-04-17 Fri 14:30] =>  0:06
CLOCK: [2020-04-17 Fri 14:24]--[2020-04-17 Fri 14:24] =>  0:00
:END:
***** Time complexity:
:LOGBOOK:
CLOCK: [2020-04-17 Fri 15:00]--[2020-04-17 Fri 15:15] =>  0:15
:END:
This is a bit hard to analyse, but the basic idea is to add up all the time taken to sort all diagonal lists. The total number of such lists is $m+n-1$.
By observation, we can get that the number of the longest diagonal list(s) in the matrix is $|n-m+1|$.
The number of remaining lists would be $m+n-1-|n-m+1|$, which gives us either $2\times (m-1)$ or $2\times (n-1)$.

Therefore, our formula to calculate the total time required by the algorithm is as follows:


$O(2\times (\sum_{i=1}^{\min(n,m)-1} i\log i)+|n-m+1|\times \min(m,n)\times \log{\min(m,n)})$.
***** Space complexity: 

$O(\sqrt{m\times n})$.
**** Leetcode solution
Not available.

Interesting one [[https://leetcode.com/problems/sort-the-matrix-diagonally/discuss/489846/Several-Python-solutions][here]].
#+name: 1329 Sort the matrix diagonally 2 leetcode solution
#+caption: 1329 Sort the matrix diagonally 2 leetcode solution
#+begin_src ein-python :session localhost :results output code
def diagonal_sort(mat):
    m, n = len(mat), len(mat[0])

    def sort(i, j):
        ij = zip(range(i, m), range(j, n))
        vals = iter(sorted(mat[i][j] for i, j in ij))
        for i, j in ij:
            mat[i][j] = next(vals)

    for i in range(m): sort(i, 0)
    for j in range(m): sort(0, j)

    return mat

print(diagonal_sort([[4,2,3],[1,3,4]]))
print(diagonal_sort([[2,1],[3,2],[3,2]]))
print(diagonal_sort([[1,2,1],[3,2,4],[7,7,4]]))
print(diagonal_sort([[3,3,1,1],[2,2,1,2],[1,1,1,2]]))
print(diagonal_sort(
    [[11,25,66,1,69,7],[23,55,17,45,15,52],[75,31,36,44,58,8],[22,27,33,25,68,4],[84,28,14,11,5,50]]
))
#+end_src

#+RESULTS: 1329 Sort the matrix diagonally 2 leetcode solution
#+begin_src none
[[4, 2, 3], [1, 3, 4]]
[[2, 1], [3, 2], [3, 2]]
[[1, 2, 1], [3, 2, 4], [7, 7, 4]]
[[3, 3, 1, 1], [2, 2, 1, 2], [1, 1, 1, 2]]
[[11, 25, 66, 1, 69, 7], [23, 55, 17, 45, 15, 52], [75, 31, 36, 44, 58, 8], [22, 27, 33, 25, 68, 4], [84, 28, 14, 11, 5, 50]]
#+end_src

***** Time complexity:

***** Space complexity: 

*** More analysis
**** General thoughts
**** Related problems

** DONE 1395 Count number of teams                            :array:medium:
*** Description
:LOGBOOK:
CLOCK: [2020-04-17 Fri 19:38]--[2020-04-17 Fri 19:43] =>  0:05
:END:
There are ~n~ soldiers standing in a line. Each soldier is assigned a *unique* ~rating~ value.

You have to form a team of 3 soldiers amongst them under the following rules:
1. Choose 3 soldiers with index(i, j, k) with rating ~(rating[i], rating[j], rating[k])~.
2. A team is valid if: ~(rating[i]<rating[j]<rating[k])~ or ~rating[i]>rating[j]>rating[k]~, where ~0<=i<j<k<n~.

Soldiers can be part of multiple teams.

Return the number of teams you can form given the conditions.

Constraints:
1. n == rating.length
2. 1 <= n <= 200
3. 1 <= rating[i] <= 10^5
**** Examples:
#+name: 1395 Count number of teams example
#+caption: 1395 Count number of teams example
#+begin_example
Input: rating = [2,5,3,4,1]
Output: 3
Explanation: We can form three teams given the conditions. (2,3,4), (5,4,1), (5,3,1). 

Input: rating = [2,1,3]
Output: 0
Explanation: We can't form any team given the conditions.

Input: rating = [1,2,3,4]
Output: 4
#+end_example

*** Solution

**** Problem category

**** Algorithm
:LOGBOOK:
CLOCK: [2020-04-17 Fri 19:43]--[2020-04-17 Fri 19:45] =>  0:02
:END:
We return ~False~ for all ~n<3~.

This is a combination problem. We need to try all combinations of the list.
**** Code
:LOGBOOK:
CLOCK: [2020-04-17 Fri 19:46]--[2020-04-17 Fri 19:50] =>  0:04
:END:
#+name: 1395 Count number of teams my solution
#+caption: 1395 Count number of teams my solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>
def num_teams(rating: List[int]) -> int:
    if len(rating) < 3:
        return 0

    from itertools import combinations

    count = 0
    for comb in combinations(rating, 3):
        if comb[0] < comb[1] < comb[2] or comb[0]>comb[1]>comb[2]:
            count += 1


    return count
print(num_teams([2,5,3,4,1]))
print(num_teams([2,1,3]))
print(num_teams([1,2,3,4]))
print(num_teams([0,1]))
#+end_src

#+RESULTS: 1395 Count number of teams my solution
#+begin_src none
3
0
4
0
#+end_src

**** Complexity
***** Time complexity:
:LOGBOOK:
CLOCK: [2020-04-17 Fri 20:02]--[2020-04-17 Fri 20:04] =>  0:02
:END:
$O(C_{n}^{3})$, i.e. $O(n^3)$.
***** Space complexity: 

$O(1)$.
**** Leetcode solution
:PROPERTIES:
:CUSTOM_ID: 1395 Count number of teams Leetcode
:END:
:LOGBOOK:
CLOCK: [2020-04-20 Mon 16:10]--[2020-04-20 Mon 16:19] =>  0:09
CLOCK: [2020-04-20 Mon 15:09]--[2020-04-20 Mon 15:51] =>  0:42
:END:
Not available.

This following is adapted from [[https://leetcode.com/problems/count-number-of-teams/discuss/554817/Java-O(N2)-Time-O(N)-Space-(Best-Solution)][this Java solution]].
#+name: 1395 Count number of teams efficient solution
#+caption: 1395 Count number of teams efficient solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>
def num_teams(rating: List[int]) -> int:
    ans = 0
    n = len(rating)

    biggerLeft, biggerRight = {}, {}

    for i in range(n-1):
        for j in range(i+1, n):
            if rating[i] < rating[j]:
                biggerRight[i] = biggerRight.get(i, 0) + 1
            elif rating[i] > rating[j]:
                biggerLeft[j] = biggerLeft.get(j, 0) + 1

    for i in range(n-1):
        for j in range(i+1, n):
            if rating[i] < rating[j]:
                ans += biggerRight.get(j, 0)
            elif rating[i] > rating[j]:
                ans += biggerLeft.get(i, 0)
    return ans
print(num_teams([2,5,3,4,1]))
print(num_teams([2,1,3]))
print(num_teams([1,2,3,4]))
print(num_teams([0,1]))
#+end_src

#+RESULTS: 1395 Count number of teams efficient solution
#+begin_src none
3
0
4
0
#+end_src


***** Time complexity:
$O(N^2)$.
***** Space complexity: 

$O(N)$.
*** More analysis
**** General thoughts
:LOGBOOK:
CLOCK: [2020-04-17 Fri 20:17]--[2020-04-17 Fri 21:21] =>  1:04
:END:
Brute-forcing this problem should be prohibited as this is medium level problem.
We should try to use some better algorithms to solve it.

[[#1395 Count number of teams Leetcode]] is a neat solution to the problem and a specia case of a general solution, which is provided here.

#+name: 1395 Count number of teams general solution
#+caption: 1395 Count number of teams general solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>

def calc_combinations(n: int, k: int) -> int:
    """
    n: total number of items
    k: number of items to be drawn
    """
    calculated = {}
    def factorial(n: int) -> int:
        if n == 0 or n == 1:
            return 1
        if n not in calculated.keys():
            calculated[n] = n * factorial(n-1)
        return calculated[n]

    if n < k :
        return 0
    return int(factorial(n)/factorial(k)/factorial(n-k))

def num_teams(rating: List[int], team_len: int = 3) -> int:
    ans = 0
    n = len(rating)

    biggerLeft, biggerRight = {}, {}

    for i in range(n-1):
        for j in range(i+1, n):
            if rating[i] < rating[j]:
                biggerRight[i] = biggerRight.get(i, 0) + 1
            elif rating[i] > rating[j]:
                biggerLeft[j] = biggerLeft.get(j, 0) + 1

    for i in range(n-1):
        for j in range(i+1, n):
            if rating[i] < rating[j]:
                # team_len-2 gives the remaining numbers that need to be drawn
                # from biggerRight.get(j, 0) given rating[i] and rating[j]
                ans += calc_combinations(biggerRight.get(j, 0), team_len-2)
            elif rating[i] > rating[j]:
                ans += calc_combinations(biggerLeft.get(i, 0), team_len-2)
    return ans
print(num_teams([2,7,8,9,10], 4))
print(num_teams([2,1,3]))
print(num_teams([1,2,3,4]))
print(num_teams([0,1]))
#+end_src

#+RESULTS: 1395 Count number of teams general solution
#+begin_src none
5
0
4
0
#+end_src

**** Related problems

** DONE 442 Find all duplicates in an array                   :array:medium:
*** Description
:LOGBOOK:
CLOCK: [2020-04-20 Mon 17:30]--[2020-04-20 Mon 17:34] =>  0:04
:END:
Given an array of integers, $1\le a[i] \le n, n=\text{size of array}$, some elements appear *twice* and others appear *once*.

Find all the elements that appear *twice* in this array.

Constraints:
Do it without extra space and in $O(n)$ runtime.

**** Examples:
#+name: 442 Find all duplicates in an array example
#+caption: 442 Find all duplicates in an array example
#+begin_example
Input:
[4,3,2,7,8,2,3,1]

Output:
[2,3]
#+end_example

*** Solution

**** Problem category

**** Algorithm
:LOGBOOK:
CLOCK: [2020-04-20 Mon 19:40]--[2020-04-20 Mon 19:46] =>  0:06
CLOCK: [2020-04-20 Mon 19:18]--[2020-04-20 Mon 19:29] =>  0:11
CLOCK: [2020-04-20 Mon 17:35]--[2020-04-20 Mon 17:36] =>  0:01
:END:

See [[https://leetcode.com/problems/find-all-duplicates-in-an-array/discuss/92390/Python-O(n)-time-O(1)-space][Discussion]].

$\because$:
Given the condition $\max(arr)\le \text{len}(arr)$, we know that each number element in the array should be able to be mapped to an index of the array.

We also know that, a number in the array either occurs just once or twice.

$\therefore$:
when iterating the array, we can mark the number at index ~i~ negative when we first encounter it. If we never see it again, then we can safely ignore it (once). The second time we see it and it's negative, we add it to the final result (twice). 

**** Code
:LOGBOOK:
CLOCK: [2020-04-20 Mon 19:46]--[2020-04-20 Mon 19:50] =>  0:04
:END:
#+name: 442 Find all duplicates in an array my solution
#+caption: 442 Find all duplicates in an array my solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>

def find_duplicates(nums: List[int]) -> List[int]:
    res = []
    for n in nums:
        if nums[abs(n)-1] < 0:
            res.append(abs(n))
        else:
            nums[abs(n)-1] *= -1
    return res

print(find_duplicates([1,2,3,3]))
#+end_src

#+RESULTS: 442 Find all duplicates in an array my solution
#+begin_src none
[3]
#+end_src

**** Complexity
***** Time complexity:
$O(N)$.
***** Space complexity: 
$O(1)$, excluding the returning result ~res~.

**** Leetcode solution
Not available.

Most interesting idea has been provided in the previous section.
#+name: 442 Find all duplicates in an array leetcode solution
#+caption: 442 Find all duplicates in an array leetcode solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>

#+end_src

***** Time complexity:

***** Space complexity: 

*** More analysis
**** General thoughts
**** Related problems

** DONE 78 Subsets                                            :array:medium:
*** Description
:LOGBOOK:
CLOCK: [2020-04-20 Mon 20:03]--[2020-04-20 Mon 20:05] =>  0:02
:END:

Given a set of *distinct* integers, ~nums~, return all possible subsets (the power set).

Constraints:
The solution set must not contain duplicate subsets.
**** Examples:
#+name: 78 Subsets example
#+caption: 78 Subsets example
#+begin_example
Input: nums = [1,2,3]
Output:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
#+end_example

*** Solution

**** Problem category

**** Algorithm
:LOGBOOK:
CLOCK: [2020-04-20 Mon 20:05]--[2020-04-20 Mon 20:06] =>  0:01
:END:

We can use Python's ~itertools.combinations~.
**** Code
:LOGBOOK:
CLOCK: [2020-04-20 Mon 20:06]--[2020-04-20 Mon 20:14] =>  0:08
:END:
#+name: 78 Subsets my solution
#+caption: 78 Subsets my solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>

def subsets(nums: List[int]) -> List[List[int]]:
    from itertools import combinations, chain

    res = [combinations(nums, i) for i in range(1, len(nums) + 1)]
    return list(map(list, chain(*res))) + [[]]
print(subsets([1,2,3]))
#+end_src

#+RESULTS: 78 Subsets my solution
#+begin_src none
[[1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3], []]
#+end_src

**** Complexity
***** Time complexity:
$O(\frac{N!}{(N-K)!K!})$
***** Space complexity: 
$O(\frac{N!}{(N-K)!K!})$

**** Leetcode solution
:PROPERTIES:
:CUSTOM_ID: 78 Subsets Leetcode Solution
:END:
:LOGBOOK:
CLOCK: [2020-04-20 Mon 20:38]--[2020-04-20 Mon 20:40] =>  0:02
:END:
Bitmask solution.
The idea is that we map each subset to a bitmask of length n, where 1 on the /ith/ position in the bitmask meas the presence of ~nums[i]~ in the subset, and 0 means its absence.
#+name: 78 Subsets leetcode solution
#+caption: 78 Subsets leetcode solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>

def subsets(nums: List[int]) -> List[List[int]]:
    n = len(nums)
    output = []

    # nth_bit = "1000"
    nth_bit = 1<<n
    for i in range(2**n):
        # generate bit mask, from 0..00 to 1..11
        bitmask = bin(i | nth_bit)[3:]
        # append subset corresponding to that bit mask
        output.append([nums[j] for j in range(n) if bitmask[j] == '1'])

    return output
print(subsets([1,2,3]))
#+end_src

#+RESULTS: 78 Subsets leetcode solution
#+begin_src none
0b1000
000
0b1001
001
0b1010
010
0b1011
011
0b1100
100
0b1101
101
0b1110
110
0b1111
111
[[], [3], [2], [2, 3], [1], [1, 3], [1, 2], [1, 2, 3]]
#+end_src

***** Time complexity:
$O(\frac{N!}{(N-K)!K!})$
***** Space complexity: 
$O(\frac{N!}{(N-K)!K!})$

*** More analysis
**** General thoughts
See [[*Bitmask]]
**** Related problems

** DONE 48 Rotate image                                       :array:medium:
*** Description
:LOGBOOK:
CLOCK: [2020-04-21 Tue 14:13]--[2020-04-21 Tue 14:14] =>  0:01
:END:
You are given an ~n*n~ 2D matrix representing an image.

Rotate the image 90 degrees (clockwise).

Constraints:

You have to rotate the image in-place.
**** Examples:
#+name: 48 Rotate image example
#+caption: 48 Rotate image example
#+begin_example
Given input matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

rotate the input matrix in-place such that it becomes:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]

Given input matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
], 

rotate the input matrix in-place such that it becomes:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]
#+end_example

*** Solution

**** Problem category

**** Algorithm
:LOGBOOK:
CLOCK: [2020-04-21 Tue 14:17]--[2020-04-21 Tue 14:28] =>  0:11
:END:
Given the coordinate of a point ~(row, col)~ in the matrix ~mat~ (~n*n~), to rotate a matrix clockwise by 90 degrees is to do the following:
~map(lambda (row, col): (col, n-1-row), mat)~.
**** Code
:PROPERTIES:
:CUSTOM_ID: 48 Rotate image my solution
:END:
:LOGBOOK:
CLOCK: [2020-04-21 Tue 14:57]--[2020-04-21 Tue 15:01] =>  0:04
CLOCK: [2020-04-21 Tue 14:32]--[2020-04-21 Tue 14:56] =>  0:24
:END:
#+name: 48 Rotate image my solution
#+caption: 48 Rotate image my solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>

def rotate(matrix: List[List[int]]) -> None:
    import math
    n = len(matrix)
    def rotate_square(mat: List[List[int]], coor: Tuple[int]) -> None:
        row, col = coor
        target_val = mat[col][n-1-row]
        mat[col][n-1-row] = mat[row][col]

        row, col = col, n-1-row
        temp = mat[col][n-1-row]
        mat[col][n-1-row] = target_val

        row, col = col, n-1-row
        target_val = mat[col][n-1-row]
        mat[col][n-1-row] = temp

        row, col = col, n-1-row
        mat[col][n-1-row] = target_val

    for cur_row in range(math.ceil(n/2)):
        for cur_col in range(cur_row, n-cur_row-1):
            rotate_square(matrix, (cur_row, cur_col))

    print(matrix)

rotate([[1,2],[3,4]])
rotate([[1,2,3],[4,5,6],[7,8,9]])
rotate([[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]])
#+end_src

#+RESULTS: 48 Rotate image my solution
#+begin_src none
[[3, 1], [4, 2]]
[[7, 4, 1], [8, 5, 2], [9, 6, 3]]
[[15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11]]
#+end_src

**** Complexity
***** Time complexity:
$O(N^2)$.
***** Space complexity: 
$O(1)$
**** Leetcode solution
Not available.
#+name: 48 Rotate image leetcode solution
#+caption: 48 Rotate image leetcode solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>

#+end_src

***** Time complexity:

***** Space complexity: 

*** More analysis
**** General thoughts
:LOGBOOK:
CLOCK: [2020-04-21 Tue 15:42]--[2020-04-21 Tue 15:49] =>  0:07
:END:
My solution is very cumbersome, especially the ~rotate_square()~ function.
As shown in the Leetcode discussion forum, it is easier to flip the matrix instead of actually rotating it because flip the matrix only involves *swapping* two values. Whereas my ~rotate_square()~ involves introducing two temporary variables to finish a rotation.

The other way to mitigate the problem in my solution is to use the following code, which does the rotation of four elements at once.
#+caption: 48 rotate image sample
#+name: 48 rotate image sample
#+begin_src ein-python :session localhost :results output code 
matrix[i][j], matrix[j][n - 1 - i], matrix[n - 1 - i][n - 1 - j], matrix[n - 1 - j][i] 
= matrix[n - 1 - j][i], matrix[i][j], matrix[j][n - 1 - i], matrix[n - 1 - i][n - 1 - j]
#+end_src

#+caption: 48 rotate image sample-results

#+RESULTS: 48 rotate image sample
**** Related problems

** DONE 72 Edit distance                                           :dp:hard:
*** Description
:LOGBOOK:
CLOCK: [2020-04-21 Tue 20:46]--[2020-04-21 Tue 20:47] =>  0:01
:END:
Given two words, ~word1~ and ~word2~, find the minimum number of operations required to convert ~word1~ to ~word2~.

You have the following 3 operations permitted on a word:
1. Insert a character
2. Delete a character
3. Replace a character
   
Constraints:

**** Examples:
#+name: 72 Edit distance example
#+caption: 72 Edit distance example
#+begin_example
Input: word1 = "intention", word2 = "execution"
Output: 5
Explanation: 
intention -> inention (remove 't')
inention -> enention (replace 'i' with 'e')
enention -> exention (replace 'n' with 'x')
exention -> exection (replace 'n' with 'c')
exection -> execution (insert 'u')
#+end_example

*** Solution

**** Problem category

**** Algorithm
This is a typical dynamic programming problem.
**** Code
:LOGBOOK:
CLOCK: [2020-04-21 Tue 20:49]--[2020-04-21 Tue 21:05] =>  0:16
:END:
#+name: 72 Edit distance my solution
#+caption: 72 Edit distance my solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>

def min_distance(word1: str, word2: str) -> int:
    m = len(word1)
    n = len(word2)

    if m == 0:
        return n
    if n == 0:
        return m

    tbl = [[0 for j in range(n+1)] for i in range(m+1)]

    for i in range(m+1):
        for j in range(n+1):
            if i == 0:
                tbl[i][j] = j
            elif j==0:
                tbl[i][j] = i
            elif word1[i-1] == word2[j-1]:
                tbl[i][j] = tbl[i-1][j-1]
            else:
                tbl[i][j] = 1 + min(
                    tbl[i-1][j],
                    tbl[i][j-1],
                    tbl[i-1][j-1]
                )

    return tbl[m][n]
#+end_src

**** Complexity
***** Time complexity:
$O(MN)$
***** Space complexity: 
$O(MN)$

**** Leetcode solution
Not available.
#+name: 72 Edit distance leetcode solution
#+caption: 72 Edit distance leetcode solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>

#+end_src

***** Time complexity:

***** Space complexity: 

*** More analysis
**** General thoughts
See [[*Edit distance]].
**** Related problems

** DONE 121 Best time to buy and sell stock                  :array:hard:dp:
*** Description
:LOGBOOK:
CLOCK: [2020-04-21 Tue 21:05]--[2020-04-21 Tue 21:07] =>  0:02
:END:
Say you have an array for which the ~ith~ element is the price of a given stock on day ~i~.

If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.

Constraints:
You cannot sell a stock before you buy one.
**** Examples:
#+name: 121 Best time to buy and sell stock example
#+caption: 121 Best time to buy and sell stock example
#+begin_example
Input: [7,1,5,3,6,4]
Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
             Not 7-1 = 6, as selling price needs to be larger than buying price.
             
Input: [7,6,4,3,1]
Output: 0
Explanation: In this case, no transaction is done, i.e. max profit = 0.
#+end_example

*** Solution

**** Problem category

**** Algorithm
:LOGBOOK:
CLOCK: [2020-04-21 Tue 21:24]--[2020-04-21 Tue 21:28] =>  0:04
CLOCK: [2020-04-21 Tue 21:07]--[2020-04-21 Tue 21:13] =>  0:06
:END:
+We build up a table of all possible combinations from the ~prices~ list.+
+Half of the table is not necessary.+
We first sort the list ~prices~ and convert it to a ordered map that ~{price: day}~.
Then we start from the lowest price ~p_low~, and check it against the highest price ~p_hi~, if ~price[p_hi]>price[p_low]~, we already find one candidate of the result and move ~p_low~ to the right, else, we move ~p_hi~ to the left.
**** Code
:LOGBOOK:
CLOCK: [2020-04-21 Tue 21:31]--[2020-04-21 Tue 21:46] =>  0:15
CLOCK: [2020-04-21 Tue 21:13]--[2020-04-21 Tue 21:16] =>  0:03
:END:
#+name: 121 Best time to buy and sell stock my solution
#+caption: 121 Best time to buy and sell stock my solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>

def max_profit(prices: List[int]) -> int:

    max_p = 0

    price_map = {}
    for i, p in enumerate(prices):
        if p not in price_map.keys():
            price_map[p] = i

    prices.sort()

    for p_buy in prices:
        d_buy = price_map[p_buy]
        for p_sell in reversed(prices):
            d_sell = price_map[p_sell]
            if p_buy<p_sell and d_buy < d_sell:
                max_p = max(max_p, p_sell-p_buy)
                break

    return max_p
print(max_profit([7,1,5,3,6,4]))
print(max_profit([7,6,5]))
print(max_profit([1,4,1,4,3,1]))
#+end_src

#+RESULTS: 121 Best time to buy and sell stock my solution
#+begin_src none
5
0
3
#+end_src

**** Complexity
***** Time complexity:

***** Space complexity: 

**** Leetcode solution
:LOGBOOK:
CLOCK: [2020-04-22 Wed 08:17]--[2020-04-22 Wed 08:23] =>  0:06
:END:
If we plot the numbers in the array on a graph, we will have a line graph.

The points of interest are the peaks and valleys in the given graph. We need to find the highest peak, following the lowest valley. We can maintain two variables - ~minprice~ and ~maxprofit~ corresponding to the lowest valley and maximum profit (max difference between selling price and ~minprice~) obtained so far respectively.
#+name: 121 Best time to buy and sell stock leetcode solution
#+caption: 121 Best time to buy and sell stock leetcode solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>

def max_profit(prices: List[int]) -> int:
    from math import inf
    minprice = inf
    maxprofit = 0

    for i in range(len(prices)):
        if prices[i] < minprice:
            minprice = prices[i]
        elif prices[i] - minprice > maxprofit:
            maxprofit = prices[i] - minprice

    return maxprofit
print(max_profit([1,2,3,4,5]))
#+end_src

#+RESULTS: 121 Best time to buy and sell stock leetcode solution
#+begin_src none
4
#+end_src

***** Time complexity:
$O(N)$

***** Space complexity: 
$O(1)$

*** More analysis
**** General thoughts
:LOGBOOK:
CLOCK: [2020-04-22 Wed 09:09]--[2020-04-22 Wed 09:26] =>  0:17
CLOCK: [2020-04-22 Wed 08:23]--[2020-04-22 Wed 08:46] =>  0:23
:END:
Initially I was trying to use dynamic programming to solve this problem, as is indicated by the problem's DP tag, then it was very hard to start because the problem does not seem to have an obvious subproblems that will be solved multiple times.

The solutions provided by Leetcode did not use DP either, but then other people suggested that it /can/ be categorised as a very [[https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solution/][simple DP problem]] and tabulation can be used to solve it.

#+begin_quote
The prerequisites for using DP are:
1. optimal substructure
2. overlaping sub-problems

In this problem, sub-problems ~f[i]~ is defined as "the minimum stock price from day 0 to day ~i~", which is dependant on ~f[i-1]~ and ~prices[i]~, whichever is lower.
The overlapping sub-problem here is very obvious - there's no need to calculate ~f[i]~ by comparing stock prices from day 0 to day ~i-1~, which is the brute force solution, but just reuse the pre-calculated result ~f[i-1]~.

~maxprofit~ variable may or may not be in the DP table, as it can be viewed as a simple global max, and we can simply get it by ~maxprofit=max(maxprofit, prices[i-1]-dp[i-1][0])~.
#+end_quote

Also people mentioned that this is similar to [[https://en.wikipedia.org/wiki/Maximum_subarray_problem][Kadane's Algorithm for Maximum Subarray Sum]].
#+caption: 121 Best time to buy and sell stock dp solution
#+name: 121 Best time to buy and sell stock dp solution
#+begin_src ein-python :session localhost :results output code 
def max_profit(prices) -> int:
    from math import inf
    
    n = len(prices)
    dp = [[0, 0] for i in range(n+1)]

    # starting price
    dp[0][0] = inf

    for i in range(1, n+1):
        dp[i][0] = min(dp[i-1][0], prices[i-1])
        dp[i][1] = max(dp[i-1][1], prices[i-1]-dp[i-1][0])

    return dp[n][1]
print(max_profit([1,2,3,4,5]))
#+end_src

#+RESULTS: 121 Best time to buy and sell stock dp solution
#+begin_src none
4
#+end_src

#+caption: 121 Best time to buy and sell stock dp solution-results
**** Related problems
[[*53 Maximum subarray]]
** DONE 53 Maximum subarray                                         :dp:easy:
*** Description
:LOGBOOK:
CLOCK: [2020-04-22 Wed 09:27]--[2020-04-22 Wed 09:28] =>  0:01
:END:
Given an integer array ~nums~, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.

Constraints:
Use $O(N)$ time.
**** Examples:
#+name: 53 Maximum subarray example
#+caption: 53 Maximum subarray example
#+begin_example
Input: [-2,1,-3,4,-1,2,1,-5,4],
Output: 6
Explanation: [4,-1,2,1] has the largest sum = 6.
#+end_example

*** Solution

**** Problem category

**** Algorithm
:LOGBOOK:
CLOCK: [2020-04-22 Wed 09:28]--[2020-04-22 Wed 09:38] =>  0:10
:END:
Use dynamic programming.
The sub-problem is "the maximum sum of previous arrays".
**** Code
:LOGBOOK:
CLOCK: [2020-04-22 Wed 09:53]--[2020-04-22 Wed 09:54] =>  0:01
CLOCK: [2020-04-22 Wed 09:43]--[2020-04-22 Wed 09:49] =>  0:06
:END:
#+name: 53 Maximum subarray my solution
#+caption: 53 Maximum subarray my solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>

def max_subarray(nums: List[int]) -> int:
    from math import inf
    n = len(nums)
    if n == 1:
        return nums[0]

    # this is actualy not needed
    # see General thoughts
    dp = [0 for i in range(n+1)]
    dp[0] = -inf

    for i in range(1, n+1):
        dp[i] =max(nums[i-1], nums[i-1] + dp[i-1])

    return max(dp)
print(max_subarray([-2,1,-3,4,-1,2,1,-5,4]))
print(max_subarray([-2,1]))
#+end_src

#+RESULTS: 53 Maximum subarray my solution
#+begin_src none
6
1
#+end_src

**** Complexity
***** Time complexity:
$O(N)$.
***** Space complexity: 
$O(N)$ but $O(1)$ can be achieved by removing the ~dp~ array.

**** Leetcode solution
Not available.
#+name: 53 Maximum subarray leetcode solution
#+caption: 53 Maximum subarray leetcode solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>

#+end_src

***** Time complexity:

***** Space complexity: 

*** More analysis
**** General thoughts
:LOGBOOK:
CLOCK: [2020-04-22 Wed 10:19]--[2020-04-22 Wed 10:22] =>  0:03
CLOCK: [2020-04-22 Wed 10:06]--[2020-04-22 Wed 10:09] =>  0:03
:END:
[[https://en.wikipedia.org/wiki/Maximum_subarray_problem][Wikipedia]] introduces the history of this problem as "a simplified model for /maximum likelihood/ estimate of patterns in digitized images".

In this problem, $O(1)$ space can be achieved.
#+name: 53 Maximum subarray my solution O(1) space
#+caption: 53 Maximum subarray my solution O(1) space
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>

def max_subarray(nums: List[int]) -> int:
    from math import inf
    n = len(nums)
    if n == 1:
        return nums[0]

    cur_sum = -inf
    best_sum = cur_sum

    for i in range(1, n+1):
        cur_sum =max(nums[i-1], nums[i-1] + cur_sum)
        best_sum = max(best_sum, cur_sum)

    return best_sum
print(max_subarray([-2,1,-3,4,-1,2,1,-5,4]))
#print(max_subarray([-2,1]))
#+end_src

#+RESULTS: 53 Maximum subarray my solution O(1) space
#+begin_src none
6
#+end_src

**** Related problems
[[*121 Best time to buy and sell stock]]
The ~minprice~ in [[*121 Best time to buy and sell stock]] is the ~cur_sum~ in this question, and ~maxprofit~ in [[*121 Best time to buy and sell stock]] is the ~best_sum~ in this question.
** DONE 70 Climbming stairs                                        :dp:easy:
*** Description
:LOGBOOK:
CLOCK: [2020-04-22 Wed 10:50]--[2020-04-22 Wed 10:52] =>  0:02
:END:
You are climbing a stair case. It takes ~n~ steps to reach to the top.

Each time you can either climbe 1 or 2 steps. In how many distinct ways you can climb to the top?

Constraints:
~n~ will be positive integer.
**** Examples:
#+name: 70 Climbming stairs example
#+caption: 70 Climbming stairs example
#+begin_example
Input: 2
Output: 2
Explanation: There are two ways to climb to the top.
1. 1 step + 1 step
2. 2 steps

Input: 3
Output: 3
Explanation: There are three ways to climb to the top.
1. 1 step + 1 step + 1 step
2. 1 step + 2 steps
3. 2 steps + 1 step
#+end_example

*** Solution

**** Problem category

**** Algorithm
:LOGBOOK:
CLOCK: [2020-04-22 Wed 11:07]--[2020-04-22 Wed 11:11] =>  0:04
CLOCK: [2020-04-22 Wed 10:57]--[2020-04-22 Wed 11:03] =>  0:06
CLOCK: [2020-04-22 Wed 10:52]--[2020-04-22 Wed 10:56] =>  0:04
:END:
This is basically a Fibonacci series.
+We need to do a "top-down" calculation of the ways we can take.+
+Starting from the top (~n~), there are two ways to go back (one step or two steps), and we are at ~n-1~.+
+By the same token, when we are at ~n-1~, for the two different stairs we are at, there are two stairs we can take for each of them. We first calculate one of them, and store the number of ways to go down in a map. This map can be later used for calculating another possibility at ~n-1~.+

+We continue this until we reach the bottom.+

+We then do addition: ~ans[n] = ans[n-1]+ans[n-2]~.+
The code is written in "bottom-up" format. Somehow for me it is easier to think this way. Previously mentioned algorithm still works but is hard for me to implement as I am not sure how to solve the recursive part when we use a map to simplify calculation.
**** Code
:LOGBOOK:
CLOCK: [2020-04-22 Wed 11:11]--[2020-04-22 Wed 11:18] =>  0:07
:END:
#+name: 70 Climbming stairs my solution
#+caption: 70 Climbming stairs my solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>

def climb_stairs(n: int) -> int:
    dp = [0 for i in range(n+1)]

    dp[0], dp[1] = 1, 1
    for i in range(2, n+1):
        dp[i] = dp[i-1] + dp[i-2]
    return dp[n]
print(climb_stairs(4))
#+end_src

#+RESULTS: 70 Climbming stairs my solution
#+begin_src none
5
#+end_src

**** Complexity
***** Time complexity:
$O(n)$.

***** Space complexity: 
$O(n)$.

**** Leetcode solution
:LOGBOOK:
CLOCK: [2020-04-23 Thu 07:55]--[2020-04-23 Thu 08:05] =>  0:10
:END:
There are [[https://leetcode.com/problems/climbing-stairs/solution/][6 approaches]] on Leetcode.
1. Approach 1 is brute force.
2. Approaches 2 to 4 are essentially the same as my solution.
3. Approach 5 uses /Binets Method/, which uses matrix multiplication to obtain the $n^{th}$ Fibonacci number. Its time complexity is $\log(n)$. Space complexity is $O(1)$.
4. Approach 6 just uses the Fibonacci Formula to calculate the $n^{th}$ Fibonacci number. It is asymptotically the same as approach 5. However, precision of calculation is lost when ~n~ is big and the formula will give an incorrect number.
Here we take the formula solution.
#+name: 70 Climbming stairs leetcode solution
#+caption: 70 Climbming stairs leetcode solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>

def climb_stairs(n: int) -> int:
    sqrt5=pow(5, 1/2)
    fibn = pow((1+sqrt5)/2, n+1)-pow((1-sqrt5)/2,n+1)
    return int(fibn/sqrt5)
print(climb_stairs(5))
#+end_src

#+RESULTS: 70 Climbming stairs leetcode solution
#+begin_src none
8
#+end_src

***** Time complexity:

***** Space complexity: 

*** More analysis
**** General thoughts
:LOGBOOK:
CLOCK: [2020-04-23 Thu 08:05]--[2020-04-23 Thu 08:08] =>  0:03
:END:
It is amazing how we can optimise this seemingly daunting problem such dramatically from $O(2^n)$ to $\log(n)$!.
**** Related problems
[[*746 Min cost climbing stairs]]
** DONE 746 Min cost climbing stairs                               :dp:easy:
*** Description
:LOGBOOK:
CLOCK: [2020-04-23 Thu 08:11]--[2020-04-23 Thu 08:14] =>  0:03
:END:
On a staircase, the $i^{th}$ step has some 0 indexed non-negative cost ~cost[i]~ assigned.

Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0 or with index 1.

Constraints:
1. ~cost~ will have a length in the range [2, 1000]
2. Every ~cost[i]~ will be an integer in the range [0, 999].
**** Examples:
#+name: 746 Min cost climbing stairs example
#+caption: 746 Min cost climbing stairs example
#+begin_example
Input: cost = [10, 15, 20]
Output: 15
Explanation: Cheapest is start on cost[1], pay that cost and go to the top.

Input: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]
Output: 6
Explanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3].
#+end_example

*** Solution

**** Problem category

**** Algorithm
:LOGBOOK:
CLOCK: [2020-04-23 Thu 08:14]--[2020-04-23 Thu 08:24] =>  0:10
:END:
This is an optimal problem. The final problem, "minimum cost to reach the top of the floor" can be divided into two subproblems, namely, the minimum cost to reach to the previous two possible stairs. We have $min_cost_n=min(min_cost_{n-1}, min_cost_{n-2})$, and that $min_cost_{n-1}$ and $min_cost_{n-2}$ have overlapping subsubproblems.
Therefore, we can use dynamic programming to solve this problem.
**** Code
:LOGBOOK:
CLOCK: [2020-04-23 Thu 09:11]--[2020-04-23 Thu 09:11] =>  0:00
CLOCK: [2020-04-23 Thu 08:24]--[2020-04-23 Thu 08:41] =>  0:17
:END:
#+name: 746 Min cost climbing stairs my solution
#+caption: 746 Min cost climbing stairs my solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>

def min_cost_climbing_stairs(cost: List[int]) -> int:
    from math import inf
    n = len(cost)
    min_cost = [inf for i in range(n)]

    min_cost[0], min_cost[1] = cost[0], cost[1]
    for i in range(2, n):
        min_cost[i] = min(min_cost[i-1], min_cost[i-2])+cost[i]

    return min(min_cost[n-1], min_cost[n-2])
print(min_cost_climbing_stairs([1, 100, 1,1,1,100,1,1,100,1]))
#+end_src

#+RESULTS: 746 Min cost climbing stairs my solution
#+begin_src none
6
#+end_src
**** Complexity
***** Time complexity:
$O(N)$.
***** Space complexity: 
$O(N)$.
**** Leetcode solution
:PROPERTIES:
:CUSTOM_ID: 746 Leetcode
:END:
:LOGBOOK:
CLOCK: [2020-04-23 Thu 08:43]--[2020-04-23 Thu 09:03] =>  0:20
:END:
The explanation from Leetcode is not very intuitive or clear.
The concept is the same as mine, but the way it explains things is very twisted.

Basically, they want ~i in range(n, 1, -1)~, and then calculate each ~f[i]~ which is the total cost of the current floor.
#+caption: Quote from Leetcode
#+name: Quote from Leetcode
#+begin_quote
Intuition: 
There is a clear recursion available: the final cost f[i] to climb the staircase from some step i is f[i] = cost[i] + min(f[i+1], f[i+2]). This motivates dynamic programming.

Algorithm:
Let's evaluate f backwards in order. That way, when we are deciding what f[i] will be, we've already figured out f[i+1] and f[i+2].

We can do even better than that. At the i-th step, let f1, f2 be the old value of f[i+1], f[i+2], and update them to be the new values f[i], f[i+1]. We keep these updated as we iterate through i backwards. At the end, we want min(f1, f2).
#+end_quote

#+name: 746 Min cost climbing stairs leetcode solution
#+caption: 746 Min cost climbing stairs leetcode solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>

def min_cost_climbing_stairs(cost: List[int]):
    f1 = f2 = 0
    for x in reversed(cost):
        f1, f2=x+min(f1, f2), f1

    return min(f1, f2)
print(min_cost_climbing_stairs([10,14,10]))
#+end_src

#+RESULTS: 746 Min cost climbing stairs leetcode solution
#+begin_src none
14
#+end_src

Based on the [[#746 Leetcode][Leetcode solution]], we can improve our code to get $O(1)$ space complexity.
#+name: 746 Min cost climbing stairs my solution improved
#+caption: 746 Min cost climbing stairs my solution improved
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>

def min_cost_climbing_stairs(cost: List[int]) -> int:
    from math import inf
    n = len(cost)

    mc1, mc2 = cost[0], cost[1]

    for i in range(2, n):
        mc1, mc2 = mc2, min(mc1, mc2)+cost[i]

    return min(mc1, mc2)
print(min_cost_climbing_stairs([1, 100, 1,1,1,100,1,1,100,1]))
#+end_src

#+RESULTS: 746 Min cost climbing stairs my solution improved
#+begin_src none
6
#+end_src
***** Time complexity:
$O(N)$
***** Space complexity: 

$O(1)$
*** More analysis
**** General thoughts
:LOGBOOK:
CLOCK: [2020-04-23 Thu 09:15]--[2020-04-23 Thu 09:18] =>  0:03
:END:
Again, to determine if a question fits dynamic programming, we want to determine if:
1. It asks for an optimal solution
2. It can be divided into finding the optimal solution to subproblems
3. The subproblems have overlapping subsubproblems
   1. DP's goal is to only solve these overlapping problems once to save time
4. A recursive definition of the optimal solution can be found
**** Related problems
[[*70 Climbming stairs]]


* Data structures
This section contains widely used data structures and related problems.
* Algorithms
This section contains widely used algorithms and related problems.
** Sorting
*** Insertion sort
In-place sort.
Easy to implement.
#+caption: Insertion sort
#+name: Insertion sort
#+begin_src ein-python :session localhost :results output code 
def insertion_sort(arr):
    i = 0
    while i < len(arr):
        j = i
        while j > 0 and arr[j-1] > arr[j]:
            temp = arr[j-1]
            arr[j-1] = arr[j]
            arr[j] = temp
            j -= 1

        i+=1

    return arr
print(insertion_sort([2,1,3,4,2,5]))
#+end_src

#+RESULTS: Insertion sort
#+begin_src none
[1, 2, 2, 3, 4, 5]
#+end_src

#+caption: Insertion sort-results
** Dynamic programming

The prerequisites for using DP are:
1. optimal substructure
2. overlaping sub-problems
*** Edit distance
:LOGBOOK:
CLOCK: [2020-04-21 Tue 20:27]--[2020-04-21 Tue 20:45] =>  0:18
CLOCK: [2020-04-21 Tue 17:35]--[2020-04-21 Tue 17:57] =>  0:22
:END:

#+caption: dynamic programming - edit distance
#+name: dynamic programming - edit distance
#+begin_src ein-python :session localhost :results output code 
def edit(s: str, t: str) -> int:
    from math import inf
    def get_element(tbl: List[List[int]], i: int, j: int) -> int:

        if i>=0 and j>=0:
            return tbl[i][j]
        else:
            return inf
        
    m = len(s)
    n = len(t)

    tbl = [[0 for j in range(n+1)] for i in range(m+1)]


    for i in range(0, m+1):
        for j in range(0, n+1):
            if i==0 and j==0:
                continue
            tbl[i][j] = min(1+get_element(tbl,i, j-1), 1+get_element(tbl,i-1, j), get_element(tbl, i-1, j-1)+(0 if s[i-1]==t[j-1] else 1))
    return tbl[m][n]
print(edit("cbc", "ac"))
#+end_src

#+RESULTS: dynamic programming - edit distance
#+begin_src none
2
#+end_src

#+caption: dynamic programming - edit distance-results

#+caption: dynamic programming - edit distance improved
#+name: dynamic programming - edit distance improved
#+begin_src ein-python :session localhost :results output code 
def edit(s: str, t: str) -> int:
    m = len(s)
    n = len(t)

    # +1 accounts for the empty string in the table
    tbl = [[0 for j in range(n+1)] for i in range(m+1)]

    for i in range(m+1):
        for j in range(n+1):
            if i == 0:
                tbl[i][j] = j
            elif j==0:
                tbl[i][j] = i

            # we want to compare the chars s[i-1] and t[j-1]
            # not the chars s[i] and t[j]
            # because at this point, i is in [1..m], j is in [1..n]
            # we need to map them back to [0..m-1] and [0..n-1]
            elif s[i-1]==t[j-1]:
                tbl[i][j] = tbl[i-1][j-1]
            else:
                tbl[i][j] = 1+min(tbl[i][j-1], # insert
                                  tbl[i-1][j], # remove
                                  tbl[i-1][j-1] # replace
                )
    return tbl[m][n]

print(edit("abc", "ac"))
#+end_src

#+RESULTS: dynamic programming - edit distance improved
#+begin_src none
1
#+end_src

#+caption: dynamic programming - edit distance improved-results
*** Discussions from /Introduction to Algorithms/
See [[#CLRS Dynamic programming]].
* Techniques
This section contains techniques that do not make a full algorithm and related problems.
** General
*** Bitmask
:LOGBOOK:
CLOCK: [2020-04-21 Tue 11:34]--[2020-04-21 Tue 11:38] =>  0:04
CLOCK: [2020-04-21 Tue 10:45]--[2020-04-21 Tue 10:59] =>  0:14
:END:
See [[#78 Subsets Leetcode Solution]].

We have set of objects that we want to draw from. How do we represent the set's subsets such that we get its power set?

We can easily think of a map to associate with each object a boolean value, indicating whether the object is picked. The problem with this is that it can take a lot of memory and can be slow due to the overhead of creating the map.

So we can use bitmask.

#+name: bitmask example
| arr  | 1 | 2 | 3 |
| mask | 1 | 0 | 1 |
#+caption: bitmask
#+name: bitmask
#+begin_src ein-python :session localhost :results output code 
def get_power_set(arr: List[int]) -> List[List[int]]:
    n = len(arr)

    # helps create left padding zeros
    # if n == 4, we have 1000
    nth_bit = 1<<n

    res = [[]]
    # time complexity: 2**n
    for i in range(2**n):
        # if n==4, we might have 1000 | 010
        # 1000 | 110, etc
        # [3:] takes out the leading "0b1" in "0b1010"
        mask = bin(nth_bit | i)[3:]
        sub = []
        # time complexity: n
        for j in range(n):
            if mask[j] == "1":
                sub.append(arr[j])

        res.append(sub)
    return res
print(get_power_set([1,2,3]))
#+end_src

#+RESULTS: bitmask
#+begin_src none
[[], [], [3], [2], [2, 3], [1], [1, 3], [1, 2], [1, 2, 3]]
#+end_src

#+caption: bitmask-results

** Python
* CLRS Notes & Yufei Tao lecture notes
:PROPERTIES:
:NOTER_DOCUMENT: /mnt/c/Users/thoma/OneDrive/Books/Introduction to Algorithms (3rd Edition).pdf
:END:
Read chapters 3-4, 6-7, 10-17 and 22 of CLRS, and practice on LeetCode.
Also check Yufei Tao's lecture notes for concise introductions.

** Growth of functions
:PROPERTIES:
:NOTER_PAGE: 64
:END:
:LOGBOOK:
CLOCK: [2020-04-23 Thu 11:00]--[2020-04-23 Thu 11:11] =>  0:11
:END:
We want to compare which algorithm performs better with respect to input size.
We study the [[*Asymptotic notation][asymptotic]] efficiency of algorithms when we make the input size large enough that only the order of growth of the running time is relevant.
*** Asymptotic notation
:PROPERTIES:
:NOTER_PAGE: 64
:END:
Notations:
1. Domain for all functions of interest: $\mathbb{N}$.
2. Worst-case running-time function $T(n)$.

**** List of notations from YFT lecture notes:
***** Big-$O$ (upper bound)
:LOGBOOK:
CLOCK: [2020-04-23 Thu 11:11]--[2020-04-23 Thu 11:18] =>  0:07
:END:
Let $f(n)$ and $g(n)$ be two functions of $n$.

We say that $f(n)$ grows asymptotically no faster than $g(n)$ if there is a constant $c_1>0$ and a constant $c_2$ such that $f(n)\le c_1 g(n)$ holds for all $n \ge c_2$.
We denote this by $f(n)=O(g(n))$.

The *time complexity* of an algorithm is described in the asymptotical form (big-O). 
***** Big-$\Omega$ (lower bound)
:LOGBOOK:
CLOCK: [2020-04-23 Thu 13:45]--[2020-04-23 Thu 13:48] =>  0:03
:END:
Let $f(n)$ and $g(n)$ be two functions of $n$.
If $g(n)=O(f(n))$, then we define: $f(n)=\Omega(g(n))$, to indicate that $f(n)$ grows asymptotically no slower than $g(n)$.
***** Big-$\Theta$
:LOGBOOK:
CLOCK: [2020-04-23 Thu 13:48]--[2020-04-23 Thu 13:59] =>  0:11
:END:
Let $f(n)$ and $g(n)$ be two functions of $n$.
If $f(n)=O(g(n)) \text{ and } f(n)=\Omega(g(n))$, in other words, $f(n)=O(g(n)) \text{ and } g(n)=O(f(n))$, then we define: $f(n)=\Theta(g(n))$.
This indicates that $f(n)$ grows asymptotically as fast as $g(n)$, no faster (big-$O$), no faster (big-$\Omega$).
*** Standard notations and common functions
:PROPERTIES:
:NOTER_PAGE: 74
:END:
** Divide and conquer
:PROPERTIES:
:NOTER_PAGE: 86
:END:
:LOGBOOK:
CLOCK: [2020-04-23 Thu 14:05]--[2020-04-23 Thu 14:09] =>  0:04
:END:
We solve the problem recursively, applying the following 3 steps at each level of the recursion:
1. *Divide* the problem into a number of subproblems that are smaller instances of the same problem (recursive case).
2. *Conquer* the subproblems by solving them recursively. If the subproblem sizes are small enough, however, just solve the subproblems in a straightforward manner (base case).
3. *Combine* the solutions to the subproblems into the solution for the original problem.
*** Recurrences
:PROPERTIES:
:NOTER_PAGE: 86
:END:
:LOGBOOK:
CLOCK: [2020-04-23 Thu 14:09]--[2020-04-23 Thu 14:19] =>  0:10
:END:
A *recurrence* is an equation of inequality that describes a function in terms of its value on smaller inputs.

The books provides 3 methods for obtaining the asymptotic $\Theta$ or $O$ bounds on the recurrence solution:
1. *Substitution method* - we guess a bound and then use mathematical induction to prove our guess correct.
2. *Recursion-tree method* - convert the recurrence into a tree whose nodes represent the costs incurred at various levels of the recursion. We use techniques for bounding summations to solve the recurrence.
3. <<master method>> *Master method* - provides bounds for recurrences of the form $T(n)=\underbrace{aT(n/b)}_{a \text{ subproblems}}+f(n),a\ge 1, b>1$ and $f(n)$ is a given function.

To use the [[master method]], 3 cases need to be memorized.
** Sorting
:PROPERTIES:
:NOTER_PAGE: 168
:END:
:LOGBOOK:
CLOCK: [2020-04-23 Thu 18:42]--[2020-04-23 Thu 18:53] =>  0:11
:END:
The *sorting problem*:
- Input: A sequence of $n$ numbers $\langle a_1, a_2,\ldots,a_n\rangle$.
- Output: A permutation $\langle a_1',a_2',\ldots,a_n'\rangle$ of the input sequence such that $a_1'\le a_2'\le \ldots \le a_n'$.

Two kinds of sorting based on time complexity:
- Comparison sort: sorted order is based only on comparison between the input elements
- Non-comparison sort: use operations other than comparisons to determine the sorted order
#+name: Sorting time complexity
#+caption: Sorting time complexity
| Algorithm      | Worst-case runing time | Average-case/expected running time | Comparison? |
|----------------+------------------------+------------------------------------+-------------|
| Insertion sort | $\Theta(n^2)$          | $\Theta(n^2)$                      | yes         |
| Merge          | $\Theta(n\lg n)$       | $\Theta(n\lg n)$                   | yes         |
| Heap           | $O(n\lg n)$            | -                                  | yes         |
| Quick          | $\Theta(n^2)$          | $\Theta(n\lg n)$ (expected)        | yes         |
| Counting       | $\Theta(k+n)$          | $\Theta(k+n)$                      | no          |
| Radix          | $\Theta(d(k+n))$       | $\Theta(d(k+n))$                   | no          |
| Bucket         | $\Theta(n^2)$          | $\Theta(n)$ (average-case)         | no          |

*** Heapsort                                              :comparison_sort:
:PROPERTIES:
:NOTER_PAGE: 172
:END:
:LOGBOOK:
CLOCK: [2020-04-24 Fri 11:02]--[2020-04-24 Fri 11:39] =>  0:37
CLOCK: [2020-04-23 Thu 18:53]--[2020-04-23 Thu 19:13] =>  0:20
:END:
- Running time: $O(n\lg n)$
- In-place: yes

The *(binary) heap* data structure is an /array/ object that can be viewed as a nearly complete binary tree (some leaves might be empty). Each node of the tree corresponds to an element of the array.

A heap $A$ is an array that has two attributes:
1. $A.length$
2. $A.heap-size$, only $A[1..A.heap-size]$ are valid elements to the heap
$A.heap-size\le A.length$.

**** Heap properties
:PROPERTIES:
:NOTER_PAGE: 173
:END:
:LOGBOOK:
CLOCK: [2020-04-24 Fri 09:39]--[2020-04-24 Fri 09:47] =>  0:08
:END:

For any node $i$, we have:
- parent: $\lfloor i/2\rfloor$.
- left child: $2i$
- right child: $2i+1$

There are two kinds of binary heaps: *max-heaps* and *min-heaps*.
For every node $i$, they satisfy a *heap property*, 
- max-heap: $A[parent(i)]\ge A[i]$.
- min-heap: $A[parent(i)]\le A[i]$.

Max-heaps are used in the heapsort lagorithm; Min-heaps implement priority queues.

**** Max-Heapify (maintaining $A[parent(i)]\ge A[i]$)
:PROPERTIES:
:NOTER_PAGE: 175
:END:
:LOGBOOK:
CLOCK: [2020-04-24 Fri 11:55]--[2020-04-24 Fri 12:07] =>  0:12
CLOCK: [2020-04-24 Fri 09:47]--[2020-04-24 Fri 10:13] =>  0:26
:END:
Here is the Python code for the Max-Heapify pseudo-code.
Time complexity: $O(\lg n), n=A.length$.

The ~max_heapify~ lets the value at ~A[i]~ "float down" in the max-heap
so that the subtree rooted at index ~i~ obeys the max-heap property.
#+caption: max-heapify
#+name: max-heapify
#+begin_src ein-python :session localhost :results output code 
def max_heapify(A, i, heap_size) -> None:

    # A is 0-indexed
    l = 2*i+1
    r = 2*i+2

    largest = i
    if l < heap_size and A[l]>A[i]:
        largest = l
    if r < heap_size and A[r]>A[largest]:
        largest = r

    if largest != i:
        A[i], A[largest] = A[largest], A[i]
        # after exchanging A[i] and A[largest]
        # the subtree now rooted at A[largest] might violate the max-heap property
        # thus we need to heapify it
        # at the end, the value of the original A[i] will float down
        # as many heights as possible
        max_heapify(A, largest, heap_size)

A = [4,14,7,10,1,12]
max_heapify(A, 0, len(A))
print(A)
#+end_src

#+RESULTS: max-heapify
#+begin_src none
[14, 10, 7, 4, 1, 12]
#+end_src

#+caption: max-heapify-results

**** Building a heap
:PROPERTIES:
:NOTER_PAGE: 178
:END:
:LOGBOOK:
CLOCK: [2020-04-24 Fri 10:13]--[2020-04-24 Fri 10:27] =>  0:14
:END:
Here is the Python code for building the Build-Max-Heap pseudo-code from bottom to top (this is faster than "top-bottom" but the details are not important here).

This is $O(n)$. Although the obvious time complexity is $O(n\lg n)$, we can prove that 
a tighter bound exists and it is $O(n)$.

This makes sure that *all* elements $A[i]$ in the heap satisfies:
$A[parent(i)]\ge A[i]$.
#+caption: build-max-heap
#+name: build-max-heap
#+begin_src ein-python :session localhost :results output code :noweb yes
<<max-heapify>>
def build_max_heap(A, heap_size) -> None:

    # we simply skip all leaves
    for i in range((len(A)//2-1), -1, -1):
        max_heapify(A, i, heap_size)

#A = [4,14,7]
#build_max_heap(A, len(A))
#print(A)
#+end_src

#+RESULTS: build-max-heap
#+begin_src none
[14, 4, 7]
#+end_src

#+caption: build-max-heap-results

**** Heapsort algorithm
:PROPERTIES:
:NOTER_PAGE: 180
:END:
:LOGBOOK:
CLOCK: [2020-04-24 Fri 10:27]--[2020-04-24 Fri 10:39] =>  0:12
:END:

#+caption: heapsort
#+name: heapsort
#+begin_src ein-python :session localhost :results output code :noweb yes
<<build-max-heap>>

def heapsort(A):

    build_max_heap(A, len(A)-1)
    for i in range(len(A)-1, 0, -1):
        # heap_size is i
        A[0], A[i] = A[i], A[0]
        max_heapify(A, 0, i)

A=[3,13,2,123,4,1]        
heapsort(A)
print(A)
#+end_src

#+RESULTS: heapsort
#+begin_src none
[14, 10, 7, 4, 1, 12]
[1, 2, 3, 4, 13, 123]
#+end_src

#+caption: heapsort-results

**** Issues with heapsort in real world applications
:LOGBOOK:
CLOCK: [2020-04-24 Fri 12:10]--[2020-04-24 Fri 12:21] =>  0:11
:END:
Notes from [[https://www.cs.princeton.edu/courses/archive/spring13/cos226/lectures/24PriorityQueues-JH-2x2.pdf][Princeton COS 226]].

Performance on real computers is heavily impacted by really messy factors like cache performance.

Cache works in a way that when we fetch one memory address, its nearby addresses are fetched as well, since memory access patterns of most programs/algorithms are highly localized.
Therefore, in a $n\times n$ matrix, ~[arr[i][j] for j in range(n) for i in range(n)]~ is faster than ~[arr[j][i] for j in range(n) for i in range(n)]~, because when we fetched ~arr[i][0]~, the computer already cached ~arr[i][1]~, etc, for us. 

#+caption: Sort algorithms and cache performance
#+name: Sort algorithms and cache performance
| Sorting algo | characteristic           | cache-friendlyâ˜º?   |
|--------------+--------------------------+----------------------|
| mergesort    | sort subarrays first     | cache-friendly â˜º   |
| quicksort    | partition into subarrays | cache-friendly â˜º   |
| heapsort     | all over the place       | cache-unfriendly ðŸ¤• |


*** Quicksort                                             :comparison_sort:
:PROPERTIES:
:NOTER_PAGE: 191
:END:
:LOGBOOK:
CLOCK: [2020-04-25 Sat 10:52]--[2020-04-25 Sat 12:00] =>  1:08
CLOCK: [2020-04-25 Sat 10:14]--[2020-04-25 Sat 10:46] =>  0:32
:END:

Worst-case: $\Theta(n^2)$.
Expected-case: $O(n\lg n)$.
In-place: true.

Three step divide-and-conquer process for a subarray $A[p..r]$:
- *Divide*: Partition $A[p..r]$ into two (possibly empty) subarrays $A[p..q-1]$ and $A[q+1..r]$ such that $a\le A[q]\le b, a\in A[p..q-1], b\in A[q+1, r]$. Compute the index $q$ as part of this partition prcedure.
- *Conquer*: Sort the two subarrays $A[p..q-1]$ and $A[q+1..r]$ by recursive calls to quicksort.
- *Combine*: Because the subarrays are already sorted, no work is needed to combine them.

**** Implementation
Implementation of the above steps:
#+caption: quicksort
#+name: quicksort
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>
<<partitioning the array>>

def quicksort(arr, low, high):
    if low < high:
        par_idx = partition(arr, low, high)
        quicksort(arr, low, par_idx-1)
        quicksort(arr, par_idx+1, high)

A = [2,1,4,5]
quicksort(A, 0, len(A)-1)
print(A)
#+end_src

#+caption: quicksort-results
#+RESULTS: quicksort
#+begin_src none
[1, 2, 4, 5]
#+end_src

Implementation of partitioning the array:
#+caption: partitioning the array
#+name: partitioning the array
#+begin_src ein-python :session localhost :results output code :noweb yes
def partition(arr, low, high):
    """
    This function takes last element as pivot, places the pivot element at its
    correct position in sorted array, and places all smaller elements to the left of
    the pivot, and all greater elements to the right of the pivot.

    This partitions the arr in-place. Thus the for loop seems hard to understand.
    """
    pivot = arr[high]
    # arr[low:i+1] is the smaller elements segment 
    # that are <= pivot

    # i is the idx of the last smaller element
    i = low - 1 
    # After each the iteration:
    # arr[low:i+1] are smaller elements.
    # arr[i+1:j] are larger elements.
    # arr[j:high] are unchecked elements.
    # arr[high] is the pivot
    for j in range(low, high):
        # if current element is smaller than
        # or equal to pivot
        # This means we can add another element
        # to the smaller elements segment
        if arr[j] <= pivot:
            # increment index of smaller element
            # because we found one smaller element at arr[j]
            # and is going to exchange it with arr[i]
            i += 1
            # if j>i, that means arr[i] > pivot
            # we need to exchange that with arr[j].
            # otherwise, there is no need to exchange 
            # arr[j] and arr[i]
            # however, this condition can be ignored,
            # as it does not slow down the operation
            if j>i:
                arr[i], arr[j] = arr[j], arr[i]

    # exchange the smallest element in the larger segment
    # with the pivot
    arr[i+1], arr[high] = arr[high], arr[i+1]
    return i+1
#+end_src

**** Notes on choosing the /pivot/ and running time
:PROPERTIES:
:NOTER_PAGE: 196
:END:
:LOGBOOK:
CLOCK: [2020-04-25 Sat 14:27]--[2020-04-25 Sat 14:43] =>  0:16
:END:

We can randomly pick any $i$ in $A$ to be our pivot. And this random picking process can be done in $O(1)$ time.

Because this is a randomized algorithm, its running time is a *random variable* depending on the random choices made. Thus we can only get its running time as follows:
#+caption: Quicksort running time
#+name: Quicksort running time
| Case    | # of elements in segments after each partitioning | Running time |
|---------+---------------------------------------------------+--------------|
| Worst   | n-1 elements and 0 elements                       | $O(n^2)$     |
| Best    | $\lfloor n/2 \rfloor$, $\lceil n/2 \rceil -1$     | $O(n\lg n)$  |
| Average | as long as segment not empty (not the worst)      | $O(n\lg n)$  |

*** Sorting in linear time
:PROPERTIES:
:NOTER_PAGE: 212
:END:
:LOGBOOK:
CLOCK: [2020-04-25 Sat 15:07]--[2020-04-25 Sat 15:13] =>  0:06
:END:
We assume all input elements are distinct, without loss of generality.
**** TODO Decision-tree
:PROPERTIES:
:NOTER_PAGE: 213
:END:
:LOGBOOK:
CLOCK: [2020-04-25 Sat 15:13]--[2020-04-25 Sat 15:15] =>  0:02
:END:
Comparison sorts can be viewed abstractly in terms of decision trees.
A decision tree is a full binary tree that represents the comparisons between elements 
that are performed by a particular sorting algorithm operating on an input of a given size.
** Medians and order statistics
:PROPERTIES:
:NOTER_PAGE: 234
:END:
:LOGBOOK:
CLOCK: [2020-04-25 Sat 09:53]--[2020-04-25 Sat 10:11] =>  0:18
:END:
*** Definition
The $i$ th *order statistic* of a set of $n$ elements is the $i$ th smallest element.
For example, the *minimum* of a set of elements is the first order statistic ($i=1$),
and the *maximum* is the $n$ th order statistic ($i=n$). A *median*, is the middle of the set.

The *selection problem*:
- Input: A set $A$ of $n$ (distinct) numbers and an integer $i$, with $1\le i \le n$.
- Output: The element $x \in A,a_1< a_2 < \ldots < a_{i-1},x < a_{i+1}\ldots a_n$.
*** TODO Selection in expected linear time
:PROPERTIES:
:NOTER_PAGE: 236
:END:
:LOGBOOK:
CLOCK: [2020-04-25 Sat 10:11]--[2020-04-25 Sat 10:13] =>  0:02
:END:
We use ~randomized_select~.
** Dynamic programming
:PROPERTIES:
:CUSTOM_ID: CLRS Dynamic programming
:NOTER_PAGE: 380
:END:
:LOGBOOK:
CLOCK: [2020-04-22 Wed 13:36]--[2020-04-22 Wed 13:52] =>  0:16
:END:
Dynamic programming solves problems by combining the solutions to subproblems. "Programming" in this context refers to
a tabular mothod, not to writing computer code.

DP is usually applied to *optimization problems* that can be divided into subproblems,
and these subproblems have overlapping subsubprolems, i.e. they share some common subsubproblems.

Usually, there exist multiple solutions to a problem, and we want /a/ solution that gives an optimal 
(minimum or maximum) value, since there might also exist multiple solutions that give us the same
optimal value.
*** Four steps to develop a dynamic programming algorithm
:PROPERTIES:
:NOTER_PAGE: 380
:END:
1. <<characterize-structure>>Characterize the structure of an optimal solution
2. <<recursively-define-value>>Recursively define the value of an optimal solution
3. Compute the value of an optimal solution, typically in a bottom-up fashion
4. Construct an optimal solution from computed information
   1. This step is only needed when we want /not only the value of the solution/, but also the /solution/ itself.
   2. This step is where DP needs $O(N)$ space (if input is one dimentional array) as it needs to store the computed information.
*** Rod cutting example
:PROPERTIES:
:NOTER_PAGE: 381
:END:
:LOGBOOK:
CLOCK: [2020-04-22 Wed 13:52]--[2020-04-22 Wed 14:47] =>  0:55
:END:
**** The problem
Given a rod of length ~n~ inches and a table of ~prices[i], i=1,2,...,n~, determine the maximum revenue ~rn~ obtainable
by cutting up the rod and selling the pieces. Note that if the price ~prices[n]~ for a rod of length
~n~ is large enough, an optimal solution may require no cutting at all.
**** The solution
:PROPERTIES:
:NOTER_PAGE: 382
:END:
:LOGBOOK:
CLOCK: [2020-04-22 Wed 17:13]--[2020-04-22 Wed 17:13] =>  0:00
CLOCK: [2020-04-22 Wed 14:59]--[2020-04-22 Wed 15:05] =>  0:06
CLOCK: [2020-04-22 Wed 14:56]--[2020-04-22 Wed 14:57] =>  0:01
:END:
To cut a rod of length ~n~ into rods of 1 inch, we need to cut ~n-1~ times.
By thinking of this as a problem of bitmasking, where we have a binary number of ~n-1~ bits,
and 1 represents cut, 0 represents no cut, it is easy to deduce that the number of possible ways
to cut the rod is $2^{n-1}$.

Given the ~prices~ table, any revenue $r_n$ of a length ~n~ rod can be represented as follows:
$r_n=\max(p_n, r_1+r_{n-1}, r_2+r_{n-2},...,r_{n-1}+r_1)$. ([[recursively-define-value][Recursively define the value of an optimal solution]])
$p_n$ corresponds to making no cuts at all. The remaining ~n-1~ arguments correspond to the maximum
revenue obtained by making an initial cut of the rod into two pieces of size ~i~ and ~n-i~, 
for each $i=1,2,...,n-1$, and then optimally cutting up those pieces further, 
obtaining revenues $r_i$ and and $r_{n-i}$ from those two pieces.

We say the rod-cutting problem exihibits *optimal substructure*, i.e. optimal solutions to a problem
incorporate optimal solutions to related subproblems, which we may solve independently.
It also has overlapping subsubproblems. For example, one needs to $r_1$ twice for $r_i$ and $r_{n-i}$.

The equation $r_n=\max(p_n, r_1+r_{n-1}, r_2+r_{n-2},...,r_{n-1}+r_1)$ has duplicate values
since when doing cutting (bitmasking), "100" is the same as "001".
Therefore, we can simplify this process of cutting by the following:
1. We cut a first piece of length ~i~ off the left-hand end
2. We only further divided the right-hand end remainder of length ~n-i~.
3. The revenue is then $r_n=\max_{1\le i\le n}(p_i+r_{n-i})$, which removes one recursion ($r_i$) for us.

***** Recursive top-down implementation
:PROPERTIES:
:NOTER_PAGE: 384
:END:
Here is an implementation of the above formula $r_n=\max_{1\le i\le n}(p_i+r_{n-i})$.
#+caption: cutting rod recursive top-down implementation
#+name: cutting rod recursive top-down implementation
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>
def cut_rod(p: List[int], n: int) -> int:
    from math import inf
    if n == 0:
        return 0
    q = -inf
    for i in range(1, n+1):
        # implementation detail
        # the array in the book starts with 1
        # here the array starts with 0
        q = max(q, p[i-1]+cut_rod(p, n-i))
    return q
print(cut_rod([1,2,3,9], 3))
#+end_src

#+RESULTS: cutting rod recursive top-down implementation
#+begin_src none
3
#+end_src

#+caption: cutting rod recursive top-down implementation-results

This implementation is slow because it's time complexity is $O(n^2),\text{ where }n=\text{len}(p)$.
Many same operations were done multiple times. 
For example, when solving ~cut_rod(p, n)~ and ~cut_rod(p, n-1)~, ~cut_rod(p, n-2)~ was calculated twice.

***** Dynamic programming solution
:PROPERTIES:
:NOTER_PAGE: 385
:END:
:LOGBOOK:
CLOCK: [2020-04-22 Wed 15:05]--[2020-04-22 Wed 15:34] =>  0:29
:END:
We only need to solve one problem in [[*Recursive top-down implementation]] to make it significantly faster,
namely, we want to solve each subproblem exactly *once* and save it (extra memory) for future use.

Dynamic programming runs in polynomial time when the number of /distinct/ subproblems involved
is polynomial in the input size and we can solve each sub subproblem in polynomial time.
There are usually two ways to implement a dynamic programming approach - top-down with memoization
and bottom-up.

Top-down with memoization:
1. Recursive
2. Save the result of each subproblem in an array or hash table
3. For every subproblem, first check if we have already solved it
4. If so, just return the value
5. If not, compute the value for the subproblem

Bottom-up:
1. Typically depends on some natural notion of the "size" of a subproblem, s.t. solving any particular subproblem depends only on solving "smaller" subproblems.
2. We sort the subproblems by size and solve them in size order, smallest first.
3. When solving a particular subproblem, we have already solved all of the smaller subproblems its solution depends upon beforehand, and we have saved their solutions.

These two methods are asymptotically the same.

****** top-bottom approach code
:PROPERTIES:
:NOTER_PAGE: 386
:END:
Here is the Python code for dynamic programming using top-bottom memoization method.
#+caption: top-bottom dynamic programming meoization
#+name: top-bottom dynamic programming meoization
#+begin_src ein-python :session localhost :results output code 
def memoized_cut_rod(p, n):
    from math import inf
    def memoized_cut_rod_aux(p, n, r):
        if r[n] >= 0:
            return r[n]
        if n == 0:
            q = 0
        else:
            q = -inf
            for i in range(1, n+1):
                q = max(q, p[i-1]+memoized_cut_rod_aux(p, n-i, r))
                r[n] = q
        return q

    r = [-inf for i in range(n+1)]

    return memoized_cut_rod_aux(p, n, r)
print(memoized_cut_rod([1,2,3,9], 3))
#+end_src

#+RESULTS: top-bottom dynamic programming meoization
#+begin_src none
3
#+end_src

#+caption: top-bottom dynamic programming meoization-results

****** bottom-up approach code
:PROPERTIES:
:NOTER_PAGE: 387
:END:
:LOGBOOK:
CLOCK: [2020-04-22 Wed 17:14]--[2020-04-22 Wed 17:16] =>  0:02
CLOCK: [2020-04-22 Wed 16:30]--[2020-04-22 Wed 16:47] =>  0:17
CLOCK: [2020-04-22 Wed 15:47]--[2020-04-22 Wed 16:23] =>  0:36
CLOCK: [2020-04-22 Wed 15:34]--[2020-04-22 Wed 15:37] =>  0:03
:END:
Here is the bottom-up approach, which is simpler and easier to understand for me.
Recall the revenue is $r_n=\max_{1\le i\le n}(p_i+r_{n-i})$.
We need to prove that $r_n=\max(p_n, r_1+r_{n-1}, r_2+r_{n-2},...,r_{n-1}+r_1)$ is in effect
equivalent to $r_n=\max_{1\le i\le n}(p_i+r_{n-i})$, so that we can justify the use of an inner loop in the code below.
#+caption: bottom-up dynamic programming approach
#+name: bottom-up dynamic programming approach
#+begin_src ein-python :session localhost :results output code 
def bottom_up_cut_rod(p, n):
    from math import inf

    r = [0 for i in range(n+1)]
    for i in range(1, n+1):
        q = -inf
        # This inner loop is introduced because
        # we cannot know, ahead of time, the best cutting strategy
        # that will give us the highest return.
        # Therefore we need to check all possible strategies,
        # which were already calculated.
        for j in range(1, i+1):
            # p[j-1] is the price of a length j rod
            # r[i-j] is the best return of length i-j rod, which should be already calculated
            #q = max(q, p[j-1] + r[i-j])
            # q is the possible return from previous operations in this inner loop
            q = max(q, r[j] + r[i-j], p[j-1]) # this is easier to understand
            r[i] = q
    return r[n]
print(bottom_up_cut_rod([1,4,4,4,9], 4))
#+end_src

#+RESULTS: bottom-up dynamic programming approach
#+begin_src none
8
#+end_src

#+caption: bottom-up dynamic programming approach-results

****** Reconstructing a solution
:PROPERTIES:
:NOTER_PAGE: 389
:END:


* Clock table
#+BEGIN: clocktable :scope file :maxlevel 1
#+CAPTION: Clock summary at [2020-04-24 Fri 21:22]
| Headline                             |    Time |
|--------------------------------------+---------|
| *Total time*                         | *19:06* |
|--------------------------------------+---------|
| Problems                             |    8:49 |
| Algorithms                           |    0:40 |
| Techniques                           |    0:18 |
| CLRS Notes & Yufei Tao lecture notes |    6:02 |
| Exporting                            |    0:38 |
| Fix up                               |    2:39 |
#+END:

* Exporting                                                        :noexport:
:LOGBOOK:
CLOCK: [2020-04-24 Fri 14:49]--[2020-04-24 Fri 15:27] =>  0:38
:END:
* Fix up                                                           :noexport:
:LOGBOOK:
CLOCK: [2020-04-24 Fri 16:24]--[2020-04-24 Fri 16:25] =>  0:01
:END:
** DONE Captions and names for code result block
:LOGBOOK:
CLOCK: [2020-04-25 Sat 09:29]--[2020-04-25 Sat 09:38] =>  0:09
CLOCK: [2020-04-24 Fri 20:00]--[2020-04-24 Fri 20:56] =>  0:56
CLOCK: [2020-04-24 Fri 17:44]--[2020-04-24 Fri 18:13] =>  0:29
CLOCK: [2020-04-24 Fri 16:25]--[2020-04-24 Fri 17:38] =>  1:13
:END:
In ~ob-ein.el~, set ~KEEP-KEYWORD~ to ~t~ for ~(org-babel-remove-result)~.
* Appendix
#+TOC: listings
#+TOC: tables

