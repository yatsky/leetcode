#+FILETAG: :learning:note:
#+LATEX_HEADER: \usepackage{amsmath}

* Introduction
This is the main file that contains all the problems and their solutions.
Each problem is organised as follows:
- Problem number Problem name         :problem_tag:
- Description (Basic info)
  - Examples
- Solution (Tackling process)
  - Problem category
  - Algorithm (written by me)
  - Code (written by me)
  - Complexity
    - Time complexity
    - Space complexity
  - Leetcode solution
    - Time complexity
    - Space complexity
- More analysis (Thoughts)
  - General thoughts
  - Related problems
* Problems
Here we start to finish our problems ðŸ˜ˆ.
** Imports for typing
#+caption: imports for typing
#+name: imports for typing
#+begin_src ein-python :session localhost :results output code :noweb yes
from typing import List, Tuple, Set
#+end_src

#+caption: imports for typing-results

#+RESULTS: imports for typing
** 1313 Decompress Run-length encoded list                           :array:
*** Description
:LOGBOOK:
CLOCK: [2020-04-16 Thu 20:09]--[2020-04-16 Thu 20:13] =>  0:04
:END:
We are given a list ~nums~ of integers representing a list compressed with run-length encoding.

Consider each adjacent pair of elements ~[freq, val]=[nums[2*i], nums[2*i+1]], i>=0~.
For each such pair, there are ~freq~ elements with value ~val~ concatenated in a sublist.
Concatenate all the sublists from left to right to generate the decompressed list.

Return the decompressed list.

Constraints:
1. 2 <= nums.length <= 100
2. nums.length % 2 == 0
3. 1 <= nums[i] <= 100
**** Examples:
#+name: 1313 Decompress Run-length encoded list example
#+caption: 1313 Decompress Run-length encoded list example
#+begin_example
Input: nums = [1,2,3,4]
Output: [2,4,4,4]
Explanation: The first pair [1,2] means we have freq = 1 and val = 2 so we generate the array [2].
The second pair [3,4] means we have freq = 3 and val = 4 so we generate [4,4,4].
At the end the concatenation [2] + [4,4,4] is [2,4,4,4].

Input: nums = [1,1,2,3]
Output: [1,3,3]
#+end_example

*** Solution

**** Problem category
Just an array problem.
**** Algorithm
:LOGBOOK:
CLOCK: [2020-04-16 Thu 20:13]--[2020-04-16 Thu 20:15] =>  0:02
:END:
We can use ~for i in range(len(nums), 2)~ and create a sublist for all ~nums[i-1], nums[i]~.
Finally we concatenate these sublists.
**** Code
:LOGBOOK:
CLOCK: [2020-04-16 Thu 20:15]--[2020-04-16 Thu 20:19] =>  0:04
:END:
#+name: 1313 Decompress Run-length encoded list my solution
#+caption: 1313 Decompress Run-length encoded list my solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>

def decompress_RLE_list(nums: List[int]) -> List[int]:
    res = []
    for i in range(0, len(nums), 2):
        sub_lst = [nums[i+1] for j in range(nums[i])]
        res = res+sub_lst
    return res
print(decompress_RLE_list([1,1,2,3]))
#+end_src

#+RESULTS: 1313 Decompress Run-length encoded list my solution
#+begin_src none
[1, 3, 3]
#+end_src

**** Complexity
***** Time complexity:
:LOGBOOK:
CLOCK: [2020-04-16 Thu 20:25]--[2020-04-16 Thu 20:25] =>  0:00
CLOCK: [2020-04-16 Thu 20:21]--[2020-04-16 Thu 20:25] =>  0:04
:END:
$O(M)\text{, where } M=\sum_{i=0,2,4...}^{len(nums)-2}nums[i]$, the summation corresponds to the outer ~for~ loop, we simply sum up the time it takes to build each sub list.
***** Space complexity: 
$O(M)\text{, where } M=\sum_{i=0,2,4...}^{len(nums)-2}nums[i]$

**** Leetcode solution
Not available.
#+name: 1313 Decompress Run-length encoded list leetcode solution
#+caption: 1313 Decompress Run-length encoded list leetcode solution
#+begin_src ein-python :session localhost :results output code

#+end_src

***** Time complexity:

***** Space complexity: 

*** More analysis
**** General thoughts
To concatenate lists in Python.
#+caption: concatenate lists
#+name: concatenate lists
#+begin_src ein-python :session localhost :results output code 
lst1=[1,2,3]
lst2=[3,3,3]
print(lst1+lst2)
#+end_src

#+RESULTS: concatenate lists
#+begin_src none
[1, 2, 3, 3, 3, 3]
#+end_src

#+caption: concatenate lists-results
**** Related problems


** 1295 Find numbers with even number of digits                      :array:
*** Description
:LOGBOOK:
CLOCK: [2020-04-16 Thu 20:51]--[2020-04-16 Thu 20:53] =>  0:02
:END:
Given an array ~nums~ of integers, return how many of them contain an *even number* of digits.

Constraints:
1. 1 <= nums.length <= 500
2. 1 <= nums[i] <= 10^5
**** Examples:
#+name: 1295 Find numbers with even number of digits example
#+caption: 1295 Find numbers with even number of digits example
#+begin_example
Input: nums = [12,345,2,6,7896]
Output: 2
Explanation: 
12 contains 2 digits (even number of digits). 
345 contains 3 digits (odd number of digits). 
2 contains 1 digit (odd number of digits). 
6 contains 1 digit (odd number of digits). 
7896 contains 4 digits (even number of digits). 
Therefore only 12 and 7896 contain an even number of digits.

Input: nums = [555,901,482,1771]
Output: 1 
Explanation: 
Only 1771 contains an even number of digits.
#+end_example

*** Solution

**** Problem category

**** Algorithm
:LOGBOOK:
CLOCK: [2020-04-16 Thu 20:53]--[2020-04-16 Thu 20:54] =>  0:01
:END:
We simply loop the ~nums~ and check each number.
We can use this to get the number of all digits of a number: ~len(str(num))~.
**** Code
:LOGBOOK:
CLOCK: [2020-04-16 Thu 20:56]--[2020-04-16 Thu 20:57] =>  0:01
:END:
#+name: 1295 Find numbers with even number of digits my solution
#+caption: 1295 Find numbers with even number of digits my solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>

def find_numbers(nums: List[int]) -> int:
    res = 0
    for ele in nums:
        if len(str(ele)) % 2 == 0:
            res += 1
    return res
print(find_numbers([1,2,3]))
print(find_numbers([11,2,3]))
#+end_src

#+RESULTS: 1295 Find numbers with even number of digits my solution
#+begin_src none
0
1
#+end_src

**** Complexity
***** Time complexity:
$O(N)$.
***** Space complexity: 
$O(N)$.

**** Leetcode solution
Not available.
#+name: 1295 Find numbers with even number of digits leetcode solution
#+caption: 1295 Find numbers with even number of digits leetcode solution
#+begin_src ein-python :session localhost :results output code

#+end_src

***** Time complexity:

***** Space complexity: 

*** More analysis
**** General thoughts
Pretty straightforward.
**** Related problems


** 1365 How many numbers are smaller than the current number         :array:
*** Description
Given the array ~nums~, for each ~nums[i]~, find out how many numbers in the array are smaller than it.
That is, for each ~nums[i]~, you have to count the number of valid ~j~'s, such that ~j != i and nums[j] < nums[i]>~.

Return the answer in an array.

Constraints:

1. 2 <= nums.length <= 500
2. 0 <= nums[i] <= 100
**** Examples:
#+name: 1365 How many numbers are smaller than the current number example
#+caption: 1365 How many numbers are smaller than the current number example
#+begin_example
Input: nums = [8,1,2,2,3]
Output: [4,0,1,1,3]
Explanation: 
For nums[0]=8 there exist four smaller numbers than it (1, 2, 2 and 3). 
For nums[1]=1 does not exist any smaller number than it.
For nums[2]=2 there exist one smaller number than it (1). 
For nums[3]=2 there exist one smaller number than it (1). 
For nums[4]=3 there exist three smaller numbers than it (1, 2 and 2).

Input: nums = [6,5,4,8]
Output: [2,1,0,3]

Input: nums = [7,7,7,7]
Output: [0,0,0,0]
#+end_example

*** Solution

**** Problem category

**** Algorithm
:LOGBOOK:
CLOCK: [2020-04-16 Thu 21:17]--[2020-04-16 Thu 21:19] =>  0:02
:END:
We first sort ~nums~, and get ~sorted_nums~.
We loop through ~sorted_nums~, and get ~smaller_count~ mapping in the form of ~{num: smaller_count}~.
We then loop ~nums~ and get ~smaller_count~ of each ~num~, store them in ~res~.
**** Code
:LOGBOOK:
CLOCK: [2020-04-16 Thu 21:20]--[2020-04-16 Thu 21:26] =>  0:06
:END:
#+name: 1365 How many numbers are smaller than the current number my solution
#+caption: 1365 How many numbers are smaller than the current number my solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>

def smaller_numbers_than_current(nums: List[int]) -> List[int]:
    import math
    sorted_nums = sorted(nums)

    smaller_counts = {}
    for i, e in enumerate(sorted_nums):
        smaller_counts[e] = min(smaller_counts.get(e, math.inf), i)

    res = []
    for num in nums:
        res.append(smaller_counts[num])

    return res
print(smaller_numbers_than_current([2,2,3,4,1]))
#+end_src

#+RESULTS: 1365 How many numbers are smaller than the current number my solution
#+begin_src none
[1, 1, 3, 4, 0]
#+end_src

**** Complexity
***** Time complexity:
$O(N\log{N})$.
***** Space complexity: 
$O(N)$.

**** Leetcode solution
Not available.
#+name: 1365 How many numbers are smaller than the current number leetcode solution
#+caption: 1365 How many numbers are smaller than the current number leetcode solution
#+begin_src ein-python :session localhost :results output code

#+end_src

***** Time complexity:

***** Space complexity: 

*** More analysis
**** General thoughts
The best time complexity we can do is $O(N\log N)$.
**** Related problems


** DONE 1409 Queries on a permutation with key                :array:medium:
*** Description
:LOGBOOK:
CLOCK: [2020-04-17 Fri 08:47]--[2020-04-17 Fri 08:53] =>  0:06
:END:
Given the array ~queries~ of positive integers between ~1~ and ~m~, you have to process all ~queries[i]~ (from ~i=0~ to ~i=queries.length-1~) according to the following rules:
1. in the beginning, you have the permutation ~P=[1,2,3,...,m]~.
2. For the current ~i~, find the position of ~queries[i]~ in the permutation ~P~ (indexing from 0) and then move this at the begining of the permutation ~P~. Notice that the position of ~queries[i]~ in ~P~ is the result for ~queries[i]~.

Return an array containing the result for the given ~queries~.

Constraints:

1. 1 <= m <= 10^3
2. 1 <= queries.length <= m
3. 1 <= queries[i] <= m
**** Examples:
#+name: 1409 Queries on a permutation with key example
#+caption: 1409 Queries on a permutation with key example
#+begin_example
Input: queries = [3,1,2,1], m = 5
Output: [2,1,2,1] 
Explanation: The queries are processed as follow: 
For i=0: queries[i]=3, P=[1,2,3,4,5], position of 3 in P is 2, then we move 3 to the beginning of P resulting in P=[3,1,2,4,5]. 
For i=1: queries[i]=1, P=[3,1,2,4,5], position of 1 in P is 1, then we move 1 to the beginning of P resulting in P=[1,3,2,4,5]. 
For i=2: queries[i]=2, P=[1,3,2,4,5], position of 2 in P is 2, then we move 2 to the beginning of P resulting in P=[2,1,3,4,5]. 
For i=3: queries[i]=1, P=[2,1,3,4,5], position of 1 in P is 1, then we move 1 to the beginning of P resulting in P=[1,2,3,4,5]. 
Therefore, the array containing the result is [2,1,2,1].  

Input: queries = [4,1,2,2], m = 4
Output: [3,1,2,0]

Input: queries = [7,5,5,8,3], m = 8
Output: [6,5,0,7,5]
#+end_example

*** Solution

**** Problem category

**** Algorithm
:LOGBOOK:
CLOCK: [2020-04-17 Fri 08:53]--[2020-04-17 Fri 09:01] =>  0:08
:END:
We can use brute force.
We loop through queries ~for i, e in enumerate(queries)~, then have an inner loop ~for j, e_p in enumerate(p_copy)~, when ~e_p==e~, we do ~P.pop(j)~, ~P.insert(0, e_p)~, and ~res.append(j)~.
**** Code
:LOGBOOK:
CLOCK: [2020-04-17 Fri 09:01]--[2020-04-17 Fri 09:05] =>  0:04
:END:
#+name: 1409 Queries on a permutation with key my solution
#+caption: 1409 Queries on a permutation with key my solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>

def process_queries(queries: List[int], m: int) -> List[int]:
    res = []

    p = list(range(1, m+1))
    p_copy = p.copy()
    for i, e in enumerate(queries):
        p_copy = p.copy()
        for j, e_p in enumerate(p_copy):
            if e_p == e:
                p.pop(j)
                p.insert(0, e_p)
                res.append(j)

    return res

print(process_queries([3,1,2,1],5))
#+end_src

#+RESULTS: 1409 Queries on a permutation with key my solution
#+begin_src none
[2, 1, 2, 1]
#+end_src

**** Complexity
***** Time complexity:
$O(N\times M)\text{ , where }N=len(queries), M=m$.
***** Space complexity: 
$O(M)$.
**** Leetcode solution
:LOGBOOK:
CLOCK: [2020-04-17 Fri 09:33]--[2020-04-17 Fri 09:34] =>  0:01
:END:
Not available.

Here is one interesting solution from the discussion forum.
#+name: 1409 Queries on a permutation with key discussion solution
#+caption: 1409 Queries on a permutation with key discussion solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>

def process_queries(queries: List[int], m: int) -> List[int]:
    # the original code uses
    # def process(arr, idx), which is quite confusing
    # as we are trying to find the idx of an element
    def process(arr, elem):
        ans = arr.index(elem)
        arr.insert(0, arr.pop(ans))
        return ans

    m = [x for x in range(1, m+1)]
    return [process(m, i) for i in queries]

print(process_queries([3,1,2,1],5))
#+end_src

#+RESULTS: 1409 Queries on a permutation with key discussion solution
#+begin_src none
[2, 1, 2, 1]
#+end_src

***** Time complexity:
$O(N\times M)\text{ , where }N=len(queries), M=m$.

***** Space complexity: 
$O(M)$.

*** More analysis
**** General thoughts
**** Related problems


* Data structures
This section contains widely used data structures and related problems.
* Algorithms
This section contains widely used algorithms and related problems.
* Techniques
This section contains techniques that do not make a full algorithm and related problems.
** General
** Python
