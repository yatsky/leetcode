#+FILETAG: :learning:note:
#+LATEX_HEADER: \usepackage{amsmath}

* Introduction
This is the main file that contains all the problems and their solutions.
Each problem is organised as follows:
- Problem number Problem name         :problem_tag:
- Description (Basic info)
  - Examples
- Solution (Tackling process)
  - Problem category
  - Algorithm (written by me)
  - Code (written by me)
  - Complexity
    - Time complexity
    - Space complexity
  - Leetcode solution
    - Time complexity
    - Space complexity
- More analysis (Thoughts)
  - General thoughts
  - Related problems
* Problems
Here we start to finish our problems ðŸ˜ˆ.
** Imports for typing
#+caption: imports for typing
#+name: imports for typing
#+begin_src ein-python :session localhost :results output code :noweb yes
from typing import List, Tuple, Set
#+end_src

#+caption: imports for typing-results

#+RESULTS: imports for typing
** DONE 1313 Decompress Run-length encoded list                 :array:easy:
*** Description
:LOGBOOK:
CLOCK: [2020-04-16 Thu 20:09]--[2020-04-16 Thu 20:13] =>  0:04
:END:
We are given a list ~nums~ of integers representing a list compressed with run-length encoding.

Consider each adjacent pair of elements ~[freq, val]=[nums[2*i], nums[2*i+1]], i>=0~.
For each such pair, there are ~freq~ elements with value ~val~ concatenated in a sublist.
Concatenate all the sublists from left to right to generate the decompressed list.

Return the decompressed list.

Constraints:
1. 2 <= nums.length <= 100
2. nums.length % 2 == 0
3. 1 <= nums[i] <= 100
**** Examples:
#+name: 1313 Decompress Run-length encoded list example
#+caption: 1313 Decompress Run-length encoded list example
#+begin_example
Input: nums = [1,2,3,4]
Output: [2,4,4,4]
Explanation: The first pair [1,2] means we have freq = 1 and val = 2 so we generate the array [2].
The second pair [3,4] means we have freq = 3 and val = 4 so we generate [4,4,4].
At the end the concatenation [2] + [4,4,4] is [2,4,4,4].

Input: nums = [1,1,2,3]
Output: [1,3,3]
#+end_example

*** Solution

**** Problem category
Just an array problem.
**** Algorithm
:LOGBOOK:
CLOCK: [2020-04-16 Thu 20:13]--[2020-04-16 Thu 20:15] =>  0:02
:END:
We can use ~for i in range(len(nums), 2)~ and create a sublist for all ~nums[i-1], nums[i]~.
Finally we concatenate these sublists.
**** Code
:LOGBOOK:
CLOCK: [2020-04-16 Thu 20:15]--[2020-04-16 Thu 20:19] =>  0:04
:END:
#+name: 1313 Decompress Run-length encoded list my solution
#+caption: 1313 Decompress Run-length encoded list my solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>

def decompress_RLE_list(nums: List[int]) -> List[int]:
    res = []
    for i in range(0, len(nums), 2):
        sub_lst = [nums[i+1] for j in range(nums[i])]
        res = res+sub_lst
    return res
print(decompress_RLE_list([1,1,2,3]))
#+end_src

#+RESULTS: 1313 Decompress Run-length encoded list my solution
#+begin_src none
[1, 3, 3]
#+end_src

**** Complexity
***** Time complexity:
:LOGBOOK:
CLOCK: [2020-04-16 Thu 20:25]--[2020-04-16 Thu 20:25] =>  0:00
CLOCK: [2020-04-16 Thu 20:21]--[2020-04-16 Thu 20:25] =>  0:04
:END:
$O(M)\text{, where } M=\sum_{i=0,2,4...}^{len(nums)-2}nums[i]$, the summation corresponds to the outer ~for~ loop, we simply sum up the time it takes to build each sub list.
***** Space complexity: 
$O(M)\text{, where } M=\sum_{i=0,2,4...}^{len(nums)-2}nums[i]$

**** Leetcode solution
Not available.
#+name: 1313 Decompress Run-length encoded list leetcode solution
#+caption: 1313 Decompress Run-length encoded list leetcode solution
#+begin_src ein-python :session localhost :results output code

#+end_src

***** Time complexity:

***** Space complexity: 

*** More analysis
**** General thoughts
To concatenate lists in Python.
#+caption: concatenate lists
#+name: concatenate lists
#+begin_src ein-python :session localhost :results output code 
lst1=[1,2,3]
lst2=[3,3,3]
print(lst1+lst2)
#+end_src

#+RESULTS: concatenate lists
#+begin_src none
[1, 2, 3, 3, 3, 3]
#+end_src

#+caption: concatenate lists-results
**** Related problems


** DONE 1295 Find numbers with even number of digits            :array:easy:
*** Description
:LOGBOOK:
CLOCK: [2020-04-16 Thu 20:51]--[2020-04-16 Thu 20:53] =>  0:02
:END:
Given an array ~nums~ of integers, return how many of them contain an *even number* of digits.

Constraints:
1. 1 <= nums.length <= 500
2. 1 <= nums[i] <= 10^5
**** Examples:
#+name: 1295 Find numbers with even number of digits example
#+caption: 1295 Find numbers with even number of digits example
#+begin_example
Input: nums = [12,345,2,6,7896]
Output: 2
Explanation: 
12 contains 2 digits (even number of digits). 
345 contains 3 digits (odd number of digits). 
2 contains 1 digit (odd number of digits). 
6 contains 1 digit (odd number of digits). 
7896 contains 4 digits (even number of digits). 
Therefore only 12 and 7896 contain an even number of digits.

Input: nums = [555,901,482,1771]
Output: 1 
Explanation: 
Only 1771 contains an even number of digits.
#+end_example

*** Solution

**** Problem category

**** Algorithm
:LOGBOOK:
CLOCK: [2020-04-16 Thu 20:53]--[2020-04-16 Thu 20:54] =>  0:01
:END:
We simply loop the ~nums~ and check each number.
We can use this to get the number of all digits of a number: ~len(str(num))~.
**** Code
:LOGBOOK:
CLOCK: [2020-04-16 Thu 20:56]--[2020-04-16 Thu 20:57] =>  0:01
:END:
#+name: 1295 Find numbers with even number of digits my solution
#+caption: 1295 Find numbers with even number of digits my solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>

def find_numbers(nums: List[int]) -> int:
    res = 0
    for ele in nums:
        if len(str(ele)) % 2 == 0:
            res += 1
    return res
print(find_numbers([1,2,3]))
print(find_numbers([11,2,3]))
#+end_src

#+RESULTS: 1295 Find numbers with even number of digits my solution
#+begin_src none
0
1
#+end_src

**** Complexity
***** Time complexity:
$O(N)$.
***** Space complexity: 
$O(N)$.

**** Leetcode solution
Not available.
#+name: 1295 Find numbers with even number of digits leetcode solution
#+caption: 1295 Find numbers with even number of digits leetcode solution
#+begin_src ein-python :session localhost :results output code

#+end_src

***** Time complexity:

***** Space complexity: 

*** More analysis
**** General thoughts
Pretty straightforward.
**** Related problems


** DONE 1365 How many numbers are smaller than the current number :array:easy:
*** Description
Given the array ~nums~, for each ~nums[i]~, find out how many numbers in the array are smaller than it.
That is, for each ~nums[i]~, you have to count the number of valid ~j~'s, such that ~j != i and nums[j] < nums[i]>~.

Return the answer in an array.

Constraints:

1. 2 <= nums.length <= 500
2. 0 <= nums[i] <= 100
**** Examples:
#+name: 1365 How many numbers are smaller than the current number example
#+caption: 1365 How many numbers are smaller than the current number example
#+begin_example
Input: nums = [8,1,2,2,3]
Output: [4,0,1,1,3]
Explanation: 
For nums[0]=8 there exist four smaller numbers than it (1, 2, 2 and 3). 
For nums[1]=1 does not exist any smaller number than it.
For nums[2]=2 there exist one smaller number than it (1). 
For nums[3]=2 there exist one smaller number than it (1). 
For nums[4]=3 there exist three smaller numbers than it (1, 2 and 2).

Input: nums = [6,5,4,8]
Output: [2,1,0,3]

Input: nums = [7,7,7,7]
Output: [0,0,0,0]
#+end_example

*** Solution

**** Problem category

**** Algorithm
:LOGBOOK:
CLOCK: [2020-04-16 Thu 21:17]--[2020-04-16 Thu 21:19] =>  0:02
:END:
We first sort ~nums~, and get ~sorted_nums~.
We loop through ~sorted_nums~, and get ~smaller_count~ mapping in the form of ~{num: smaller_count}~.
We then loop ~nums~ and get ~smaller_count~ of each ~num~, store them in ~res~.
**** Code
:LOGBOOK:
CLOCK: [2020-04-16 Thu 21:20]--[2020-04-16 Thu 21:26] =>  0:06
:END:
#+name: 1365 How many numbers are smaller than the current number my solution
#+caption: 1365 How many numbers are smaller than the current number my solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>

def smaller_numbers_than_current(nums: List[int]) -> List[int]:
    import math
    sorted_nums = sorted(nums)

    smaller_counts = {}
    for i, e in enumerate(sorted_nums):
        smaller_counts[e] = min(smaller_counts.get(e, math.inf), i)

    res = []
    for num in nums:
        res.append(smaller_counts[num])

    return res
print(smaller_numbers_than_current([2,2,3,4,1]))
#+end_src

#+RESULTS: 1365 How many numbers are smaller than the current number my solution
#+begin_src none
[1, 1, 3, 4, 0]
#+end_src

**** Complexity
***** Time complexity:
$O(N\log{N})$.
***** Space complexity: 
$O(N)$.

**** Leetcode solution
Not available.
#+name: 1365 How many numbers are smaller than the current number leetcode solution
#+caption: 1365 How many numbers are smaller than the current number leetcode solution
#+begin_src ein-python :session localhost :results output code

#+end_src

***** Time complexity:

***** Space complexity: 

*** More analysis
**** General thoughts
The best time complexity we can do is $O(N\log N)$.
**** Related problems


** DONE 1409 Queries on a permutation with key                :array:medium:
*** Description
:LOGBOOK:
CLOCK: [2020-04-17 Fri 08:47]--[2020-04-17 Fri 08:53] =>  0:06
:END:
Given the array ~queries~ of positive integers between ~1~ and ~m~, you have to process all ~queries[i]~ (from ~i=0~ to ~i=queries.length-1~) according to the following rules:
1. in the beginning, you have the permutation ~P=[1,2,3,...,m]~.
2. For the current ~i~, find the position of ~queries[i]~ in the permutation ~P~ (indexing from 0) and then move this at the begining of the permutation ~P~. Notice that the position of ~queries[i]~ in ~P~ is the result for ~queries[i]~.

Return an array containing the result for the given ~queries~.

Constraints:

1. 1 <= m <= 10^3
2. 1 <= queries.length <= m
3. 1 <= queries[i] <= m
**** Examples:
#+name: 1409 Queries on a permutation with key example
#+caption: 1409 Queries on a permutation with key example
#+begin_example
Input: queries = [3,1,2,1], m = 5
Output: [2,1,2,1] 
Explanation: The queries are processed as follow: 
For i=0: queries[i]=3, P=[1,2,3,4,5], position of 3 in P is 2, then we move 3 to the beginning of P resulting in P=[3,1,2,4,5]. 
For i=1: queries[i]=1, P=[3,1,2,4,5], position of 1 in P is 1, then we move 1 to the beginning of P resulting in P=[1,3,2,4,5]. 
For i=2: queries[i]=2, P=[1,3,2,4,5], position of 2 in P is 2, then we move 2 to the beginning of P resulting in P=[2,1,3,4,5]. 
For i=3: queries[i]=1, P=[2,1,3,4,5], position of 1 in P is 1, then we move 1 to the beginning of P resulting in P=[1,2,3,4,5]. 
Therefore, the array containing the result is [2,1,2,1].  

Input: queries = [4,1,2,2], m = 4
Output: [3,1,2,0]

Input: queries = [7,5,5,8,3], m = 8
Output: [6,5,0,7,5]
#+end_example

*** Solution

**** Problem category

**** Algorithm
:LOGBOOK:
CLOCK: [2020-04-17 Fri 08:53]--[2020-04-17 Fri 09:01] =>  0:08
:END:
We can use brute force.
We loop through queries ~for i, e in enumerate(queries)~, then have an inner loop ~for j, e_p in enumerate(p_copy)~, when ~e_p==e~, we do ~P.pop(j)~, ~P.insert(0, e_p)~, and ~res.append(j)~.
**** Code
:LOGBOOK:
CLOCK: [2020-04-17 Fri 09:01]--[2020-04-17 Fri 09:05] =>  0:04
:END:
#+name: 1409 Queries on a permutation with key my solution
#+caption: 1409 Queries on a permutation with key my solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>

def process_queries(queries: List[int], m: int) -> List[int]:
    res = []

    p = list(range(1, m+1))
    p_copy = p.copy()
    for i, e in enumerate(queries):
        p_copy = p.copy()
        for j, e_p in enumerate(p_copy):
            if e_p == e:
                p.pop(j)
                p.insert(0, e_p)
                res.append(j)

    return res

print(process_queries([3,1,2,1],5))
#+end_src

#+RESULTS: 1409 Queries on a permutation with key my solution
#+begin_src none
[2, 1, 2, 1]
#+end_src

**** Complexity
***** Time complexity:
$O(N\times M)\text{ , where }N=len(queries), M=m$.
***** Space complexity: 
$O(M)$.
**** Leetcode solution
:LOGBOOK:
CLOCK: [2020-04-17 Fri 09:33]--[2020-04-17 Fri 09:34] =>  0:01
:END:
Not available.

Here is one interesting solution from the discussion forum.
#+name: 1409 Queries on a permutation with key discussion solution
#+caption: 1409 Queries on a permutation with key discussion solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>

def process_queries(queries: List[int], m: int) -> List[int]:
    # the original code uses
    # def process(arr, idx), which is quite confusing
    # as we are trying to find the idx of an element
    def process(arr, elem):
        ans = arr.index(elem)
        arr.insert(0, arr.pop(ans))
        return ans

    m = [x for x in range(1, m+1)]
    return [process(m, i) for i in queries]

print(process_queries([3,1,2,1],5))
#+end_src

#+RESULTS: 1409 Queries on a permutation with key discussion solution
#+begin_src none
[2, 1, 2, 1]
#+end_src

***** Time complexity:
$O(N\times M)\text{ , where }N=len(queries), M=m$.

***** Space complexity: 
$O(M)$.

*** More analysis
**** General thoughts
**** Related problems

** 1329 Sort the matrix diagonally
This is based on an incorrect understanding of the problem description.
See [[*1329 Sort the matrix diagonally 2]] for a correct understanding and solution.
*** Description
:LOGBOOK:
CLOCK: [2020-04-17 Fri 09:55]--[2020-04-17 Fri 09:57] =>  0:02
:END:
Given a ~m*n~ matrix ~mat~ of integers, sort it diagonally in ascending order from the top-left to the bottom-right then return the sorted array.

Constraints:
1. m == mat.length
2. n == mat[i].length
3. 1 <= m, n <= 100
4. 1 <= mat[i][j] <= 100
**** Examples:
#+name: 1329 Sort the matrix diagonally example
#+caption: 1329 Sort the matrix diagonally example
#+begin_example
Input: mat = [[3,3,1,1],[2,2,1,2],[1,1,1,2]]
Output: [[1,1,1,1],[1,2,2,2],[1,2,3,3]]
#+end_example

*** Solution

**** Problem category

**** Algorithm
:LOGBOOK:
CLOCK: [2020-04-17 Fri 10:10]--[2020-04-17 Fri 10:17] =>  0:07
:END:
We first concatenate all lists in the matrix, then sort it to get ~sorted_lst~.
+Then we re-construct the resulting matrix and return it.+
Then we create a new empty ~m*n~ matrix ~res~ filled with ~None~.
We then loop through ~sorted_lst~, and fill the first row of ~res~, then the first column, then second row, second column...
Recall that a 2D array can be mapped to a 1D array.
**** Code
:LOGBOOK:
CLOCK: [2020-04-17 Fri 10:17]--[2020-04-17 Fri 10:41] =>  0:24
CLOCK: [2020-04-17 Fri 10:00]--[2020-04-17 Fri 10:04] =>  0:04
:END:
#+name: 1329 Sort the matrix diagonally my solution
#+caption: 1329 Sort the matrix diagonally my solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>

def diagonal_sort(mat: List[List[int]]) -> List[List[int]]:
    import itertools

    m = len(mat)
    n = len(mat[0])
    res = [[None for i in range(n)] for j in range(m)]
    sorted_lst = sorted(itertools.chain(*mat))

    cur_col = 0
    cur_row = 0

    idx = 0
    while cur_col < n or cur_row < m:
        if cur_col < n:
            for moving_col in range(cur_col, n):
                res[cur_row][moving_col] = sorted_lst[idx]
                idx += 1

            # cur_row+1 so that it does not overwrite
            # the first data in the column
        if cur_row < m:
            for moving_row in range(cur_row+1, m):
                res[moving_row][cur_col] = sorted_lst[idx]
                idx += 1

        cur_col = min(n-1, cur_col+1)
        cur_row = min(m-1, cur_row+1)
        if cur_col == n-1 and cur_row == m-1 and res[m-1][n-1] is not None:
            break
    return res
#print(diagonal_sort([[2,1],[3,2],[3,2]]))
#print(diagonal_sort([[1,2,1],[3,2,4],[7,7,4]]))
#print(diagonal_sort([[3,3,1,1],[2,2,1,2],[1,1,1,2]]))
print(diagonal_sort(
    [[11,25,66,1,69,7],[23,55,17,45,15,52],[75,31,36,44,58,8],[22,27,33,25,68,4],[84,28,14,11,5,50]]
))
#+end_src

#+RESULTS: 1329 Sort the matrix diagonally my solution
#+begin_src none
[[1, 4, 5, 7, 8, 11], [11, 22, 23, 25, 25, 27], [14, 28, 36, 44, 45, 50], [15, 31, 52, 58, 66, 68], [17, 33, 55, 69, 75, 84]]
#+end_src

**** Complexity
***** Time complexity:

***** Space complexity: 

**** Leetcode solution

#+name: 1329 Sort the matrix diagonally leetcode solution
#+caption: 1329 Sort the matrix diagonally leetcode solution
#+begin_src ein-python :session localhost :results output code

#+end_src

***** Time complexity:

***** Space complexity: 

*** More analysis
**** General thoughts
**** Related problems

** DONE 1329 Sort the matrix diagonally 2                     :array:medium:
*** Description

Given a ~m*n~ matrix ~mat~ of integers, sort it diagonally in ascending order from the top-left to the bottom-right then return the sorted array.

Constraints:
1. m == mat.length
2. n == mat[i].length
3. 1 <= m, n <= 100
4. 1 <= mat[i][j] <= 100

**** Examples:
#+name: 1329 Sort the matrix diagonally 2 example
#+caption: 1329 Sort the matrix diagonally 2 example
#+begin_example
Input: mat = [[3,3,1,1],[2,2,1,2],[1,1,1,2]]
Output: [[1,1,1,1],[1,2,2,2],[1,2,3,3]]
#+end_example

*** Solution

**** Problem category

**** Algorithm
:LOGBOOK:
CLOCK: [2020-04-17 Fri 13:47]--[2020-04-17 Fri 13:53] =>  0:06
:END:
With the existing ~mat~, we want to sort each existing diagonal so that they are ascend from top-left to bottom right. We do not want to sort the entire matrix.

We need to first get all the starting cell of each diagonal list ~(x, y)~.
With it, we can easily get the diagonal list by adding 1 to both ~x~ and ~y~.
We then sort each diagonal list and put them back to the ~mat~.
**** Code
#+name: 1329 Sort the matrix diagonally 2 my solution
#+caption: 1329 Sort the matrix diagonally 2 my solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>

def diagonal_sort(mat: List[List[int]]) -> List[List[int]]:
    n = len(mat)
    m = len(mat[0])

    def sort_list(head: Tuple[int]) -> None:
        res = []
        x, y = head
        while x < n and y < m:
            res.append(mat[x][y])
            x+=1
            y+=1

        res.sort()
        res = iter(res)
        x, y = head
        while x < n and y < m:
            mat[x][y] = next(res)
            x+=1
            y+=1

    diagonal_heads = [(x, y) for x in range(n) for y in range(m)]

    for head in diagonal_heads:
        sort_list(head)
        
    return mat
print(diagonal_sort([[4,2,3],[1,3,4]]))
print(diagonal_sort([[2,1],[3,2],[3,2]]))
print(diagonal_sort([[1,2,1],[3,2,4],[7,7,4]]))
print(diagonal_sort([[3,3,1,1],[2,2,1,2],[1,1,1,2]]))
print(diagonal_sort(
    [[11,25,66,1,69,7],[23,55,17,45,15,52],[75,31,36,44,58,8],[22,27,33,25,68,4],[84,28,14,11,5,50]]
))
#+end_src

#+RESULTS: 1329 Sort the matrix diagonally 2 my solution
#+begin_src none
[[3, 2, 3], [1, 4, 4]]
[[2, 1], [2, 2], [3, 3]]
[[1, 2, 1], [3, 2, 4], [7, 7, 4]]
[[1, 1, 1, 1], [1, 2, 2, 2], [1, 2, 3, 3]]
[[5, 17, 4, 1, 52, 7], [11, 11, 25, 45, 8, 69], [14, 23, 25, 44, 58, 15], [22, 27, 31, 36, 50, 66], [84, 28, 75, 33, 55, 68]]
#+end_src

**** Complexity
:LOGBOOK:
CLOCK: [2020-04-17 Fri 14:24]--[2020-04-17 Fri 14:30] =>  0:06
CLOCK: [2020-04-17 Fri 14:24]--[2020-04-17 Fri 14:24] =>  0:00
:END:
***** Time complexity:
:LOGBOOK:
CLOCK: [2020-04-17 Fri 15:00]--[2020-04-17 Fri 15:15] =>  0:15
:END:
This is a bit hard to analyse, but the basic idea is to add up all the time taken to sort all diagonal lists. The total number of such lists is $m+n-1$.
By observation, we can get that the number of the longest diagonal list(s) in the matrix is $|n-m+1|$.
The number of remaining lists would be $m+n-1-|n-m+1|$, which gives us either $2\times (m-1)$ or $2\times (n-1)$.

Therefore, our formula to calculate the total time required by the algorithm is as follows:


$O(2\times (\sum_{i=1}^{\min(n,m)-1} i\log i)+|n-m+1|\times \min(m,n)\times \log{\min(m,n)})$.
***** Space complexity: 

$O(\sqrt{m\times n})$.
**** Leetcode solution
Not available.

Interesting one [[https://leetcode.com/problems/sort-the-matrix-diagonally/discuss/489846/Several-Python-solutions][here]].
#+name: 1329 Sort the matrix diagonally 2 leetcode solution
#+caption: 1329 Sort the matrix diagonally 2 leetcode solution
#+begin_src ein-python :session localhost :results output code
def diagonal_sort(mat):
    m, n = len(mat), len(mat[0])

    def sort(i, j):
        ij = zip(range(i, m), range(j, n))
        vals = iter(sorted(mat[i][j] for i, j in ij))
        for i, j in ij:
            mat[i][j] = next(vals)

    for i in range(m): sort(i, 0)
    for j in range(m): sort(0, j)

    return mat

print(diagonal_sort([[4,2,3],[1,3,4]]))
print(diagonal_sort([[2,1],[3,2],[3,2]]))
print(diagonal_sort([[1,2,1],[3,2,4],[7,7,4]]))
print(diagonal_sort([[3,3,1,1],[2,2,1,2],[1,1,1,2]]))
print(diagonal_sort(
    [[11,25,66,1,69,7],[23,55,17,45,15,52],[75,31,36,44,58,8],[22,27,33,25,68,4],[84,28,14,11,5,50]]
))
#+end_src

#+RESULTS: 1329 Sort the matrix diagonally 2 leetcode solution
#+begin_src none
[[4, 2, 3], [1, 3, 4]]
[[2, 1], [3, 2], [3, 2]]
[[1, 2, 1], [3, 2, 4], [7, 7, 4]]
[[3, 3, 1, 1], [2, 2, 1, 2], [1, 1, 1, 2]]
[[11, 25, 66, 1, 69, 7], [23, 55, 17, 45, 15, 52], [75, 31, 36, 44, 58, 8], [22, 27, 33, 25, 68, 4], [84, 28, 14, 11, 5, 50]]
#+end_src

***** Time complexity:

***** Space complexity: 

*** More analysis
**** General thoughts
**** Related problems

** DONE 1395 Count number of teams                            :array:medium:
*** Description
:LOGBOOK:
CLOCK: [2020-04-17 Fri 19:38]--[2020-04-17 Fri 19:43] =>  0:05
:END:
There are ~n~ soldiers standing in a line. Each soldier is assigned a *unique* ~rating~ value.

You have to form a team of 3 soldiers amongst them under the following rules:
1. Choose 3 soldiers with index(i, j, k) with rating ~(rating[i], rating[j], rating[k])~.
2. A team is valid if: ~(rating[i]<rating[j]<rating[k])~ or ~rating[i]>rating[j]>rating[k]~, where ~0<=i<j<k<n~.

Soldiers can be part of multiple teams.

Return the number of teams you can form given the conditions.

Constraints:
1. n == rating.length
2. 1 <= n <= 200
3. 1 <= rating[i] <= 10^5
**** Examples:
#+name: 1395 Count number of teams example
#+caption: 1395 Count number of teams example
#+begin_example
Input: rating = [2,5,3,4,1]
Output: 3
Explanation: We can form three teams given the conditions. (2,3,4), (5,4,1), (5,3,1). 

Input: rating = [2,1,3]
Output: 0
Explanation: We can't form any team given the conditions.

Input: rating = [1,2,3,4]
Output: 4
#+end_example

*** Solution

**** Problem category

**** Algorithm
:LOGBOOK:
CLOCK: [2020-04-17 Fri 19:43]--[2020-04-17 Fri 19:45] =>  0:02
:END:
We return ~False~ for all ~n<3~.

This is a combination problem. We need to try all combinations of the list.
**** Code
:LOGBOOK:
CLOCK: [2020-04-17 Fri 19:46]--[2020-04-17 Fri 19:50] =>  0:04
:END:
#+name: 1395 Count number of teams my solution
#+caption: 1395 Count number of teams my solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>
def num_teams(rating: List[int]) -> int:
    if len(rating) < 3:
        return 0

    from itertools import combinations

    count = 0
    for comb in combinations(rating, 3):
        if comb[0] < comb[1] < comb[2] or comb[0]>comb[1]>comb[2]:
            count += 1


    return count
print(num_teams([2,5,3,4,1]))
print(num_teams([2,1,3]))
print(num_teams([1,2,3,4]))
print(num_teams([0,1]))
#+end_src

#+RESULTS: 1395 Count number of teams my solution
#+begin_src none
3
0
4
0
#+end_src

**** Complexity
***** Time complexity:
:LOGBOOK:
CLOCK: [2020-04-17 Fri 20:02]--[2020-04-17 Fri 20:04] =>  0:02
:END:
$O(C_{n}^{3})$, i.e. $O(n^3)$.
***** Space complexity: 

$O(1)$.
**** Leetcode solution
:PROPERTIES:
:CUSTOM_ID: 1395 Count number of teams Leetcode
:END:
:LOGBOOK:
CLOCK: [2020-04-20 Mon 16:10]--[2020-04-20 Mon 16:19] =>  0:09
CLOCK: [2020-04-20 Mon 15:09]--[2020-04-20 Mon 15:51] =>  0:42
:END:
Not available.

This following is adapted from [[https://leetcode.com/problems/count-number-of-teams/discuss/554817/Java-O(N2)-Time-O(N)-Space-(Best-Solution)][this Java solution]].
#+name: 1395 Count number of teams efficient solution
#+caption: 1395 Count number of teams efficient solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>
def num_teams(rating: List[int]) -> int:
    ans = 0
    n = len(rating)

    biggerLeft, biggerRight = {}, {}

    for i in range(n-1):
        for j in range(i+1, n):
            if rating[i] < rating[j]:
                biggerRight[i] = biggerRight.get(i, 0) + 1
            elif rating[i] > rating[j]:
                biggerLeft[j] = biggerLeft.get(j, 0) + 1

    for i in range(n-1):
        for j in range(i+1, n):
            if rating[i] < rating[j]:
                ans += biggerRight.get(j, 0)
            elif rating[i] > rating[j]:
                ans += biggerLeft.get(i, 0)
    return ans
print(num_teams([2,5,3,4,1]))
print(num_teams([2,1,3]))
print(num_teams([1,2,3,4]))
print(num_teams([0,1]))
#+end_src

#+RESULTS: 1395 Count number of teams efficient solution
#+begin_src none
3
0
4
0
#+end_src


***** Time complexity:
$O(N^2)$.
***** Space complexity: 

$O(N)$.
*** More analysis
**** General thoughts
:LOGBOOK:
CLOCK: [2020-04-17 Fri 20:17]--[2020-04-17 Fri 21:21] =>  1:04
:END:
Brute-forcing this problem should be prohibited as this is medium level problem.
We should try to use some better algorithms to solve it.

[[#1395 Count number of teams Leetcode]] is a neat solution to the problem and a specia case of a general solution, which is provided here.

#+name: 1395 Count number of teams general solution
#+caption: 1395 Count number of teams general solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>

def calc_combinations(n: int, k: int) -> int:
    """
    n: total number of items
    k: number of items to be drawn
    """
    calculated = {}
    def factorial(n: int) -> int:
        if n == 0 or n == 1:
            return 1
        if n not in calculated.keys():
            calculated[n] = n * factorial(n-1)
        return calculated[n]

    if n < k :
        return 0
    return int(factorial(n)/factorial(k)/factorial(n-k))

def num_teams(rating: List[int], team_len: int = 3) -> int:
    ans = 0
    n = len(rating)

    biggerLeft, biggerRight = {}, {}

    for i in range(n-1):
        for j in range(i+1, n):
            if rating[i] < rating[j]:
                biggerRight[i] = biggerRight.get(i, 0) + 1
            elif rating[i] > rating[j]:
                biggerLeft[j] = biggerLeft.get(j, 0) + 1

    for i in range(n-1):
        for j in range(i+1, n):
            if rating[i] < rating[j]:
                # team_len-2 gives the remaining numbers that need to be drawn
                # from biggerRight.get(j, 0) given rating[i] and rating[j]
                ans += calc_combinations(biggerRight.get(j, 0), team_len-2)
            elif rating[i] > rating[j]:
                ans += calc_combinations(biggerLeft.get(i, 0), team_len-2)
    return ans
print(num_teams([2,7,8,9,10], 4))
print(num_teams([2,1,3]))
print(num_teams([1,2,3,4]))
print(num_teams([0,1]))
#+end_src

#+RESULTS: 1395 Count number of teams general solution
#+begin_src none
5
0
4
0
#+end_src

**** Related problems

** DONE 442 Find all duplicates in an array                   :array:medium:
*** Description
:LOGBOOK:
CLOCK: [2020-04-20 Mon 17:30]--[2020-04-20 Mon 17:34] =>  0:04
:END:
Given an array of integers, $1\le a[i] \le n, n=\text{size of array}$, some elements appear *twice* and others appear *once*.

Find all the elements that appear *twice* in this array.

Constraints:
Do it without extra space and in $O(n)$ runtime.

**** Examples:
#+name: 442 Find all duplicates in an array example
#+caption: 442 Find all duplicates in an array example
#+begin_example
Input:
[4,3,2,7,8,2,3,1]

Output:
[2,3]
#+end_example

*** Solution

**** Problem category

**** Algorithm
:LOGBOOK:
CLOCK: [2020-04-20 Mon 19:40]--[2020-04-20 Mon 19:46] =>  0:06
CLOCK: [2020-04-20 Mon 19:18]--[2020-04-20 Mon 19:29] =>  0:11
CLOCK: [2020-04-20 Mon 17:35]--[2020-04-20 Mon 17:36] =>  0:01
:END:

See [[https://leetcode.com/problems/find-all-duplicates-in-an-array/discuss/92390/Python-O(n)-time-O(1)-space][Discussion]].

$\because$:
Given the condition $\max(arr)\le \text{len}(arr)$, we know that each number element in the array should be able to be mapped to an index of the array.

We also know that, a number in the array either occurs just once or twice.

$\therefore$:
when iterating the array, we can mark the number at index ~i~ negative when we first encounter it. If we never see it again, then we can safely ignore it (once). The second time we see it and it's negative, we add it to the final result (twice). 

**** Code
:LOGBOOK:
CLOCK: [2020-04-20 Mon 19:46]--[2020-04-20 Mon 19:50] =>  0:04
:END:
#+name: 442 Find all duplicates in an array my solution
#+caption: 442 Find all duplicates in an array my solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>

def find_duplicates(nums: List[int]) -> List[int]:
    res = []
    for n in nums:
        if nums[abs(n)-1] < 0:
            res.append(abs(n))
        else:
            nums[abs(n)-1] *= -1
    return res

print(find_duplicates([1,2,3,3]))
#+end_src

#+RESULTS: 442 Find all duplicates in an array my solution
#+begin_src none
[3]
#+end_src

**** Complexity
***** Time complexity:
$O(N)$.
***** Space complexity: 
$O(1)$, excluding the returning result ~res~.

**** Leetcode solution
Not available.

Most interesting idea has been provided in the previous section.
#+name: 442 Find all duplicates in an array leetcode solution
#+caption: 442 Find all duplicates in an array leetcode solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>

#+end_src

***** Time complexity:

***** Space complexity: 

*** More analysis
**** General thoughts
**** Related problems

** DONE 78 Subsets                                            :array:medium:
*** Description
:LOGBOOK:
CLOCK: [2020-04-20 Mon 20:03]--[2020-04-20 Mon 20:05] =>  0:02
:END:

Given a set of *distinct* integers, ~nums~, return all possible subsets (the power set).

Constraints:
The solution set must not contain duplicate subsets.
**** Examples:
#+name: 78 Subsets example
#+caption: 78 Subsets example
#+begin_example
Input: nums = [1,2,3]
Output:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
#+end_example

*** Solution

**** Problem category

**** Algorithm
:LOGBOOK:
CLOCK: [2020-04-20 Mon 20:05]--[2020-04-20 Mon 20:06] =>  0:01
:END:

We can use Python's ~itertools.combinations~.
**** Code
:LOGBOOK:
CLOCK: [2020-04-20 Mon 20:06]--[2020-04-20 Mon 20:14] =>  0:08
:END:
#+name: 78 Subsets my solution
#+caption: 78 Subsets my solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>

def subsets(nums: List[int]) -> List[List[int]]:
    from itertools import combinations, chain

    res = [combinations(nums, i) for i in range(1, len(nums) + 1)]
    return list(map(list, chain(*res))) + [[]]
print(subsets([1,2,3]))
#+end_src

#+RESULTS: 78 Subsets my solution
#+begin_src none
[[1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3], []]
#+end_src

**** Complexity
***** Time complexity:
$O(\frac{N!}{(N-K)!K!})$
***** Space complexity: 
$O(\frac{N!}{(N-K)!K!})$

**** Leetcode solution
:PROPERTIES:
:CUSTOM_ID: 78 Subsets Leetcode Solution
:END:
:LOGBOOK:
CLOCK: [2020-04-20 Mon 20:38]--[2020-04-20 Mon 20:40] =>  0:02
:END:
Bitmask solution.
The idea is that we map each subset to a bitmask of length n, where 1 on the /ith/ position in the bitmask meas the presence of ~nums[i]~ in the subset, and 0 means its absence.
#+name: 78 Subsets leetcode solution
#+caption: 78 Subsets leetcode solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>

def subsets(nums: List[int]) -> List[List[int]]:
    n = len(nums)
    output = []

    # nth_bit = "1000"
    nth_bit = 1<<n
    for i in range(2**n):
        # generate bit mask, from 0..00 to 1..11
        bitmask = bin(i | nth_bit)[3:]
        # append subset corresponding to that bit mask
        output.append([nums[j] for j in range(n) if bitmask[j] == '1'])

    return output
print(subsets([1,2,3]))
#+end_src

#+RESULTS: 78 Subsets leetcode solution
#+begin_src none
0b1000
000
0b1001
001
0b1010
010
0b1011
011
0b1100
100
0b1101
101
0b1110
110
0b1111
111
[[], [3], [2], [2, 3], [1], [1, 3], [1, 2], [1, 2, 3]]
#+end_src

***** Time complexity:
$O(\frac{N!}{(N-K)!K!})$
***** Space complexity: 
$O(\frac{N!}{(N-K)!K!})$

*** More analysis
**** General thoughts
See [[*Bitmask]]
**** Related problems

** DONE 48 Rotate image                                       :array:medium:
*** Description
:LOGBOOK:
CLOCK: [2020-04-21 Tue 14:13]--[2020-04-21 Tue 14:14] =>  0:01
:END:
You are given an ~n*n~ 2D matrix representing an image.

Rotate the image 90 degrees (clockwise).

Constraints:

You have to rotate the image in-place.
**** Examples:
#+name: 48 Rotate image example
#+caption: 48 Rotate image example
#+begin_example
Given input matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

rotate the input matrix in-place such that it becomes:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]

Given input matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
], 

rotate the input matrix in-place such that it becomes:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]
#+end_example

*** Solution

**** Problem category

**** Algorithm
:LOGBOOK:
CLOCK: [2020-04-21 Tue 14:17]--[2020-04-21 Tue 14:28] =>  0:11
:END:
Given the coordinate of a point ~(row, col)~ in the matrix ~mat~ (~n*n~), to rotate a matrix clockwise by 90 degrees is to do the following:
~map(lambda (row, col): (col, n-1-row), mat)~.
**** Code
:PROPERTIES:
:CUSTOM_ID: 48 Rotate image my solution
:END:
:LOGBOOK:
CLOCK: [2020-04-21 Tue 14:57]--[2020-04-21 Tue 15:01] =>  0:04
CLOCK: [2020-04-21 Tue 14:32]--[2020-04-21 Tue 14:56] =>  0:24
:END:
#+name: 48 Rotate image my solution
#+caption: 48 Rotate image my solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>

def rotate(matrix: List[List[int]]) -> None:
    import math
    n = len(matrix)
    def rotate_square(mat: List[List[int]], coor: Tuple[int]) -> None:
        row, col = coor
        target_val = mat[col][n-1-row]
        mat[col][n-1-row] = mat[row][col]

        row, col = col, n-1-row
        temp = mat[col][n-1-row]
        mat[col][n-1-row] = target_val

        row, col = col, n-1-row
        target_val = mat[col][n-1-row]
        mat[col][n-1-row] = temp

        row, col = col, n-1-row
        mat[col][n-1-row] = target_val

    for cur_row in range(math.ceil(n/2)):
        for cur_col in range(cur_row, n-cur_row-1):
            rotate_square(matrix, (cur_row, cur_col))

    print(matrix)

rotate([[1,2],[3,4]])
rotate([[1,2,3],[4,5,6],[7,8,9]])
rotate([[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]])
#+end_src

#+RESULTS: 48 Rotate image my solution
#+begin_src none
[[3, 1], [4, 2]]
[[7, 4, 1], [8, 5, 2], [9, 6, 3]]
[[15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11]]
#+end_src

**** Complexity
***** Time complexity:
$O(N^2)$.
***** Space complexity: 
$O(1)$
**** Leetcode solution
Not available.
#+name: 48 Rotate image leetcode solution
#+caption: 48 Rotate image leetcode solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>

#+end_src

***** Time complexity:

***** Space complexity: 

*** More analysis
**** General thoughts
:LOGBOOK:
CLOCK: [2020-04-21 Tue 15:42]--[2020-04-21 Tue 15:49] =>  0:07
:END:
My solution is very cumbersome, especially the ~rotate_square()~ function.
As shown in the Leetcode discussion forum, it is easier to flip the matrix instead of actually rotating it because flip the matrix only involves *swapping* two values. Whereas my ~rotate_square()~ involves introducing two temporary variables to finish a rotation.

The other way to mitigate the problem in my solution is to use the following code, which does the rotation of four elements at once.
#+caption: 48 rotate image sample
#+name: 48 rotate image sample
#+begin_src ein-python :session localhost :results output code 
matrix[i][j], matrix[j][n - 1 - i], matrix[n - 1 - i][n - 1 - j], matrix[n - 1 - j][i] 
= matrix[n - 1 - j][i], matrix[i][j], matrix[j][n - 1 - i], matrix[n - 1 - i][n - 1 - j]
#+end_src

#+caption: 48 rotate image sample-results

#+RESULTS: 48 rotate image sample
**** Related problems

** DONE 72 Edit distance                                           :dp:hard:
*** Description
:LOGBOOK:
CLOCK: [2020-04-21 Tue 20:46]--[2020-04-21 Tue 20:47] =>  0:01
:END:
Given two words, ~word1~ and ~word2~, find the minimum number of operations required to convert ~word1~ to ~word2~.

You have the following 3 operations permitted on a word:
1. Insert a character
2. Delete a character
3. Replace a character
   
Constraints:

**** Examples:
#+name: 72 Edit distance example
#+caption: 72 Edit distance example
#+begin_example
Input: word1 = "intention", word2 = "execution"
Output: 5
Explanation: 
intention -> inention (remove 't')
inention -> enention (replace 'i' with 'e')
enention -> exention (replace 'n' with 'x')
exention -> exection (replace 'n' with 'c')
exection -> execution (insert 'u')
#+end_example

*** Solution

**** Problem category

**** Algorithm
This is a typical dynamic programming problem.
**** Code
:LOGBOOK:
CLOCK: [2020-04-21 Tue 20:49]--[2020-04-21 Tue 21:05] =>  0:16
:END:
#+name: 72 Edit distance my solution
#+caption: 72 Edit distance my solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>

def min_distance(word1: str, word2: str) -> int:
    m = len(word1)
    n = len(word2)

    if m == 0:
        return n
    if n == 0:
        return m

    tbl = [[0 for j in range(n+1)] for i in range(m+1)]

    for i in range(m+1):
        for j in range(n+1):
            if i == 0:
                tbl[i][j] = j
            elif j==0:
                tbl[i][j] = i
            elif word1[i-1] == word2[j-1]:
                tbl[i][j] = tbl[i-1][j-1]
            else:
                tbl[i][j] = 1 + min(
                    tbl[i-1][j],
                    tbl[i][j-1],
                    tbl[i-1][j-1]
                )

    return tbl[m][n]
#+end_src

**** Complexity
***** Time complexity:
$O(MN)$
***** Space complexity: 
$O(MN)$

**** Leetcode solution
Not available.
#+name: 72 Edit distance leetcode solution
#+caption: 72 Edit distance leetcode solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>

#+end_src

***** Time complexity:

***** Space complexity: 

*** More analysis
**** General thoughts
See [[*Edit distance]].
**** Related problems

** DONE 121 Best time to buy and sell stock                  :array:hard:dp:
*** Description
:LOGBOOK:
CLOCK: [2020-04-21 Tue 21:05]--[2020-04-21 Tue 21:07] =>  0:02
:END:
Say you have an array for which the ~ith~ element is the price of a given stock on day ~i~.

If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.

Constraints:
You cannot sell a stock before you buy one.
**** Examples:
#+name: 121 Best time to buy and sell stock example
#+caption: 121 Best time to buy and sell stock example
#+begin_example
Input: [7,1,5,3,6,4]
Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
             Not 7-1 = 6, as selling price needs to be larger than buying price.
             
Input: [7,6,4,3,1]
Output: 0
Explanation: In this case, no transaction is done, i.e. max profit = 0.
#+end_example

*** Solution

**** Problem category

**** Algorithm
:LOGBOOK:
CLOCK: [2020-04-21 Tue 21:24]--[2020-04-21 Tue 21:28] =>  0:04
CLOCK: [2020-04-21 Tue 21:07]--[2020-04-21 Tue 21:13] =>  0:06
:END:
+We build up a table of all possible combinations from the ~prices~ list.+
+Half of the table is not necessary.+
We first sort the list ~prices~ and convert it to a ordered map that ~{price: day}~.
Then we start from the lowest price ~p_low~, and check it against the highest price ~p_hi~, if ~price[p_hi]>price[p_low]~, we already find one candidate of the result and move ~p_low~ to the right, else, we move ~p_hi~ to the left.
**** Code
:LOGBOOK:
CLOCK: [2020-04-21 Tue 21:31]--[2020-04-21 Tue 21:46] =>  0:15
CLOCK: [2020-04-21 Tue 21:13]--[2020-04-21 Tue 21:16] =>  0:03
:END:
#+name: 121 Best time to buy and sell stock my solution
#+caption: 121 Best time to buy and sell stock my solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>

def max_profit(prices: List[int]) -> int:

    max_p = 0

    price_map = {}
    for i, p in enumerate(prices):
        if p not in price_map.keys():
            price_map[p] = i

    prices.sort()

    for p_buy in prices:
        d_buy = price_map[p_buy]
        for p_sell in reversed(prices):
            d_sell = price_map[p_sell]
            if p_buy<p_sell and d_buy < d_sell:
                max_p = max(max_p, p_sell-p_buy)
                break

    return max_p
print(max_profit([7,1,5,3,6,4]))
print(max_profit([7,6,5]))
print(max_profit([1,4,1,4,3,1]))
#+end_src

#+RESULTS: 121 Best time to buy and sell stock my solution
#+begin_src none
5
0
3
#+end_src

**** Complexity
***** Time complexity:

***** Space complexity: 

**** Leetcode solution
:LOGBOOK:
CLOCK: [2020-04-22 Wed 08:17]--[2020-04-22 Wed 08:23] =>  0:06
:END:
If we plot the numbers in the array on a graph, we will have a line graph.

The points of interest are the peaks and valleys in the given graph. We need to find the highest peak, following the lowest valley. We can maintain two variables - ~minprice~ and ~maxprofit~ corresponding to the lowest valley and maximum profit (max difference between selling price and ~minprice~) obtained so far respectively.
#+name: 121 Best time to buy and sell stock leetcode solution
#+caption: 121 Best time to buy and sell stock leetcode solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>

def max_profit(prices: List[int]) -> int:
    from math import inf
    minprice = inf
    maxprofit = 0

    for i in range(len(prices)):
        if prices[i] < minprice:
            minprice = prices[i]
        elif prices[i] - minprice > maxprofit:
            maxprofit = prices[i] - minprice

    return maxprofit
print(max_profit([1,2,3,4,5]))
#+end_src

#+RESULTS: 121 Best time to buy and sell stock leetcode solution
#+begin_src none
4
#+end_src

***** Time complexity:
$O(N)$

***** Space complexity: 
$O(1)$

*** More analysis
**** General thoughts
:LOGBOOK:
CLOCK: [2020-04-22 Wed 09:09]--[2020-04-22 Wed 09:26] =>  0:17
CLOCK: [2020-04-22 Wed 08:23]--[2020-04-22 Wed 08:46] =>  0:23
:END:
Initially I was trying to use dynamic programming to solve this problem, as is indicated by the problem's DP tag, then it was very hard to start because the problem does not seem to have an obvious subproblems that will be solved multiple times.

The solutions provided by Leetcode did not use DP either, but then other people suggested that it /can/ be categorised as a very [[https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solution/][simple DP problem]] and tabulation can be used to solve it.

#+begin_quote
The prerequisites for using DP are:
1. optimal substructure
2. overlaping sub-problems

In this problem, sub-problems ~f[i]~ is defined as "the minimum stock price from day 0 to day ~i~", which is dependant on ~f[i-1]~ and ~prices[i]~, whichever is lower.
The overlapping sub-problem here is very obvious - there's no need to calculate ~f[i]~ by comparing stock prices from day 0 to day ~i-1~, which is the brute force solution, but just reuse the pre-calculated result ~f[i-1]~.

~maxprofit~ variable may or may not be in the DP table, as it can be viewed as a simple global max, and we can simply get it by ~maxprofit=max(maxprofit, prices[i-1]-dp[i-1][0])~.
#+end_quote

Also people mentioned that this is similar to [[https://en.wikipedia.org/wiki/Maximum_subarray_problem][Kadane's Algorithm for Maximum Subarray Sum]].
#+caption: 121 Best time to buy and sell stock dp solution
#+name: 121 Best time to buy and sell stock dp solution
#+begin_src ein-python :session localhost :results output code 
def max_profit(prices) -> int:
    from math import inf
    
    n = len(prices)
    dp = [[0, 0] for i in range(n+1)]

    # starting price
    dp[0][0] = inf

    for i in range(1, n+1):
        dp[i][0] = min(dp[i-1][0], prices[i-1])
        dp[i][1] = max(dp[i-1][1], prices[i-1]-dp[i-1][0])

    return dp[n][1]
print(max_profit([1,2,3,4,5]))
#+end_src

#+RESULTS: 121 Best time to buy and sell stock dp solution
#+begin_src none
4
#+end_src

#+caption: 121 Best time to buy and sell stock dp solution-results
**** Related problems
[[*53 Maximum subarray]]
** DONE 53 Maximum subarray                                         :dp:easy:
*** Description
:LOGBOOK:
CLOCK: [2020-04-22 Wed 09:27]--[2020-04-22 Wed 09:28] =>  0:01
:END:
Given an integer array ~nums~, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.

Constraints:
Use $O(N)$ time.
**** Examples:
#+name: 53 Maximum subarray example
#+caption: 53 Maximum subarray example
#+begin_example
Input: [-2,1,-3,4,-1,2,1,-5,4],
Output: 6
Explanation: [4,-1,2,1] has the largest sum = 6.
#+end_example

*** Solution

**** Problem category

**** Algorithm
:LOGBOOK:
CLOCK: [2020-04-22 Wed 09:28]--[2020-04-22 Wed 09:38] =>  0:10
:END:
Use dynamic programming.
The sub-problem is "the maximum sum of previous arrays".
**** Code
:LOGBOOK:
CLOCK: [2020-04-22 Wed 09:53]--[2020-04-22 Wed 09:54] =>  0:01
CLOCK: [2020-04-22 Wed 09:43]--[2020-04-22 Wed 09:49] =>  0:06
:END:
#+name: 53 Maximum subarray my solution
#+caption: 53 Maximum subarray my solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>

def max_subarray(nums: List[int]) -> int:
    from math import inf
    n = len(nums)
    if n == 1:
        return nums[0]

    # this is actualy not needed
    # see General thoughts
    dp = [0 for i in range(n+1)]
    dp[0] = -inf

    for i in range(1, n+1):
        dp[i] =max(nums[i-1], nums[i-1] + dp[i-1])

    return max(dp)
print(max_subarray([-2,1,-3,4,-1,2,1,-5,4]))
print(max_subarray([-2,1]))
#+end_src

#+RESULTS: 53 Maximum subarray my solution
#+begin_src none
6
1
#+end_src

**** Complexity
***** Time complexity:
$O(N)$.
***** Space complexity: 
$O(N)$ but $O(1)$ can be achieved by removing the ~dp~ array.

**** Leetcode solution
Not available.
#+name: 53 Maximum subarray leetcode solution
#+caption: 53 Maximum subarray leetcode solution
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>

#+end_src

***** Time complexity:

***** Space complexity: 

*** More analysis
**** General thoughts
:LOGBOOK:
CLOCK: [2020-04-22 Wed 10:19]--[2020-04-22 Wed 10:22] =>  0:03
CLOCK: [2020-04-22 Wed 10:06]--[2020-04-22 Wed 10:09] =>  0:03
:END:
[[https://en.wikipedia.org/wiki/Maximum_subarray_problem][Wikipedia]] introduces the history of this problem as "a simplified model for /maximum likelihood/ estimate of patterns in digitized images".

In this problem, $O(1)$ space can be achieved.
#+name: 53 Maximum subarray my solution O(1) space
#+caption: 53 Maximum subarray my solution O(1) space
#+begin_src ein-python :session localhost :results output code :noweb yes
<<imports for typing>>

def max_subarray(nums: List[int]) -> int:
    from math import inf
    n = len(nums)
    if n == 1:
        return nums[0]

    cur_sum = -inf
    best_sum = cur_sum

    for i in range(1, n+1):
        cur_sum =max(nums[i-1], nums[i-1] + cur_sum)
        best_sum = max(best_sum, cur_sum)

    return best_sum
print(max_subarray([-2,1,-3,4,-1,2,1,-5,4]))
#print(max_subarray([-2,1]))
#+end_src

#+RESULTS: 53 Maximum subarray my solution O(1) space
#+begin_src none
6
#+end_src

**** Related problems
[[*121 Best time to buy and sell stock]]
The ~minprice~ in [[*121 Best time to buy and sell stock]] is the ~cur_sum~ in this question, and ~maxprofit~ in [[*121 Best time to buy and sell stock]] is the ~best_sum~ in this question.
* Data structures
This section contains widely used data structures and related problems.
* Algorithms
This section contains widely used algorithms and related problems.
** Sorting
*** Insertion sort
In-place sort.
Easy to implement.
#+caption: Insertion sort
#+name: Insertion sort
#+begin_src ein-python :session localhost :results output code 
def insertion_sort(arr):
    i = 0
    while i < len(arr):
        j = i
        while j > 0 and arr[j-1] > arr[j]:
            temp = arr[j-1]
            arr[j-1] = arr[j]
            arr[j] = temp
            j -= 1

        i+=1

    return arr
print(insertion_sort([2,1,3,4,2,5]))
#+end_src

#+RESULTS: Insertion sort
#+begin_src none
[1, 2, 2, 3, 4, 5]
#+end_src

#+caption: Insertion sort-results
** Dynamic programming

The prerequisites for using DP are:
1. optimal substructure
2. overlaping sub-problems
*** Edit distance
:LOGBOOK:
CLOCK: [2020-04-21 Tue 20:27]--[2020-04-21 Tue 20:45] =>  0:18
CLOCK: [2020-04-21 Tue 17:35]--[2020-04-21 Tue 17:57] =>  0:22
:END:

#+caption: dynamic programming - edit distance
#+name: dynamic programming - edit distance
#+begin_src ein-python :session localhost :results output code 
def edit(s: str, t: str) -> int:
    from math import inf
    def get_element(tbl: List[List[int]], i: int, j: int) -> int:

        if i>=0 and j>=0:
            return tbl[i][j]
        else:
            return inf
        
    m = len(s)
    n = len(t)

    tbl = [[0 for j in range(n+1)] for i in range(m+1)]


    for i in range(0, m+1):
        for j in range(0, n+1):
            if i==0 and j==0:
                continue
            tbl[i][j] = min(1+get_element(tbl,i, j-1), 1+get_element(tbl,i-1, j), get_element(tbl, i-1, j-1)+(0 if s[i-1]==t[j-1] else 1))
    return tbl[m][n]
print(edit("cbc", "ac"))
#+end_src

#+RESULTS: dynamic programming - edit distance
#+begin_src none
2
#+end_src

#+caption: dynamic programming - edit distance-results

#+caption: dynamic programming - edit distance improved
#+name: dynamic programming - edit distance improved
#+begin_src ein-python :session localhost :results output code 
def edit(s: str, t: str) -> int:
    m = len(s)
    n = len(t)

    # +1 accounts for the empty string in the table
    tbl = [[0 for j in range(n+1)] for i in range(m+1)]

    for i in range(m+1):
        for j in range(n+1):
            if i == 0:
                tbl[i][j] = j
            elif j==0:
                tbl[i][j] = i

            # we want to compare the chars s[i-1] and t[j-1]
            # not the chars s[i] and t[j]
            # because at this point, i is in [1..m], j is in [1..n]
            # we need to map them back to [0..m-1] and [0..n-1]
            elif s[i-1]==t[j-1]:
                tbl[i][j] = tbl[i-1][j-1]
            else:
                tbl[i][j] = 1+min(tbl[i][j-1], # insert
                                  tbl[i-1][j], # remove
                                  tbl[i-1][j-1] # replace
                )
    return tbl[m][n]

print(edit("abc", "ac"))
#+end_src

#+RESULTS: dynamic programming - edit distance improved
#+begin_src none
1
#+end_src

#+caption: dynamic programming - edit distance improved-results
* Techniques
This section contains techniques that do not make a full algorithm and related problems.
** General
*** Bitmask
:LOGBOOK:
CLOCK: [2020-04-21 Tue 11:34]--[2020-04-21 Tue 11:38] =>  0:04
CLOCK: [2020-04-21 Tue 10:45]--[2020-04-21 Tue 10:59] =>  0:14
:END:
See [[#78 Subsets Leetcode Solution]].

We have set of objects that we want to draw from. How do we represent the set's subsets such that we get its power set?

We can easily think of a map to associate with each object a boolean value, indicating whether the object is picked. The problem with this is that it can take a lot of memory and can be slow due to the overhead of creating the map.

So we can use bitmask.

#+name: bitmask example
| arr  | 1 | 2 | 3 |
| mask | 1 | 0 | 1 |
#+caption: bitmask
#+name: bitmask
#+begin_src ein-python :session localhost :results output code 
def get_power_set(arr: List[int]) -> List[List[int]]:
    n = len(arr)

    # helps create left padding zeros
    # if n == 4, we have 1000
    nth_bit = 1<<n

    res = [[]]
    # time complexity: 2**n
    for i in range(2**n):
        # if n==4, we might have 1000 | 010
        # 1000 | 110, etc
        # [3:] takes out the leading "0b1" in "0b1010"
        mask = bin(nth_bit | i)[3:]
        sub = []
        # time complexity: n
        for j in range(n):
            if mask[j] == "1":
                sub.append(arr[j])

        res.append(sub)
    return res
print(get_power_set([1,2,3]))
#+end_src

#+RESULTS: bitmask
#+begin_src none
[[], [], [3], [2], [2, 3], [1], [1, 3], [1, 2], [1, 2, 3]]
#+end_src

#+caption: bitmask-results

** Python
