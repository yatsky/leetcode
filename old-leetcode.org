#+FILETAG: :learning:note:
#+LATEX_HEADER: \usepackage{amsmath}
#+SETUPFILE: ../theme-readtheorg.setup
#+EXPORT_FILE_NAME: ../../yatsky.github.io/leetcode.html
#+HTML_LINK_HOME: ../website/index.html

* Programming practice
** LeetCode                                                       :leetcode:
#+BEGIN: clocktable :scope subtree :maxlevel 2
#+CAPTION: Clock summary at [2020-04-16 Thu 07:38]
| Headline     | Time       |          |
|--------------+------------+----------|
| *Total time* | *2d 13:16* |          |
|--------------+------------+----------|
| \_  LeetCode |            | 2d 13:16 |
#+END:


DEADLINE: <2019-12-31 Tue>
[[https://leetcode.com/progress/][My progress]]
*** Plan
:PROPERTIES:
:Effort:   1:00
:END:
:LOGBOOK:
CLOCK: [2019-09-09 Mon 09:18]--[2019-09-09 Mon 09:45] =>  0:27
:END:
**** Good resources                                             :resource:
1. [[https://leetcode.com/discuss/career/216554/from-0-to-clearing-uberappleamazonlinkedingoogle][From 0 to clearing]] 
2. [[https://www.reddit.com/r/cscareerquestions/comments/6luszf/a_leetcode_grinding_guide/][A leetcode grinding guide]]
*** TODO Execution
SCHEDULED: <2019-10-29 Tue 15:00 +1d>
:PROPERTIES:
:LAST_REPEAT: [2020-04-16 Thu 14:27]
:END:
- State "DONE"       from "TODO"       [2020-04-16 Thu 14:27]
- State "DONE"       from "TODO"       [2020-04-16 Thu 08:09]
- State "DONE"       from "TODO"       [2020-04-14 Tue 22:16]
- State "DONE"       from "TODO"       [2020-04-14 Tue 12:26]
- State "DONE"       from "TODO"       [2020-04-13 Mon 21:22]
- State "DONE"       from "TODO"       [2020-04-13 Mon 14:51]
- State "DONE"       from "TODO"       [2020-04-09 Thu 14:56]
- State "DONE"       from "TODO"       [2020-04-09 Thu 14:04]
- State "DONE"       from "TODO"       [2020-04-09 Thu 10:21]
- State "DONE"       from "TODO"       [2020-02-01 Sat 11:32]
- State "DONE"       from "TODO"       [2020-01-27 Mon 11:33]
- State "DONE"       from "TODO"       [2019-10-18 Fri 11:18]
- State "DONE"       from "TODO"       [2019-10-17 Thu 16:53]
- State "DONE"       from "TODO"       [2019-10-17 Thu 15:00]
- State "DONE"       from "TODO"       [2019-10-16 Wed 21:57]
- State "DONE"       from "TODO"       [2019-10-16 Wed 14:46]
- State "DONE"       from "TODO"       [2019-10-14 Mon 21:19]
- State "DONE"       from "TODO"       [2019-10-14 Mon 16:19]
- State "DONE"       from "TODO"       [2019-10-14 Mon 14:04]
- State "DONE"       from "TODO"       [2019-10-10 Thu 21:17]
- State "DONE"       from "TODO"       [2019-10-09 Wed 21:57]
- State "DONE"       from "TODO"       [2019-10-08 Tue 20:59]
- State "DONE"       from "TODO"       [2019-10-07 Mon 21:05]
- State "DONE"       from "TODO"       [2019-10-05 Sat 11:21]
- State "DONE"       from "TODO"       [2019-10-04 Fri 21:46]
- State "DONE"       from "TODO"       [2019-10-03 Thu 19:42]
- State "DONE"       from "TODO"       [2019-10-03 Thu 09:27]
- State "DONE"       from "TODO"       [2019-10-02 Wed 21:18]
- State "DONE"       from "TODO"       [2019-10-02 Wed 20:02]
- State "DONE"       from "TODO"       [2019-10-02 Wed 19:28]
- State "DONE"       from "TODO"       [2019-09-30 Mon 19:59]
- State "DONE"       from "TODO"       [2019-09-28 Sat 14:31]
- State "DONE"       from "TODO"       [2019-09-28 Sat 13:43]
- State "DONE"       from "TODO"       [2019-09-27 Fri 20:15]
- State "DONE"       from "TODO"       [2019-09-27 Fri 15:26]
- State "DONE"       from "TODO"       [2019-09-26 Thu 18:02]
- State "DONE"       from "TODO"       [2019-09-26 Thu 15:47]
- State "DONE"       from "TODO"       [2019-09-26 Thu 14:21]
- State "DONE"       from "TODO"       [2019-09-24 Tue 20:39]
- State "DONE"       from "TODO"       [2019-09-23 Mon 20:08]
- State "DONE"       from "TODO"       [2019-09-20 Fri 09:13]
- State "DONE"       from "TODO"       [2019-09-20 Fri 09:13]
- State "DONE"       from "TODO"       [2019-09-16 Mon 21:58]
- State "DONE"       from "TODO"       [2019-09-16 Mon 21:58]
- State "DONE"       from "TODO"       [2019-09-15 Sun 19:52]
- State "DONE"       from "TODO"       [2019-09-13 Fri 20:54]
- State "DONE"       from "TODO"       [2019-09-12 Thu 21:37]
- State "DONE"       from "TODO"       [2019-09-11 Wed 20:34]
- State "DONE"       from "TODO"       [2019-09-10 Tue 19:09]
- State "DONE"       from "TODO"       [2019-09-09 Mon 19:08]
:LOGBOOK:
CLOCK: [2019-09-14 Sat 11:48]--[2019-09-14 Sat 12:02] =>  0:14
CLOCK: [2019-09-14 Sat 08:49]--[2019-09-14 Sat 10:27] =>  1:38
CLOCK: [2019-09-14 Sat 08:44]--[2019-09-14 Sat 08:49] =>  0:05
CLOCK: [2019-09-13 Fri 19:47]--[2019-09-13 Fri 20:54] =>  1:07
CLOCK: [2019-09-13 Fri 19:00]--[2019-09-13 Fri 19:47] =>  0:47
CLOCK: [2019-09-12 Thu 16:26]--[2019-09-12 Thu 17:41] =>  1:15
CLOCK: [2019-09-11 Wed 20:13]--[2019-09-11 Wed 20:23] =>  0:10
CLOCK: [2019-09-10 Tue 16:16]--[2019-09-10 Tue 16:39] =>  0:23
CLOCK: [2019-09-10 Tue 15:34]--[2019-09-10 Tue 16:16] =>  0:42
CLOCK: [2019-09-09 Mon 19:34]--[2019-09-09 Mon 20:03] =>  0:29
CLOCK: [2019-09-09 Mon 09:54]--[2019-09-09 Mon 09:54] =>  0:00
:END:
Two questions a day should be enough. Don't spend over 30 minutes on one question.
Should be ordered by Difficulty, Acceptance rate(high to low), with Solution.
| question type             |  easy | medium |  hard |
|---------------------------+-------+--------+-------|
| total number of questions | ~ 200 |  ~ 350 | ~ 150 |
|---------------------------+-------+--------+-------|
| <2019-09-09 Mon>          |     2 |      0 |     0 |
| <2019-09-10 Tue>          |     2 |      0 |     0 |
| <2019-09-11 Wed>          |     2 |      0 |     0 |
| <2019-09-12 Thu>          |     2 |      0 |     0 |
| <2019-09-13 Fri>          |     2 |      0 |     0 |
| <2019-09-14 Sat>          |     6 |      0 |     0 |
| <2019-09-15 Sun>          |     2 |      0 |     0 |
| <2019-09-16 Mon>          |     2 |      0 |     0 |
| <2019-09-17 Tue>          |     2 |      0 |     0 |
|                           |       |        |       |

*** Question list
:LOGBOOK:
CLOCK: [2020-04-09 Thu 08:51]--[2020-04-09 Thu 09:01] =>  0:10
:END:
| Done |    # | Title                                             | Acceptance | Difficulty |
|------+------+---------------------------------------------------+------------+------------|
|    1 |  762 | Prime Number of Set Bits in Binary Representation |     62.10% | Easy       |
|    1 |  771 | Jewels and Stones                                 |     84.80% | Easy       |
|    1 |  938 | Range Sum of BST                                  |     79.70% | Easy       |
|    1 |  804 | Unique Morse Code Words                           |     76.20% | Easy       |
|    1 |  832 | Flipping an Image                                 |     75.00% | Easy       |
|    1 |  905 | Sort Array By Parity                              |     73.80% | Easy       |
|    1 |  728 | Self Dividing Numbers                             |     73.30% | Easy       |
|    1 |  961 | N-Repeated Element in Size 2N Array               |     73.20% | Easy       |
|    1 |  617 | Merge Two Binary Trees                            |     73.10% | Easy       |
|    1 |  657 | Robot Return to Origin                            |     73.00% | Easy       |
|    1 |  977 | Squares of a Sorted Array                         |     72.30% | Easy       |
|    1 |  942 | DI String Match                                   |     71.40% | Easy       |
|    1 |  461 | Hamming Distance                                  |     71.30% | Easy       |
|    1 |  561 | Array Partition I                                 |     71.20% | Easy       |
|    1 |  852 | Peak Index in a Mountain Array                    |     71.00% | Easy       |
|    1 |  933 | Number of Recent Calls                            |     70.80% | Easy       |
|    1 |  590 | N-ary Tree Postorder Traversal                    |     70.80% | Easy       |
|    1 |  589 | N-ary Tree Preorder Traversal                     |     70.80% | Easy       |
|    1 |  700 | Search in a Binary Search Tree                    |     70.70% | Easy       |
|    1 |  944 | Delete Columns to Make Sorted                     |     70.00% | Easy       |
|    1 |  811 | Subdomain Visit Count                             |     68.40% | Easy       |
|    1 |  876 | Middle of the Linked List                         |     68.40% | Easy       |
|    1 |  922 | Sort Array By Parity II                           |     68.20% | Easy       |
|    1 |  557 | Reverse Words in a String III                     |     68.20% | Easy       |
|    1 |  897 | Increasing Order Search Tree                      |     68.00% | Easy       |
|    1 |  559 | Maximum Depth of N-ary Tree                       |     67.70% | Easy       |
|    1 |  929 | Unique Email Addresses                            |     67.60% | Easy       |
|    1 |  965 | Univalued Binary Tree                             |     67.30% | Easy       |
|    1 |  883 | Projection Area of 3D Shapes                      |     67.10% | Easy       |
|    1 |  509 | Fibonacci Number                                  |     67.00% | Easy       |
|    1 | 1047 | Remove All Adjacent Duplicates In String          |     66.90% | Easy       |
|    1 |  821 | Shortest Distance to a Character                  |     66.00% | Easy       |
|    1 |  908 | Smallest Range I                                  |     65.30% | Easy       |
|    1 |  893 | Groups of Special-Equivalent Strings              |     65.30% | Easy       |
|    1 |  872 | Leaf-Similar Trees                                |     64.80% | Easy       |
|    1 |  136 | Single Number                                     |     64.70% | Easy       |
|    1 |  104 | Maximum Depth of Binary Tree                      |     64.50% | Easy       |
|    1 |  806 | Number of Lines To Write String                   |     64.20% | Easy       |
|    1 |  766 | Toeplitz Matrix                                   |     63.90% | Easy       |
|    1 |  867 | Transpose Matrix                                  |     63.20% | Easy       |
|    1 |  682 | Baseball Game                                     |     62.80% | Easy       |
|    1 |  496 | Next Greater Element I                            |     62.60% | Easy       |
|    1 |  784 | Letter Case Permutation                           |     62.30% | Easy       |
|    1 |  226 | Invert Binary Tree                                |     62.20% | Easy       |
|    1 |  884 | Uncommon Words from Two Sentences                 |     62.20% | Easy       |
|    1 |  669 | Trim a Binary Search Tree                         |     62.10% | Easy       |
|    1 |  985 | Sum of Even Numbers After Queries                 |     61.90% | Easy       |
|    1 |  824 | Goat Latin                                        |     61.90% | Easy       |
|    1 |  637 | Average of Levels in Binary Tree                  |     61.70% | Easy       |
|    1 |  412 | Fizz Buzz                                         |     61.50% | Easy       |
|    1 |  575 | Distribute Candies                                |     61.00% | Easy       |
|    1 |  206 | Reverse Linked List                               |     60.40% | Easy       |
|    1 | 1103 | Distribute Candies to People                      |     60.30% | Easy       |
|    1 |  868 | Binary Gap                                        |     60.20% | Easy       |
|    1 |  349 | Intersection of Two Arrays                        |     60.20% | Easy       |
|    1 |  566 | Reshape the Matrix                                |     60.00% | Easy       |
|    1 |  237 | Delete Node in a Linked List                      |     59.00% | Easy       |
|    1 |  693 | Binary Number with Alternating Bits               |     59.00% | Easy       |
|    1 | 1089 | Duplicate Zeros                                   |     58.80% | Easy       |
|    1 |  892 | Surface Area of 3D Shapes                         |     58.20% | Easy       |
|    1 |  812 | Largest Triangle Area                             |     57.60% | Easy       |
|    1 |  917 | Reverse Only Letters                              |     57.40% | Easy       |
|    1 |  888 | Fair Candy Swap                                   |     57.40% | Easy       |
|    1 |  976 | Largest Perimeter Triangle                        |     57.30% | Easy       |
|    1 |  283 | Move Zeroes                                       |     57.20% | Easy       |
|    1 |  521 | Longest Uncommon Subsequence I                    |     57.20% | Easy       |
|    1 |  896 | Monotonic Array                                   |     56.90% | Easy       |
|    1 | 1137 | N-th Tribonacci Number                            |     56.70% | Easy       |
|    1 |  788 | Rotated Digits                                    |     56.70% | Easy       |
|    1 |  169 | Majority Element                                  |     56.30% | Easy       |
|    1 |  485 | Max Consecutive Ones                              |     56.20% | Easy       |
|    1 |  690 | Employee Importance                               |     56.10% | Easy       |
|    1 |  748 | Shortest Completing Word                          |     56.10% | Easy       |
|    1 |  292 | Nim Game                                          |     56.10% | Easy       |
|    1 |  108 | Convert Sorted Array to Binary Search Tree        |     55.80% | Easy       |
|    1 | 1029 | Two City Scheduling                               |     55.80% | Easy       |
|    1 |  242 | Valid Anagram                                     |     55.60% | Easy       |
|    1 |  122 | Best Time to Buy and Sell Stock II                |     55.60% | Easy       |
|    1 |  448 | Find All Numbers Disappeared in an Array          |     55.40% | Easy       |
|    1 |  696 | Count Binary Substrings                           |     55.20% | Easy       |
|    1 |  217 | Contains Duplicate                                |     55.20% | Easy       |
|    1 |  953 | Verifying an Alien Dictionary                     |     54.90% | Easy       |
|    1 |  653 | Two Sum IV - Input is a BST                       |     54.50% | Easy       |
|    1 |  538 | Convert BST to Greater Tree                       |     54.00% | Easy       |
|    1 |  937 | Reorder Data in Log Files                         |     53.60% | Easy       |
|    1 |  733 | Flood Fill                                        |     53.30% | Easy       |
|    1 |  606 | Construct String from Binary Tree                 |     53.30% | Easy       |
|    1 |  697 | Degree of an Array                                |     53.20% | Easy       |
|    1 |  167 | Two Sum II - Input array is sorted                |     52.90% | Easy       |
|    1 |    1 | Two Sum                                           |     45.20% | Easy       |
|    1 |    7 | Reverse Integer                                   |     25.60% | Easy       |
|    1 | 1342 | Number of Steps to Reduce a Number to Zero        |     86.20% | Easy       |
|    1 |  709 | To Lower Case                                     |     78.70% | Easy       |
|    0 |  339 | Nested List Weight Sum                            |     72.20% | Easy       |
|    0 |  346 | Moving Average from Data Stream                   |     69.40% | Easy       |
|    0 |  359 | Logger Rate Limiter                               |     69.10% | Easy       |
|    0 | 1394 | Find Lucky Integer in an Array                    |     68.90% | Easy       |
|    0 | 1337 | The K Weakest Rows in a Matrix                    |     68.60% | Easy       |
|    0 |  344 | Reverse String                                    |     66.10% | Easy       |
|    0 |  476 | Number Complement                                 |     63.40% | Easy       |
|    0 |  751 | IP to CIDR                                        |     62.00% | Easy       |
|    0 |  266 | Palindrome Permutation                            |     61.30% | Easy       |
|    0 |  800 | Similar RGB Color                                 |     61.30% | Easy       |
|    0 | 1260 | Shift 2D Grid                                     |     61.10% | Easy       |
|    0 |  243 | Shortest Word Distance                            |     60.20% | Easy       |
|    0 |  706 | Design HashMap                                    |     59.60% | Easy       |
|    0 | 1009 | Complement of Base 10 Integer                     |     59.40% | Easy       |
|    0 |  705 | Design HashSet                                    |     59.00% | Easy       |
|    0 | 1332 | Remove Palindromic Subsequences                   |     57.40% | Easy       |
|    0 |   13 | Roman to Integer                                  |     54.80% | Easy       |
|    0 |  389 | Find the Difference                               |     54.50% | Easy       |
|    0 |  252 | Meeting Rooms                                     |     53.90% | Easy       |
|    0 |  993 | Cousins in Binary Tree                            |     52.30% | Easy       |
|    0 |  100 | Same Tree                                         |     52.00% | Easy       |
|    0 |   21 | Merge Two Sorted Lists                            |     51.90% | Easy       |
|    0 |  783 | Minimum Distance Between BST Nodes                |     51.80% | Easy       |
|    0 |  387 | First Unique Character in a String                |     51.70% | Easy       |
|    0 |  383 | Ransom Note                                       |     51.70% | Easy       |
|    0 |  256 | Paint House                                       |     51.40% | Easy       |
|    0 |  860 | Lemonade Change                                   |     51.10% | Easy       |
|    0 |  704 | Binary Search                                     |     50.80% | Easy       |
|    0 |  661 | Image Smoother                                    |     50.70% | Easy       |
|    0 |  118 | Pascal's Triangle                                 |     50.70% | Easy       |
|    0 |  268 | Missing Number                                    |     50.60% | Easy       |
|    0 |  350 | Intersection of Two Arrays II                     |     50.60% | Easy       |
|    0 |  202 | Happy Number                                      |     50.10% | Easy       |
|    0 |  599 | Minimum Index Sum of Two Lists                    |     50.10% | Easy       |
|    0 |  997 | Find the Town Judge                               |     50.00% | Easy       |
|    0 |  453 | Minimum Moves to Equal Array Elements             |     49.80% | Easy       |
|    0 |  409 | Longest Palindrome                                |     49.80% | Easy       |
|    0 |  121 | Best Time to Buy and Sell Stock                   |     49.70% | Easy       |
|    0 |  257 | Binary Tree Paths                                 |     49.60% | Easy       |
|    0 |  796 | Rotate String                                     |     49.50% | Easy       |
|    0 |  598 | Range Addition II                                 |     49.30% | Easy       |
|    0 |  746 | Min Cost Climbing Stairs                          |     49.30% | Easy       |
|    0 |  717 | 1-bit and 2-bit Characters                        |     49.00% | Easy       |
|    0 |  830 | Positions of Large Groups                         |     48.90% | Easy       |
|    0 |  836 | Rectangle Overlap                                 |     48.70% | Easy       |
|    0 |  235 | Lowest Common Ancestor of a Binary Search Tree    |     48.50% | Easy       |
|    0 |  543 | Diameter of Binary Tree                           |     48.40% | Easy       |
|    0 |  563 | Binary Tree Tilt                                  |     47.80% | Easy       |
|    0 |  232 | Implement Queue using Stacks                      |     47.70% | Easy       |
|    0 |  541 | Reverse String II                                 |     47.60% | Easy       |
|    0 |  191 | Number of 1 Bits                                  |     47.60% | Easy       |
|    0 |  119 | Pascal's Triangle II                              |     47.50% | Easy       |
|    0 |  720 | Longest Word in Dictionary                        |     47.40% | Easy       |
|    0 |  844 | Backspace String Compare                          |     47.30% | Easy       |
|    0 |   27 | Remove Element                                    |     47.20% | Easy       |
|    0 |    9 | Palindrome Number                                 |     47.10% | Easy       |
|    0 |  994 | Rotting Oranges                                   |     47.10% | Easy       |
|    0 |  628 | Maximum Product of Three Numbers                  |     46.90% | Easy       |
|    0 |  551 | Student Attendance Record I                       |     46.70% | Easy       |
|    0 |  270 | Closest Binary Search Tree Value                  |     46.50% | Easy       |
|    0 |   70 | Climbing Stairs                                   |     46.40% | Easy       |
|    0 |   53 | Maximum Subarray                                  |     45.90% | Easy       |
|    0 |  101 | Symmetric Tree                                    |     45.90% | Easy       |
|    0 |  594 | Longest Harmonious Subsequence                    |     45.70% | Easy       |
|    0 |  674 | Longest Continuous Increasing Subsequence         |     45.40% | Easy       |
|    0 |  925 | Long Pressed Name                                 |     45.10% | Easy       |
|    0 |  744 | Find Smallest Letter Greater Than Target          |     45.00% | Easy       |
|    0 |  758 | Bold Words in String                              |     44.60% | Easy       |
|    0 |   83 | Remove Duplicates from Sorted List                |     44.60% | Easy       |
|    0 |  989 | Add to Array-Form of Integer                      |     44.10% | Easy       |
|    0 |  819 | Most Common Word                                  |     43.90% | Easy       |
|    0 |  572 | Subtree of Another Tree                           |     43.80% | Easy       |
|    0 |   26 | Remove Duplicates from Sorted Array               |     43.80% | Easy       |
|    0 |   38 | Count and Say                                     |     43.50% | Easy       |
|    0 |  225 | Implement Stack using Queues                      |     43.30% | Easy       |
|    0 |  724 | Find Pivot Index                                  |     43.10% | Easy       |
|    0 |  671 | Second Minimum Node In a Binary Tree              |     42.90% | Easy       |
|    0 |  231 | Power of Two                                      |     42.90% | Easy       |
|    0 |   67 | Add Binary                                        |     42.80% | Easy       |
|    0 |  110 | Balanced Binary Tree                              |     42.70% | Easy       |
|    0 |  303 | Range Sum Query - Immutable                       |     42.50% | Easy       |
|    0 |  849 | Maximize Distance to Closest Person               |     42.30% | Easy       |
|    0 |  716 | Max Stack                                         |     42.10% | Easy       |
|    0 |   66 | Plus One                                          |     42.00% | Easy       |
|    0 |  326 | Power of Three                                    |     42.00% | Easy       |
|    0 |  374 | Guess Number Higher or Lower                      |     41.80% | Easy       |
|    0 |  734 | Sentence Similarity                               |     41.80% | Easy       |
|    0 |  198 | House Robber                                      |     41.70% | Easy       |
|    0 |  645 | Set Mismatch                                      |     41.60% | Easy       |
|    0 |   35 | Search Insert Position                            |     41.50% | Easy       |
|    0 |  155 | Min Stack                                         |     41.50% | Easy       |
|    0 |  747 | Largest Number At Least Twice of Others           |     41.30% | Easy       |
|    0 |  342 | Power of Four                                     |     41.20% | Easy       |
|    0 |  643 | Maximum Average Subarray I                        |     41.00% | Easy       |
|    0 |  367 | Valid Perfect Square                              |     41.00% | Easy       |
|    0 |  112 | Path Sum                                          |     40.20% | Easy       |
|    0 |  443 | String Compression                                |     40.10% | Easy       |
|    0 |  141 | Linked List Cycle                                 |     40.00% | Easy       |
|    0 |  970 | Powerful Integers                                 |     39.70% | Easy       |
|    0 |  441 | Arranging Coins                                   |     39.50% | Easy       |
|    0 |  624 | Maximum Distance in Arrays                        |     38.60% | Easy       |
|    0 |  160 | Intersection of Two Linked Lists                  |     38.50% | Easy       |
|    0 |   88 | Merge Sorted Array                                |     38.40% | Easy       |
|    0 |  234 | Palindrome Linked List                            |     38.30% | Easy       |
|    0 |   20 | Valid Parentheses                                 |     38.30% | Easy       |
|    0 |  172 | Factorial Trailing Zeroes                         |     37.70% | Easy       |
|    0 |  434 | Number of Segments in a String                    |     37.50% | Easy       |
|    0 |  203 | Remove Linked List Elements                       |     37.30% | Easy       |
|    0 |  219 | Contains Duplicate II                             |     37.00% | Easy       |
|    0 |  111 | Minimum Depth of Binary Tree                      |     36.80% | Easy       |
|    0 |  840 | Magic Squares In Grid                             |     36.70% | Easy       |
|    0 |  604 | Design Compressed String Iterator                 |     36.60% | Easy       |
|    0 |  949 | Largest Time for Given Digits                     |     36.10% | Easy       |
|    0 |  680 | Valid Palindrome II                               |     35.90% | Easy       |
|    0 |  190 | Reverse Bits                                      |     35.60% | Easy       |
|    0 |  941 | Valid Mountain Array                              |     35.50% | Easy       |
|    0 |  687 | Longest Univalue Path                             |     35.40% | Easy       |
|    0 |  507 | Perfect Number                                    |     35.30% | Easy       |
|    0 |   14 | Longest Common Prefix                             |     34.80% | Easy       |
|    0 |  125 | Valid Palindrome                                  |     34.60% | Easy       |
|    0 |  874 | Walking Robot Simulation                          |     34.40% | Easy       |
|    0 |  914 | X of a Kind in a Deck of Cards                    |     34.00% | Easy       |
|    0 |   28 | Implement strStr()                                |     33.90% | Easy       |
|    0 |  278 | First Bad Version                                 |     33.50% | Easy       |
|    0 |  189 | Rotate Array                                      |     33.40% | Easy       |
|    0 |   69 | Sqrt(x)                                           |     33.10% | Easy       |
|    0 |  170 | Two Sum III - Data structure design               |     32.90% | Easy       |
|    0 |  633 | Sum of Square Numbers                             |     32.40% | Easy       |
|    0 |  686 | Repeated String Match                             |     32.10% | Easy       |
|    0 |  605 | Can Place Flowers                                 |     31.60% | Easy       |
|    0 |  581 | Shortest Unsorted Continuous Subarray             |     30.80% | Easy       |
|    0 |  414 | Third Maximum Number                              |     30.10% | Easy       |
|    0 |  859 | Buddy Strings                                     |     27.60% | Easy       |
|    0 |  665 | Non-decreasing Array                              |     19.40% | Easy       |
|------+------+---------------------------------------------------+------------+------------|
|   93 |  227 | 0.39912281                                        |          0 | 0          |

#+TBLFM: @229$1=vsum(@I..II)::@229$2=vlen(@I..@II)::@229$3=@230$1 / @229$2
*** Review
:PROPERTIES:
:LAST_REPEAT: [2019-09-20 Fri 09:13]
:END:
- State "DONE"       from "TODO"       [2019-09-20 Fri 09:13]
- State "DONE"       from "TODO"       [2019-09-20 Fri 09:13]
- State "DONE"       from "TODO"       [2019-09-16 Mon 21:58]
- State "DONE"       from "TODO"       [2019-09-16 Mon 21:58]
- State "DONE"       from "TODO"       [2019-09-16 Mon 21:58]
- State "DONE"       from "TODO"       [2019-09-16 Mon 21:58]
- State "DONE"       from "TODO"       [2019-09-13 Fri 22:15]
- State "DONE"       from "TODO"       [2019-09-11 Wed 20:34]
- State "DONE"       from "TODO"       [2019-09-10 Tue 19:09]
- State "DONE"       from "TODO"       [2019-09-09 Mon 20:08]
:LOGBOOK:
CLOCK: [2019-09-09 Mon 20:03]--[2019-09-09 Mon 20:05] =>  0:02
CLOCK: [2019-09-09 Mon 09:54]--[2019-09-09 Mon 09:54] =>  0:00
:END:
Review individual questions.
+------------------------+------------------------------------------+---------------------------------------------------------------------------+
| date                   | question number                          | review                                                                    |
+------------------------+------------------------------------------+---------------------------------------------------------------------------+
| <2019-09-09 Mon 19:43> | 771. Jewels and stones                   | Use brute force - python3 or use ~sum([S.count(j) for j in J])~           |
+------------------------+------------------------------------------+---------------------------------------------------------------------------+
| <2019-09-09 Mon 20:02> | 938. Range sum of BST                    | Use recursive algorithm (I knew) - also need to know that you *can define |
|                        |                                          | a function inside another*	       	                                      |
+------------------------+------------------------------------------+---------------------------------------------------------------------------+
| <2019-09-10 Tue 16:00> | 804. Unique Morse Code Word              | Hash code of two lists containing same elements can be different, hence   |
|                        |                                          |the ~''.join~                                                              |
+------------------------+------------------------------------------+---------------------------------------------------------------------------+
| <2019-09-10 Tue 16:38> | 832. Flipping an Image                   | Use ~map(func, iterable)~ function would be a great idea                  |
+------------------------+------------------------------------------+---------------------------------------------------------------------------+
| <2019-09-11 Wed 20:31> | 905. Sort array by parity                | list.insert() always moves current element at the position to the right,  |
|                        |                                          |even when the index is -1                                                  |
+------------------------+------------------------------------------+---------------------------------------------------------------------------+
| <2019-09-11 Wed 20:33> | 961. N-repeated elemnts in size 2N array | The target element is the one that appears twice                          |
+------------------------+------------------------------------------+---------------------------------------------------------------------------+
| <2019-09-11 Wed 21:39> | 977. squares of a sorted array           | Can use binary insertion or two pointer algorithm                         |
+------------------------+------------------------------------------+---------------------------------------------------------------------------+
|                        |                                          |                                                                           |
+------------------------+------------------------------------------+---------------------------------------------------------------------------+

| date                   | quesiton number | review                       |
| <2019-09-16 Mon 21:39> |             509 | There are 6 ways to do this! |
| <2019-09-16 Mon>       |                 |                              |
|                        |                 |                              |
*** Solutions [108/108]
#+BEGIN: clocktable :scope subtree :maxlevel 1 
#+CAPTION: Clock summary at [2020-04-16 Thu 08:10]
| Headline     | Time      |
|--------------+-----------|
| *Total time* | *2d 1:36* |
|--------------+-----------|
#+END:
227 Questions in total
**** DONE 771 Jewels and stones
- ~J~ represents jewels
- characters in ~J~ are distinctive
- ~S~ represents stones
- letters are case-sensitive
- calculate the number of stones that are jewels
**** DONE 938 Range Sum of BST
- given the *root* node of a binary search tree
- return the sum of values of all nodes with value between ~L~ and ~R~ (inclusive)
- the BST is guaranteed to have unique values
- The number of nodes in the tree is at most 10000
- the final answer is guaranteed to be less than 2^31
**** DONE 804 Unique Morse Code words
- letter is mapped to a series of dots and dashes
- 
  #+name: unique_morse_code_words
  #+begin_src python
def uniqueMorseRepresentations(words):
 map_list=[".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."]
 store = []
 for w in words:
  # 0-based index
     new_morse = "".join([map_list[ord(c) - 97] for c in w])
     if new_morse not in store:
      store.append(new_morse)
 return len(store)
return uniqueMorseRepresentations(['gin', 'zen', 'gig', 'msg'])

  #+end_src

  #+RESULTS: unique_morse_code_words
  : 2
**** DONE 832 Flipping an Image
- given a matrix ~A~
- flip it horizontally, i.e. [1, 1, 0] to [0, 1, 1]
- invert it, i.e. change 1 to 0 and 0 to 1
#+name: flipping_an_image
#+begin_src python
def flip_and_invert_image(A):
    new_image = []
    for i in A:
        rev_i = i[::-1]
        inv_i = [1-p for p in rev_i]
        new_image.append(inv_i)
    return new_image
return flip_and_invert_image([[1,1,0],[1,0,1],[0,0,0]])
#+end_src
#+name: flipping_image_example_code
#+begin_src python
def flip_and_invert_image(A):
    result = []
    for row in A:
        result.append(list(map(lambda x: 0 if x==1 else 1, row[::-1])))
    return result
return flip_and_invert_image([[1,1,0],[1,0,1],[0,0,0]])
#+end_src

#+RESULTS: flipping_image_example_code
| 1 | 0 | 0 |
| 0 | 1 | 0 |
| 1 | 1 | 1 |

#+RESULTS: flipping_an_image
| 1 | 0 | 0 |
| 0 | 1 | 0 |
| 1 | 1 | 1 |
**** DONE 905 Sort array by parity
- given an array ~A~ of non-negative integers
- return an array consisting of all the even elements of ~A~, followed by all the odd elements of A
#+name: sort_array_by_parity
#+begin_src python
def sort_array_by_parity(A):
    sorted_list = []
    for e in A:
        if e % 2 == 0:
            sorted_list.insert(0, e)
        else:
            # insert() wouldn't work because it shifts 0 at index -1 to the right.
            # sorted_list.insert(-1, e)
            sorted_list.append(e)
    return sorted_list
return sort_array_by_parity([0,1])
#+end_src

#+RESULTS: sort_array_by_parity
| 0 | 1 |
**** DONE 961 N-Repeated elements in size 2N array
- ~N+1~ unique elements in an array ~A~ of size ~2N~
- exactly one of these elements is repeated ~N~ times
- return the element that repeated ~N~ times
#+name: n_repeated_elements_in_size_2N_array
#+begin_src python
def repeated_n_times(A):
    store = []
    for e in A:
        if e in store:
            return e
        else:
            store.append(e)
#+end_src
**** DONE 657 Robot return to origin
- robot starts at position (0, 0), the origin
- given the sequence of its moves, judge if this robot ends up at (0, 0) after it completes its moves
- the move sequence is represented by a string
- valid moves are R(ight), L(eft), U(p), D(own)
- if the robot returns to origin after the moves, return true, else, return false
- where the robot faces is irrelevant

#+begin_src python
def robot_returned(moves):
    MOVE_MAP = {'U':1, 'D': -1, 'R':1, 'L':-1}
    x_coord = 0
    y_coord = 0
    for m in moves:
        if m in 'UD':
            y_coord += MOVE_MAP[m]
        else:
            x_coord += MOVE_MAP[m]

    if x_coord == 0 and y_coord == 0:
        return True
    return False
#+end_src
**** DONE 977 Squares of a sorted array
- given an array of integers ~A~ in non-decreasing order
- return an array of the squares of each number, also in sorted non-decreasing order

My instinct tells me to use a type of Insertion Sort. But it actually can use Binary Search???
#+name: quick solution
#+begin_src python
def sorted_squares(A):
    return sorted(x*x for x in A)
#+end_src
#+name: my_solution
#+begin_src python
def sorted_squares(A):
    sorted_tobe_inserted = []
    # sanity check
    if A[0] >= 0:
        return [x**2 for x in A]
    if A[-1] <= 0:
        return [x**2 for x in A[::-1]]
    # mixed negatives and positives
    result_list = A.copy()

    def find_positive_and_insert(A, sorted_tobe_inserted):
        for idx, x in enumerate(A):
            if x < 0:
                sorted_tobe_inserted.insert(0, -1 * x)
            else:
                return idx
    def binary_insert(elem, target, left, right):
        # base case, if L == R
        # right == left + 1 is also an edge case
        if left == right or (right == left + 1):
            if elem <= target[left]:
                target.insert(left, elem)
            else:
                target.insert(left+1, elem)
            return
        else:
            m = (left+right)//2
            if elem <= target[m]:
                binary_insert(elem, target, left, m)
            else:
                binary_insert(elem, target, m, right)
                
    idx = find_positive_and_insert(A, sorted_tobe_inserted)
    target = A[idx::]
    for elem in sorted_tobe_inserted:
        binary_insert(elem, target, 0, len(target))
    return [x**2 for x in target]
return sorted_squares([-4, -1, 3, 10])
#+end_src

#+name: my_solution_improved
#+begin_src python
def sorted_squares(A):
    sorted_tobe_inserted = []
    # sanity check
    if A[0] >= 0:
        return [x**2 for x in A]
    if A[-1] <= 0:
        return [x**2 for x in A[::-1]]
    # mixed negatives and positives
    result_list = A.copy()

    def find_positive_and_insert(A, sorted_tobe_inserted):
        for idx, x in enumerate(A):
            if x < 0:
                sorted_tobe_inserted.insert(0, -1 * x)
            else:
                return idx
    def binary_insert(elem, target, left, right):
        # base case, if L == R
        if left == right or (right == left + 1):
            if elem <= target[left]:
                target.insert(left, elem)
            else:
                target.insert(left+1, elem)
            return
        else:
            m = (left+right)//2
            if elem <= target[m]:
                binary_insert(elem, target, left, m)
            else:
                binary_insert(elem, target, m + 1, right)
                
    idx = find_positive_and_insert(A, sorted_tobe_inserted)
    target = A[idx::]
    for elem in sorted_tobe_inserted:
        binary_insert(elem, target, 0, len(target))
    return [x**2 for x in target]
return sorted_squares([-4, -1, 3, 10])
#+end_src

#+name: two_pointers
#+begin_src python
def sorted_squares(A):
    N = len(A)
    # i, j: negative, positive parts
    j = 0
    # find all negatives
    while j < N and A[j] < 0:
        j += 1
        i = j - 1

    ans = []
    # loop until negatives or positives run out
    while 0 <= i and j < N:
        if A[i]**2 < A[j]**2:
            ans.append(A[i]**2)
            i -= 1
        else:
            ans.append(A[j]**2)
            j += 1

    # deal with anything that's still out there
    while i >= 0:
        ans.append(A[i]**2)
        i -= 1
    while j < N:
        ans.append(A[j]**2)
        j += 1

    return ans
return sorted_squares([-3, -2, 2, 3, 4])
#+end_src

#+RESULTS: two_pointers
| 4 | 4 | 9 | 9 | 16 |

#+RESULTS: my_solution_improved
| 1 | 9 | 16 | 100 |

#+RESULTS:
| 1 | 9 | 16 | 100 |
**** DONE 728 Self dividing numbers
- a self-dividing number(sdn) is a number that is divisible by every digit it contains
- 128 % 1 == 0, 128 % 2 == 0, 128 % 8 == 0
- sdn does not have the digit zero
- given a lower and upper number bound, output a list of every possible self dividing number, including the bounds if possible
#+name: my_sdn
#+begin_src python
def self_dividing_number(left, right):

    def is_dividing_number(num):
        # converting the num to str so we can check if it contains zero
        test = str(num)
        if '0' in test:
            return False
        else:
            for digit in test:
                if num % int(digit) != 0:
                    return False
        return True

        
    ans = []
    # the solution must have a loop through the list [left, right + 1]
    for num in range(left, right + 1):
        if is_dividing_number(num):
            ans.append(num)
    return ans
#+end_src
**** DONE 617 Merging two binary trees
- given two binary trees and put one of them to cover the other
- some nodes of the two trees are overlapped while the others are not
- merge them into a new binary tree
  - if two nodes overlap, then sum node values up as the new value of the merged node
  - otherwise, the NOT null node will be used as the node of the new tree

#+name: merge_two_binary_trees
#+begin_src python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def merge_binary_trees(t1, t2):

    def reaches_leaf(node: TreeNode):
        return node.left == None and node.right == None

    # dfs merge
    def merge_binary_trees_recursive(ans_node, node1, node2):
        # base case
        ans_node.val = node1.val + node2.val
        ans_node.left = TreeNode(0)
        ans_node.right = TreeNode(0)
        if reaches_leaf(node1) and reaches_leaf(node2):
            ans_node.left = None
            ans_node.right = None
            return
        elif node1.left == None and node2.left == None:
            ans_node.left = None
        elif node1.right == None and node2.right == None:
            ans_node.right = None

        if ans_node.left != None:
            node1.left = TreeNode(0) if node1.left == None else node1.left
            node2.left = TreeNode(0) if node2.left == None else node2.left
            merge_binary_trees_recursive(ans_node.left, node1.left, node2.left)
        if ans_node.right != None:
            node1.right = TreeNode(0) if node1.right == None else node1.right
            node2.right = TreeNode(0) if node2.right == None else node2.right
            merge_binary_trees_recursive(ans_node.right, node1.right, node2.right)
        else:
            return 
        # this defensive programming is not beautiful but required to pass the test
    if t1 == None:
        return t2
    if t2 == None:
        return t1    
    ans_node = TreeNode(0)
    merge_binary_trees_recursive(ans_node, t1, t2)
    return ans_node
t1 = TreeNode(1)
t1.left = TreeNode(3)
t1.right = TreeNode(2)
t1.left.left = TreeNode(5)
t2 = TreeNode(2)
t2.left = TreeNode(1)
t2.left.right = TreeNode(4)
t2.right = TreeNode(3)
t2.right.right = TreeNode(7)

return merge_binary_trees(t1, t2)
#+end_src

#+name: merge_two_binary_trees_solution
#+begin_src python
# this method does not care if t1 or t2 is None
def merge_trees(t1, t2):
    if t1 is None:
        return t2
    if t2 is None:
        return t1

    t1.val += t2.val
    t1.left = merge_trees(t1.left, t2.left)
    t1.right = merge_trees(t1.right, t2.right)
    return t1
#+end_src
#+RESULTS: merge_two_binary_trees
: <__main__.main.<locals>.TreeNode object at 0x000001C04C99C438>

**** DONE 852 Peak index in a mountain array
***** Gathering information
an array ~A~ is a *mountian* if
- ~A.length >= 3~
- there exists some ~0 < i < A.length - 1 such that ~A[0] < ... A[i-1] < A[i] > A[i+1] >...>A[A.length - 1]~
given an array that is definitely a mountain, return any ~i~.

***** Tackling process
Because ~A~ is *definitely a mountain*, then for some ~i~ that matches the definition, ~A[0:i+1] # python list~ is strictly in increasing order. Our goal is to find the ~i~ such that ~A[i+1] < A[i]~

#+name: peak_index_in_mountain_arr
#+begin_src python
def peak_index_in_mountain_arr(A: List[int]) -> int:
    for i, num in enumerate(A):
        if i == len(A) - 1:
            return i
        else:
            if A[i+1] < num:
                return i
            
#+end_src
**** DONE 561 Array partition I
***** Gathering information
- given an array of *2n* integers
- group these integers into *n* pairs of integers
- such that (a1, b1)...(an, bn) make the *sum of min(ai, bi)* for all i from 1 to n as large as possible
***** Tackling process
It can be proven that if the elements of the array is ordered, then grouping them two at a time sequentially will provide the largest sum of min(ai, bi).
If we want the smallest sum of min(ai, bi), we can pair the ordered list from both sides.

#+name: array_partitioin_1
#+begin_src python
def array_partition_1(A):
    sorted_a = sorted(A)
    sum = 0
    for i in range(0, len(A), 2):
        sum += min(sorted_a[i], sorted_a[i+1])
    return sum

#+end_src
#+name: one_line_solution
#+begin_src python
def array_partition_1(nums);
    return sum(sorted(nums)[::2])
#+end_src
**** DONE 942 DI string match
***** Gathering information
- given a string ~S~ that *only* contains "I" (increase) or "D" (descrease)
- let ~N = S.length~
- return *any* permutation ~A~ of ~[0, 1, ..., N]~ such that for all ~i = 0, ..., N-1~
  - ~A[i] < A[i+1] if S[i] == "I"~
  - ~A[i] > A[i+1] if S[i] == "D"~
***** Tackling process
We can find that ~A~ [0, 1, ...N] is in order, and if we let "D" = -1, "I" = 1, and assume that we start from 0, then we can have
a *function f(x) = sum(x0, x1, ..., xi) where xi = 1 if S[i] == "I" else xi = -1 and i in [0, N]*.
First we get the f(x) for every i, then we assign numbers from ~A~ to each f(x) in decsending order.
For example
|   |  D | I |  D | I |
| 0 | -1 | 0 | -1 | 0 |
| 4 |  1 | 3 |  0 | 2 |
|   |    |   |    |   |

#+name: di_string_match
#+begin_src python
def di_string_match(S:str):
    DI_MAP = {"D": -1, "I": 1}
    nums = list(range(len(S) + 1))

    di_sum = 0
    di_nums = [(di_sum, 0)]
    for i, c in enumerate(S):
        di_sum += DI_MAP[c]
        di_nums.append((di_sum, i + 1))

    di_nums_sorted = sorted(di_nums, key=lambda x: x[0])
    ans = [None] * len(nums)
    for i, pos in enumerate([idx[1] for idx in di_nums_sorted]):
        ans[pos] = nums[i]
    return ans
return di_string_match("DDI")
#+end_src

#+RESULTS: di_string_match
| 3 | 1 | 0 | 2 |
**** DONE 944 Delete columns to make sorted
***** Gathering information
- given an array ~A~ of ~N~ lowercase letter strings, all of the same length
- choose any set of deletion indices, and for each string, we delete all the characters in those indices
- suppose we choose a set of deletion indices ~D~ such that after deletion, each remaining column in ~A~ is in *non-decreasing* sorted order
- return the minimum possible value of ~D.length~
For example
#+name: original
| c | d | g |
| b | a | h |
| a | f | i |

We choose ~D=[1]~
#+name: after_deletion
| c | d | g |
| a | f | i |

***** Tackling process
#+name: delete_columns_to_make_sorted
#+begin_src python
def delete_cols_to_sort(A):
    def is_sorted(col):
        if col == sorted(col):
            return True
        return False
    d_len = 0
    if len(A) == 0:
        return d_len
    else:
        for i, c in enumerate(A[0]):
            if not is_sorted([letters[i] for letters in A]):
                d_len += 1
    return d_len
return delete_cols_to_sort(["cba", "daf", "ghi"])            
#+end_src

#+name: original_solution
#+begin_src python
def min_deletion_size(A):
    ans = 0
    for col in zip(*A):
        if any(col[i] > col[i+1] for i in xrange(len(col) -1)):
            ans += 1
    return ans
#+end_src
#+RESULTS: delete_columns_to_make_sorted
: 1

**** DONE 933 Number of recent calls
:LOGBOOK:
CLOCK: [2019-09-14 Sat 13:36]--[2019-09-14 Sat 14:12] =>  0:36
:END:
***** Gathering information
- write a class ~RecentCounter~ to count recent requests
- it has only one method, ~ping(int t)~, where t represents some time in milliseconds
- return the number of ~ping~s that have been made from 3000 milliseconds ago, [t -3000, t], until now
- it is guaranteed that every call to ~ping~ uses a strictly larger value of t than before
***** Tackling process

#+name: recen_counter
#+begin_src python
# This works but takes too much time that it hangs
class RecentCounter:
    def __init__(self):
        self.calls = []
        
    def ping(self, t):
        self.calls.append(t)
        count = 0
        new_list = []
        for i in range(len(self.calls) - 1, -1, -1):
            if t - self.calls[i] <= 3000:
                count += 1
                new_list.insert(0, self.calls[i])
            else:
                break
            self.calls = new_list
        return count

#+end_src

#+name: recen_counter_mysolution_improved
#+begin_src python
class RecentCounter:
    def __init__(self):
        self.calls = []
        
    def ping(self, t):
        self.calls.append(t)

        while self.calls[0] < t - 3000:
            self.calls.pop(0)
        return len(self.calls)

#+end_src
#+name: solution
#+begin_src python
# This is faster
import collections
class RecentCounter:
    def __init__(self):
        self.calls = collections.deque()

    def ping(self, t):
        self.calls.append(t)
        while self.calls[0] < t - 3000:
            self.calls.popleft()
        return len(self.calls)
#+end_src
#+RESULTS: recen_counter
: 1

**** DONE 700 Search in Binary Search Tree
:LOGBOOK:
CLOCK: [2019-09-14 Sat 14:18]--[2019-09-14 Sat 14:34] =>  0:16
:END:
***** Gathering information
- given the root node of a BST and a value
- find the node in the BST that the node's value equals the given value
- return the subtree rooted with the node
- if the such node does not exist, return NULL
***** Tackling process
DFS search

#+name: searchBST
#+begin_src python
def searchBST(root, val):
    # base case
    if  root is None or root.val == val:
        return root
    else:
        return searchBST(root.left, val) if val > root.val else searchBST(root.right, val)
    
#+end_src
**** DONE 929 Unique email addresses
***** Gathering information
:LOGBOOK:
CLOCK: [2019-09-15 Sun 19:16]--[2019-09-15 Sun 19:18] =>  0:02
CLOCK: [2019-09-15 Sun 19:16]--[2019-09-15 Sun 19:16] =>  0:00
:END:
- every email is made up by local_name@domain_name
- emails contain lower case letters and ~.~ or ~+~
- dots (~.~) in the *local name* is ignored, so *alice.z@leetcode.com* is the same as *alicez@leetcode.com"
- pluses (~+~) in the *local name* make everything after it to be ignored (including itself), so *m.y+name@email.com* is *my@email.com*.
- we can use both rules at the same time
- given a list ~emails~, we send one email to each address in the list. how many different addresses actually receive mails?
***** Tackling process
:LOGBOOK:
CLOCK: [2019-09-15 Sun 19:18]--[2019-09-15 Sun 19:25] =>  0:07
:END:
We can use *set* to solve the problem.
#+name: my_solution
#+begin_src python
def num_unique_emails(emails:List[str]):
    ans = set()

    for email in emails:
        local_name, domain_name = email.split("@")
        new_local_name = ''
        for c in local_name:
            if c == '+':
                break
            elif c != '.':
                new_local_name += c
                ans.add((new_local_name, domain_name))
    return len(ans)
#+end_src

**** DONE 590 N-ary tree postorder traversal
***** Gathering information
:LOGBOOK:
CLOCK: [2019-09-15 Sun 19:25]--[2019-09-15 Sun 19:26] =>  0:01
:END:
- given an n-ary tree return the *postorder* traversal of its nodes' values
- iterative solution and recursive solution

***** Tackling process
:LOGBOOK:
CLOCK: [2019-09-15 Sun 19:27]--[2019-09-15 Sun 19:52] =>  0:25
:END:

#+name: my_solution_recursive
#+begin_src python
def postorder(root):
    def rec(ans, root):
        for c in root.children:
            rec(ans, c)
            ans.append(root.val)
            ans = []
    if not root:
        return None
    rec(ans, root)
    return ans
#+end_src

#+name: my_solution_iterative
#+begin_src python
def postorder(root):
    ans = []
    ans_len = len(ans)
    finished = False
    while not finished:
        ans.append(root.val)
        for c in root.children[::-1]:


#+end_src

**** DONE 509 Fibonacci Number
:LOGBOOK:
CLOCK: [2019-09-16 Mon 21:34]--[2019-09-16 Mon 21:38] =>  0:04
:END:
***** Gathering information
given n, calculate ~F(n)~
***** Tackling process
#+name: my_solution
#+begin_src python
def fib(N):
    if N == 1:
        return 1
    elif N == 0:
        return 0
    else:
        return fib(N-1) + fib(N-2)
#+end_src

**** DONE 589 N-ary tree preorder traversal
:LOGBOOK:
CLOCK: [2019-09-18 Wed 20:39]--[2019-09-18 Wed 20:58] =>  0:19
CLOCK: [2019-09-16 Mon 21:41]--[2019-09-16 Mon 21:52] =>  0:11
:END:
***** Gathering information
given an n-ary tree, return it's *preorder traversal*.
***** Tackling process
Like 590, use a stack

#+name: my solution
#+begin_src python
def preorder(root):
    ans = []
    deq = collections.deque()
    
    if not root:
        return root

    deq.append(root)
    while len(stack) > 0:
        node = deq.popleft()
        ans.append(node.val)
        deq.extendleft(node.children[::-1])
    return ans

        
#+end_src
**** DONE 922 Sort array by parity ii
***** Gathering information
Given an array A of non-negative integers, half of the integers in A are odd, and half of the integers are even.
Sort the array so that whenever A[i] is odd, i is odd; and whenever A[i] is even, i is even.
***** Tackling process
#+name: my solution
#+begin_src python
def sort_array_by_parity(A):
    ans = [0] * len(A)
    odd_pos = 1
    even_pos = 0
    for i in A:
        if i % 2 == 0:
            ans[even_pos] = i
            even_pos += 2
        else:
            ans[odd_pos] = i
            odd_pos += 2
    return ans

#+end_src
**** DONE 965 Univalued Binary tree
***** Gathering information
:LOGBOOK:
CLOCK: [2019-09-18 Wed 21:09]--[2019-09-18 Wed 21:10] =>  0:01
:END:
- a binary tree is /univalued/ if
  - every node in the tree has the same value
- return ~true~ iff the given tree is univalued
***** Tackling process
:LOGBOOK:
CLOCK: [2019-09-18 Wed 21:10]--[2019-09-18 Wed 21:28] =>  0:18
:END:
We use a base and then traverse the tree, postorder or pre order, doesn't matter.

#+name: my_solution_iterative
#+begin_src python
def is_unival_tree(root):
    if not root:
        return root

    base = root.val
    stack = [root]

    while len(stack) > 0:
        node = stack.pop()
        if node:
            if base != node.val:
                return False
            stack.extend([node.left, node.right])

    return True
#+end_src

#+name: my_solution_recursive
#+begin_src python
def is_unival_tree(root):
    if not root:
        return root

    base = root.val

    def rec(node, base):
        if node:
            if node.val != base:
                return False
            return rec(node.left, base) and rec(node.right, base)
        return True
    return rec(root, base)

            
#+end_src
**** DONE 811 Subdomain visit count
:LOGBOOK:
CLOCK: [2019-09-18 Wed 21:33]--[2019-09-18 Wed 21:56] =>  0:23
:END:
***** Gathering information
- a "count-paired domain" is a count (representing the number of visits this domain received), followed by a space, followed by the address.
  - e.g. "9001 discuss.leetcode.com"
- given a list of ~cpdomains~ of count-paired domains, get a list of count-paired domains, that explicitly counts the number of visits to each subdomain.
  - e.g. ~input: ["9001 discuss.leetcode.com"], output: ["9001 discuss.leetcode.com", "9001 leetcode.com", "9001 com"]~
***** Tackling process

This is obviously a tree-related problem. We can constrct a tree from the right of the domain (com, org...) to the left of the domain. Or we can simply use a dictionary to reduce time complexity (tree would be O(Nlog(N)), dictionary should be O(N), because the length of each domain name will not exceed 100 (in description notes). 

#+name: my_solution
#+begin_src python
def subdomain_visits(cpdomains):
    ans = {}

    for cpdomain in cpdomains:
        count, domain = cpdomain.split()
        count = int(count)
        domain_parts = domain.split('.')

        for i in range(len(domain_parts)):
            ans[tuple(domain_parts[i:])] = ans.get(tuple(domain_parts[i:]), 0) + count

    return ["{count} {domain}".format(count=count, domain=".".join(domain)) for count, domain in ans.items()]

#+end_src
**** DONE 559 Maximum depth of N-ary tree
:LOGBOOK:
CLOCK: [2019-09-19 Thu 17:48]--[2019-09-19 Thu 18:10] =>  0:22
:END:
***** Basic info
- given an n-ary tree, find its maximum depth
***** Tackling process
#+name: my solution
#+begin_src python
# the depth of the tree is at most 1000
# total number of nodes is at most 5000
def max_depth(root) -> int:
    # root is None
    if not root:
        return 0
    def dfs(node, cur_depth, max_depth):
        if node:
            if len( node.children ) != 0:
                cur_depth += 1
                return max([dfs(child, cur_depth, max_depth) for child in node.children])
        if cur_depth > max_depth:
            max_depth = cur_depth
        return max_depth
    cur_depth = 1
    max_depth = 1
    return dfs(root, cur_depth, max_depth)
#+end_src
#+name: simpler version
#+begin_src python
def rec(nd, cnt):
    cnt += 1 # this can be put here because we started at 0 in max_depth()
    if not nd.children:
        return cnt
    return max([rec(c, cnt) for c in nd.children])

def max_depth(root):
    if not root:
        return 0
    return rec(root, 0)
#+end_src
***** Note
You can't do the following because that will result in the program terminating itself when finishing searching the left most branch because of the ~return~
#+name: snippet
#+begin_src python
def dfs(node, cur_depth, max_depth):
    if node:
        if len( node.children ) != 0:
            cur_depth += 1
            for child in node.children:
                return dfs(child, cur_depth, max_depth)

#+end_src
**** DONE 883 Projection area of 3D shpes
:LOGBOOK:
CLOCK: [2019-09-23 Mon 19:31]--[2019-09-23 Mon 20:01] =>  0:30
CLOCK: [2019-09-19 Thu 18:16]--[2019-09-19 Thu 18:44] =>  0:28
:END:
***** Basic info
- on a N*N grid, we place some 1*1*1 cubes that are axis aligned with the x, y, and z axes.
- each value $v = grid[i][j]$ represents a tower of $v$ cubes placed on top of grid cell $(i, j)$
- now we view the projection of these cubes onto the xy, yz, and zx planes
- return the total area of all three projections (from the top, the front, and the side)
***** Tackling process
Input example: [[1, 2], [3, 4]], meaning g[0][0] = 1, g[0][1] = 2, g[1][0] = 3, g[1][1] = 4.

#+name:my solution
#+begin_src python
from typing import List
def projection_area(grid: List[List[int]]) -> int:

    def top_area(grid: List[List[int]]) -> int:
        # as long as the number is greater than 0
        return len([num for sublist in grid for num in sublist if num > 0])
    def left_area(grid) -> int:
        # But if you want, say, a list of ten dicts, do not use [{}]*10 -- that would give you a list with the same initially-empty dict ten times, not ten distinct ones. Rather, use [{} for i in range(10)] or similar constructs, to construct ten separate dicts to make up your list.
        ans = [[] for _ in range(len(grid[0]))]
        for i in range(len(grid[0])):
            for sublist in grid:
                ans[i].append(sublist[i])
        return sum([max(row) for row in ans])
    def right_area(grid) -> int:
        return sum([max(row) for row in grid])

    return top_area(grid) + left_area(grid) + right_area(grid)
return projection_area([[1,2],[3,4]])
#+end_src

#+RESULTS: my solution
: s'teLekatedoCteeltsetnoc

#+name: provided solution
#+begin_src python
def projection_area(grid):
    n = len(grid)
    ans = 0

    for i in range(n):
        best_row = 0 # max of grid[i][j]
        best_col = 0 # max of grid[j][i]
        for j in range(n):
            if grid[i][j]:
                ans += 1 # top shadow
                best_row = max(best_row, grid[i][j])
                best_col = max(best_col, grid[j][i])

        ans += best_col + best_row

    return ans
#+end_src
**** DONE 897 Increasing order search tree
:LOGBOOK:
CLOCK: [2019-09-23 Mon 20:11]--[2019-09-23 Mon 21:18] =>  1:07
:END:
***** Basic info
Given a binary search tree, rearrange the tree in *in-order* so that the leftmode node in the tree is now the root of the tree, and every node has no left child and only 1 right child.
***** Tackling process
[[https://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference][Python "pass by reference" reference]]
The link describes how "pass by reference" works in python, which is highly related to the problem.

#+name: my solution
#+begin_src python
def increasingBST(root):
    new_root = TreeNode(0)
    new_node = new_root

    def dfs(node, new_node):
        if node.left:
            dfs(node.left, new_node)
        if node:
            # the code here has no idea what happened to new_node previously
            # so it's using the original value of new_node.
            new_node.right = TreeNode(node.val)
            new_node = new_node.right
        if node.right:
            dfs(node.right, new_node)
            dfs(root, new_node)
    return new_root.right
#+end_src
#+name: correct solution
#+begin_src python
def increasingBST(root):
    new_root = TreeNode(None)
    new_node = new_root
    def dfs(node, new_node):
        if node:
            if node.left:
                new_node = dfs(node.left, new_node)
                new_node.right = TreeNode(node.val)
                new_node = new_node.right
                #print(new_node.val)
            if node.right:     
                new_node = dfs(node.right, new_node)
        return new_node
    dfs(root, new_node)
    return new_root.right
#+end_src

**** DONE 557 Reverse words in a string 3
:LOGBOOK:
CLOCK: [2019-09-24 Tue 20:01]--[2019-09-24 Tue 20:20] =>  0:19
:END:
***** Basic info
Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.
In the string, each word is separated by single space and there will not be any extra space in the string
For example:
#+begin_src python
input = "Let's take LeetCode contest"
output = "s'teL ekat edoCteeL tsetnoc"
#+end_src
***** Tackling process
To achieve $O(N)$ time, where $N$ is the number of characters in the string.
Can use a double ended queue. (Actually this was a misunderstanding somehow I jumped to the conclusion. We don't need to use it).
#+name: my solution wrong
#+begin_src python
def reverse_words(s: str) -> str:
    from collections import deque

    ans = deque()

    for c in s:
        if c == " ":
            ans.append(c)
        else:
            ans.appendleft(c)
    return "".join(ans)
#+end_src

#+name: my solution 557
#+begin_src python
def reverse_words(s):
    return " ".join([word[::-1] for word in s.split(" ")])
return reverse_words("Let's take leetCode contest")
#+end_src

#+RESULTS: my solution 557
: s'teL ekat edoCteel tsetnoc

**** DONE 876 Middle of the linked list
:LOGBOOK:
CLOCK: [2019-09-24 Tue 20:22]--[2019-09-24 Tue 20:39] =>  0:17
:END:
***** Basic info
Given a non-empty, singly linked list with head node ~head~, return the middle node of the linked list.
If there are two middle nodes, return the second middle node.
***** Tackling process

We have to loop through the linked list to determine the number of nodes it has. We can use one node $cur$ to store the current node position and another $mid$ to store the current middle node position corresponding to the $cur$.
Intuitively, $mid=ceiling(cur/2)$.
The following code gives $O(n)$ time and $O(1)$ space complexity.
#+name: my solution 876
#+begin_src python
def middle_node(head):
    cur = {"node": head, "pos": 1}
    mid = {"node": head, "pos": 1}
    while cur["node"].next:
        cur["node"] = cur["node"].next
        cur["pos"] += 1
        cur_mid = mid["pos"]
        new_mid = math.ceil(( cur["pos"] + 1)/2)
        if new_mid > cur_mid:
            mid["pos"] += 1
            mid["node"] = mid["node"].next

    return mid["node"]
#+end_src

We can have a $fast$ pointer that traverses twice as fast as the $slow$ pointer. When $fast$ reaches the end of the list, $slow$ must be in the middle.
#+name: fast and slow pointer
#+begin_src python
def middle_node(head):
    slow = fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
    return slow
#+end_src
**** DONE 908 Smallest Range 1
:LOGBOOK:
CLOCK: [2019-09-24 Tue 21:20]--[2019-09-24 Tue 21:37] =>  0:17
:END:
***** Basic info
Given an array $A$ of integers and an integer $K$, for each $A[i]$, we may choose any $x$ with $-K<=x<=K$ and add $x$ to $A[i]$.
After this process, we have some array $B$.
Return the smallest possible difference between $max(B)$ and $min(B)$.
***** Tackling process
Let's say $B=f(A, K)$, where $f$ tries to reduce standard deviation of $A$.

#+name: my solution 908
#+begin_src python
from typing import List
def smallest_range_1(A: List[int], K:int) -> int:
    sorted_A = sorted(A)
    max_elem = sorted_A[-1]
    min_elem = sorted_A[0]

    if  (max_elem - min_elem) / 2  > K:
        return max_elem - min_elem - 2 * K
    else:
        return 0
return smallest_range_1([2, 7, 2], 1)
#+end_src

#+RESULTS: my solution 908
: 3

**** DONE 1047 Remove all adjacent duplicates in string            :stack:
:LOGBOOK:
CLOCK: [2019-09-25 Wed 09:20]--[2019-09-25 Wed 09:35] =>  0:15
CLOCK: [2019-09-24 Tue 21:39]--[2019-09-24 Tue 22:07] =>  0:28
:END:
***** Basic info
Given a string $S$ of lowercase letters, a /duplicate removal/ consists of two adjacent and equal letters, and removing them.
We repeatedly make duplicate removals on $S$ until we no longer can.
Return the final string after all such duplicate removals have been made.
A unique answer is guaranteed.
For example:
#+begin_quote
Input: "abbaca"
Output: "ca"
Explanation: 
For example, in "abbaca" we could remove "bb" since the letters are adjacent and equal, and this is the only possible move.  The result of this move is that the string is "aaca", of which only "aa" is possible, so the final string is "ca".
#+end_quote

***** Tackling process
:LOGBOOK:
CLOCK: [2019-09-26 Thu 14:12]--[2019-09-26 Thu 14:20] =>  0:08
CLOCK: [2019-09-25 Wed 10:09]--[2019-09-25 Wed 10:31] =>  0:22
CLOCK: [2019-09-25 Wed 09:40]--[2019-09-25 Wed 09:49] =>  0:09
:END:
Time complexity is $O(\sqrt(n))$, where $n$ is the number of letters in the string.
#+name: my solution 1047
#+begin_src python
def remove_duplicates(S):
    def remove_dup(target):
        ans = ""
        cur = 0
        test = cur + 1
        while cur <= len(target) -2:
            while  test <len(target) and target[cur] == target[test]:
                test += 1
            if (test - cur) == 1:
                ans = ans + target[cur]
                cur = test
                test = cur + 1
        if ans and target[-1] != ans[-1]:
            ans = ans + target[-1]
        return ans
    
    start = S
    while True:
        end = remove_dup(start)
        if start == end:
            return end
        start = end
return remove_duplicates("aaaa")
#+end_src

#+RESULTS: my solution 1047

#+name: second try 1047
#+begin_src python
def remove_duplicates(S):
    def remove_dup(target):
        ans = ""
        if len(target) < 2:
            return target
        cur = 0
        test = 1
        while cur < len(target) - 1:
            if target[test] and target[cur] == target[test]:
                cur = test + 1
            else:
                ans += target[cur]
                cur = test

                # take care of the last character
                if test == len(target) - 1:
                    ans += target[test]
                    test = cur + 1
        if cur == len(target) - 1:
            ans += target[cur]
        return ans

    end = start = S
    while True:
        end = remove_dup(start)
        if end == start:
            return end
        start = end
return remove_duplicates("azzy")
            
#+end_src

#+RESULTS: second try 1047
: a

#+name: third try (correct solution)
#+begin_src python
def remove_duplicates(S):
    def remove_dup(target):
        if len(target) < 2:
            return target
        ans = []
        ans.append(target[0])
        for c in target[1:]:
            # always need to check if ans is empty before doing pop()
            if ans and c == ans[-1]:
                ans.pop()
            else:
                ans.append(c)
        return "".join(ans)
    start = S
    while True:
        end = remove_dup(start)
        return end
        if start == end:
            return end
        start = end
return remove_duplicates("aaaa")

#+end_src

#+RESULTS: third try

**** DONE 821 Shortest distance to a character
***** Basic info
:LOGBOOK:
CLOCK: [2019-09-26 Thu 14:30]--[2019-09-26 Thu 14:33] =>  0:03
:END:
Given a string $S$ and a character $C$, return an array of integers representing the shortest distance from the character $C$ in the string.
All leeters are lowercase and $C$ is a single character guaranteed to be in string $S$.
#+begin_quote
Input: S = "loveleetcode", C = 'e'
Output: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]
#+end_quote
***** Tackling process
:LOGBOOK:
CLOCK: [2019-09-26 Thu 14:33]--[2019-09-26 Thu 15:16] =>  0:43
:END:

Starting from the left of the string $S$, we count from 1 until we find the character $C$:
Starting from the right of the string $S$, we count from 1 until we find the character $C$:
| string      | l | o | v | e | l | e | e | t | c | o | d | e |
| first scan  | 1 | 2 | 3 | 0 | 1 | 0 | 0 | 1 | 2 | 3 | 4 | 0 |
| second scan | 3 | 2 | 1 | 0 | 1 | 0 | 0 | 4 | 3 | 2 | 1 | 0 |

We choose min(first scan, second scan).

#+name: my solution 821
#+begin_src python
def shortest_to_char(S, C):
    first_scan = []
    second_scan = []
    counter = 0
    first_zero_pos = -1
    last_zero_pos = -1
    ans = []
    
    # O(N)
    for i, c in enumerate(S):
        counter += 1
        if c == C:
            first_scan.append(0)
            counter = 0
            if first_zero_pos == -1:
                first_zero_pos = i
                last_zero_pos = i
        else:
            first_scan.append(counter)

    # O(N)
    for i, c in enumerate(S[::-1]):
        counter += 1
        if c == C:
            second_scan.append(0)
            counter = 0
        else:
            second_scan.append(counter)
            # O(N)
    pos = 0
    # use dists from second scan before we hit the first 0
    while pos < first_zero_pos:
        ans.append(second_scan[::-1][pos])
        pos += 1
        # use min()
    while pos >= first_zero_pos and pos < last_zero_pos:
        ans.append(min(first_scan[pos], second_scan[::-1][pos]))
        pos += 1
        # use dists from first scan after we hit the last 0
    while pos >= last_zero_pos and pos < len(S):
        ans.append(first_scan[pos])
        pos += 1
        
    return ans
return shortest_to_char("loveleetcode", "e")
#+end_src

#+RESULTS: my solution 821
| 3 | 2 | 1 | 0 | 1 | 0 | 0 | 1 | 2 | 2 | 1 | 0 |

#+name: leetcode discussion solution
#+begin_src python
def shortest_to_char(S, C):
    idx = [] # where a match happens
    res = [] # answers

    # O(N)
    for i in range(len(S)):
        if S[i] == C:
            idx.append(i) # find all matches
            
    # O(N^2)
    for i in range(len(S)): # check every character in S
        tmp = [] # record a single character's distance to all matches
        for j in idx:
            tmp.append(abs(i - j))
            # record the min distance of a character to any of the matches
        res.append(min(tmp))
    return res
#+end_src
**** DONE Leaf-similar trees                   :tree:recursive:yield_from:
***** Basic info
:LOGBOOK:
CLOCK: [2019-09-26 Thu 15:28]--[2019-09-26 Thu 15:31] =>  0:03
:END:
[[https://leetcode.com/problems/leaf-similar-trees/][Leaf-similar trees]]
Consider all the leaves of a /binary tree/. From left to right order, the values of those leaves form a 
/leaf value sequence/.
Two binary trees are considered /leaf-similar/ if their leaf value sequence is the same.
Return /true/ iff the two given trees with head nodes $root1$ and $root2$ are leaf-similar.
Both of the given trees will have between 1 to 100 nodes.
***** Tackling process
:LOGBOOK:
CLOCK: [2019-09-26 Thu 15:32]--[2019-09-26 Thu 15:40] =>  0:08
:END:
We need one function to get the leaf value sequence.

#+name: my solution 821
#+begin_src python
def leaf_similar(root1, root2):
    def get_leaf_value_sequence(node, ans):
        if node:
            if node.left == None and node.right == None:
                ans.append(node.val)
            else:
                get_leaf_value_sequence(node.left, ans)
                get_leaf_value_sequence(node.right, ans)
        return ans
    ans_1 = []
    ans_1 = get_leaf_value_sequence(root1, ans_1)
    ans_2 = []
    ans_2 = get_leaf_value_sequence(root2, ans_2)
    return ans_1 == ans_2
#+end_src

#+name: leetcode solution
#+begin_src python
def leaf_similar(root1, root2):
    def dfs(node):
        if node:
            if not node.left and not node.right:
                yield node.val
                yield from dfs(node.left)
                yield from dfs(node.right)

    return list(dfs(root1)) == list(dfs(root2))
#+end_src
***** Thoughts
$yield from$ allows a generator to delegate part of its operations to another generator.
#+name: yield from example
#+begin_src python
def g(x):
    yield from range(x, 0, -1)
    yield from range(x)
return list(g(5))
#+end_src

#+RESULTS: yield from example
| 5 | 4 | 3 | 2 | 1 | 0 | 1 | 2 | 3 | 4 |

**** DONE 867 Transpose matrix                             :algorithm:zip:
***** Basic info
:LOGBOOK:
CLOCK: [2019-09-26 Thu 16:58]--[2019-09-26 Thu 16:58] =>  0:00
:END:
Given a matrix $A$, return the transpose of $A$.
***** Tackling process
:LOGBOOK:
CLOCK: [2019-09-26 Thu 17:01]--[2019-09-26 Thu 17:12] =>  0:11
:END:

#+name: my solution 867
#+begin_src python
def transpose(A):
    # ans = [[]] * len(A[0])
    ans = [[] for _ in range(len(A[0]))]

    for i, row in enumerate(A):
        for j, col in enumerate(row):
            ans[j].append(col)
    return ans
return transpose([[1,2,3],[4,5,6]])
#+end_src

#+RESULTS: my solution 867
| 1 | 4 |
| 2 | 5 |
| 3 | 6 |

#+name: leetcode oneliner
#+begin_src python
def transpose(A):
    return list(zip(*A)) # * unpacks the list A into multiple lists, which are required arguments of zip()
return transpose([[1,2,3],[3,4,5]])
#+end_src

#+RESULTS: leetcode oneliner
| 1 | 3 |
| 2 | 4 |
| 3 | 5 |

***** Thoughts
:LOGBOOK:
CLOCK: [2019-09-26 Thu 17:13]--[2019-09-26 Thu 17:25] =>  0:12
:END:
To create an empty list of size n:
#+begin_src python
lst = [None] * n
#+end_src
To create a list of n *different* lists (dicts, objects, etc.):
#+begin_src python
lst = [[] for _ in range(n)]
#+end_src

/zip/ "makes an iterator that aggregates elements from each of the iterables".
Returns an iterator of tuples, where the i-th tuple contains the i-th element from each of the argument sequences of iterables.
#+name: Using the /zip/ function.
#+begin_src python
x = [1, 2, 3]
y = [3, 4, 5]
return list(zip([x,y]))
#+end_src

#+RESULTS: Using the /zip/ function.
| (1 2 3) |
| (3 4 5) |

#+name: Using the /zip/ function 2.
#+begin_src python
x = [1, 2, 3]
y = [3, 4, 5]
return list(zip(x,y))
#+end_src

#+RESULTS: Using the /zip/ function 2.
| 1 | 3 |
| 2 | 4 |
| 3 | 5 |

#+name: unzip
#+begin_src python
x = [1, 2, 3]
y = [3, 4, 5]
return list(zip(*zip(x,y)))
#+end_src

#+RESULTS: unzip
| 1 | 2 | 3 |
| 3 | 4 | 5 |

**** DONE 893 Groups of special-equivalent strings
***** Basic info
:LOGBOOK:
CLOCK: [2019-09-26 Thu 17:26]--[2019-09-26 Thu 17:30] =>  0:04
:END:
Given an array $A$ of strings. Two strings $S$ and $T$ are /special-equivalent/ if after any number of moves, $S==T$.
A /move/ consists of choosing two indices $i$ and $j$ with $i%2 == j%2$, and swapping $S[i]$ with $S[j]$.
A /group of special-equivalent strings from A/ is a non-empty subset $Sub$ of $A$ such that any string not in $Sub$ is not special equivalent with any string in $Sub$.
Return the number of groups of special equivalent strings from $A$.
All $A[i]$ have the same length and consist of only lowercase letters.

Example:
#+begin_src example
A = ["a", "a"]
gives 1 because we can only have one group of special-equivalent strings - ["a", "a"]

A = ["a", "b", "c", "a", "c", "c"]
gives 3 because we have ["a", "a"] with no move or with one single move, ["b"] with no move or one single move, and ["c", "c", "c"] with no move or one single move
#+end_src
***** Tackling process
:LOGBOOK:
CLOCK: [2019-09-26 Thu 17:30]--[2019-09-26 Thu 17:50] =>  0:20
:END:
Basically, for any given string S1, if there exists another string S2 such that:

1. len(S1) == len(S2)
2. sorted(S1[::2]) == sorted(S2[::2])
3. sorted(S1[1::2]) == sorted(S2[1::2])

then, S1 is special equivalent to S2.

#+name: my solution 893
#+begin_src python
def num_special_equiv_groups(A):
    def is_special_equiv(s1, s2):
        if len(s1) == len(s2):
            if sorted(s1[::2]) == sorted(s2[::2]) and sorted(s1[1::2]) == sorted(s2[1::2]):
                return True
        return False
    special_equiv_groups = set()

    for string in A:
        for seg in special_equiv_groups:
            if is_special_equiv(seg, string):
                break
        else:
            special_equiv_groups.add(string)

    return len(special_equiv_groups)

return num_special_equiv_groups(["aa", "bb", "ab", "ba"])
#+end_src

#+RESULTS: my solution 893
: 4

***** Thoughts
Through swapping, we can permute the even indexed letters, and the odd indexed letters.
What characterizes these permutations is the count of the letters: all such permutations have the same count (for each letter), and different counts have different permutations.
Thus the function $C(S)$ = the count of the even indexed letters in S, followed by the count of the odd indexed letters in S.
Afterwards, we count the number of unique $C(S)$ for $S \in A$.
#+name: leetcode solution
#+begin_src python
def num_special_equiv_groups(A):
    def count(word):
        ans = [0] * 52
        for i, letter in enumerate(word):
            # ordinal number of the letter plus its position information (odd, even)
            ans[ord(letter) - ord('a') + 26 * (i%2)] += 1
        return tuple(ans)
    return len({count(word) for word in A})
return num_special_equiv_groups(["aa", "bb", "ab", "ba"])
#+end_src

#+RESULTS: leetcode solution
: 4

**** DONE 806 Number of lines to write string
***** Basic info
:LOGBOOK:
CLOCK: [2019-09-27 Fri 14:21]--[2019-09-27 Fri 14:32] =>  0:11
:END:
Write the letters of a given string $S$, from left to right, into lines.
Each line has a maximum width of 100 units, and if writing a letter would cause the width to exceed 100 units, it is written on the next line.
Given an array $widths$, where $widths[0]$ is the width of 'a', $widths[1]$ is the width of 'b',..., and $widths[25]$ is the width of 'z'.

Now answer two questions: how many lines have at least one character from $S$, and what is the width used by the last such line?
***** Tackling process
:LOGBOOK:
CLOCK: [2019-09-27 Fri 14:32]--[2019-09-27 Fri 14:47] =>  0:15
:END:
Example :
Input: 
widths = [4,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]
S = "bbbcccdddaaa"
Output: [2, 4]
Explanation: 
All letters except 'a' have the same length of 10, and 
"bbbcccdddaa" will cover 9 * 10 + 2 * 4 = 98 units.
For the last 'a', it is written on the second line because
there is only 2 units left in the first line.
So the answer is 2 lines, plus 4 units in the second line.

| b | b | b | b | ... |  d |  a |  a |  a |  a |  a |  a |  a |  a |    |     |
| 1 | 2 | 3 | 4 | ... | 90 | 91 | 92 | 93 | 94 | 95 | 96 | 97 | 98 | 99 | 100 |
| a | a | a | a |     |    |    |    |    |    |    |    |    |    |    |     |
| 1 | 2 | 3 | 4 |     |    |    |    |    |    |    |    |    |    |    |     |

#+name: my solution 806
#+begin_src python
def number_of_lines(widths, S):
    ans = [100]

    for c in S:
        units_to_write = widths[ord(c) - ord('a')]
        if units_to_write > ans[-1]:
            ans.append(100)
            ans[-1] -= units_to_write
    return [len(ans), 100-ans[-1]]
return number_of_lines([10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10],"abcdefghijklmnopqrstuvwxyz")
#+end_src

#+RESULTS: my solution 806
| 3 | 60 |

***** Thoughts
:LOGBOOK:
CLOCK: [2019-09-27 Fri 14:50]--[2019-09-27 Fri 15:00] =>  0:10
:END:
#+name: leetcode solution 806
#+begin_src python
def num_of_lines(widths, S):
    lines, width = 1, 0
    for c in S:
        w = widths[ord(c) - ord('a')]
        width += w
        if width > 100:
            lines += 1
            width = w # not need to start from 0
    return lines, width
#+end_src

**** DONE 620 Not boring movies                                      :sql:
***** Basic info
:LOGBOOK:
CLOCK: [2019-09-27 Fri 15:14]--[2019-09-27 Fri 15:16] =>  0:02
:END:
X city opened a new cinema, many people would like to go to this cinema. The cinema also gives out a poster indicating the movies' ratings and descriptions.
Write an SQL query to output movies with an odd numbered ID and a description that is not 'boring'. Order the result by rating.

***** Tackling process
:LOGBOOK:
CLOCK: [2019-09-27 Fri 15:16]--[2019-09-27 Fri 15:22] =>  0:06
:END:

#+name: my solution 620
#+begin_src sql
select * from cinema where (id % 2) != 0 and description!='boring' order by rating desc;
#+end_src
***** Thoughts
:LOGBOOK:
CLOCK: [2019-09-27 Fri 15:22]--[2019-09-27 Fri 15:23] =>  0:01
:END:
This is slightly faster
#+name: leetcode solution 620
#+begin_src sql
select * from cinema where mod(id,2)=0 and description<>'boring' order by rating desc;
#+end_src

**** DONE 766 Toeplitz matrix
***** Basic info
:LOGBOOK:
CLOCK: [2019-09-27 Fri 15:50]--[2019-09-27 Fri 15:52] =>  0:02
:END:
A matrix is /Toeplitz/ if every diagonal from top-left to bottom-right has the same element.
Now given an $M\times N$ matrix, return True iff the matrix is /Toeplitz/.
***** Tackling process                              :follow_up_questions:
:LOGBOOK:
CLOCK: [2019-09-27 Fri 15:53]--[2019-09-27 Fri 16:11] =>  0:18
:END:

#+name: my solution 766
#+begin_src python
def is_toeplitz_matrix(matrix):
    def same_elem_on_diagonal(row, col, matrix):
        test_row = row + 1
        test_col = col + 1
        while test_row < len(matrix) and test_col < len(matrix[0]):
            if matrix[row][col] != matrix[test_row][test_col]:
                return False
            test_row += 1
            test_col += 1
        return True
    for col in range(len(matrix[0])):
        if not same_elem_on_diagonal(0, col, matrix):
            return False

    for row in range(len(matrix)):
        if not same_elem_on_diagonal(row, 0, matrix):
            return False
    return True
return is_toeplitz_matrix([[1,2,3,4],[5,1,2,3],[9,5,1,2]])
#+end_src

#+RESULTS: my solution 766
: True

***** Thoughts
:LOGBOOK:
CLOCK: [2019-09-27 Fri 16:11]--[2019-09-27 Fri 16:23] =>  0:12
:END:

Time complexity $O(M\times N)$.
Space complexity $O(1)$.

Leetcode solution: Two coordinates are on the same diagonal iff $r1 - c1 == r2 - c2$.
So we need to remember the value of that diagonal as groups[r-c], if we see a mismatch, the matrix is not Toeplitz; otherwise it is.
Time complexity $O(M\times N)$.
Space complexity $O(M+N)$.
#+name: leetcode solution 7665
#+begin_src python
def is_toeplitz_matrix(matrix):
    groups = {}
    for r, row in enumerate(matrix):
        for c, val in enumerate(row):
            if r-c not in groups:
                groups[r-c] = val
            elif groups[r-c] != val:
                return False
    return True
#+end_src
***** Follow up questions
****** What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matri into the memory at once?

****** What is the matrix is so large that you can only load up a partial row into the memory at once?
**** DONE 985 Sum of even numbers after queries           :time_sensitive:
***** Basic info
:LOGBOOK:
CLOCK: [2019-09-27 Fri 16:27]--[2019-09-27 Fri 16:34] =>  0:07
:END:
We have an array $A$ of integers, and an array $queries$ of queries.
For the i-th query $val = queries[i][0], index = queries[i][1]$, we add val to $A[index]$.
Then, the answer to the i-th query is the sum of even values of $A$.
Here, the given $index=queries[i][1]$ is a 0-based index, and each query permanently modifies the array $A$.
Return the answer to all queries. Your answer array should have $answer[i]$ as the answer to the i-th query.

Example:
#+begin_example
Input: A = [1,2,3,4], queries = [[1,0],[-3,1],[-4,0],[2,3]]
Output: [8,6,2,4]
Explanation: 
At the beginning, the array is [1,2,3,4].
After adding 1 to A[0], the array is [2,2,3,4], and the sum of even values is 2 + 2 + 4 = 8.
After adding -3 to A[1], the array is [2,-1,3,4], and the sum of even values is 2 + 4 = 6.
After adding -4 to A[0], the array is [-2,-1,3,4], and the sum of even values is -2 + 4 = 2.
After adding 2 to A[3], the array is [-2,-1,3,6], and the sum of even values is -2 + 6 = 4.
#+end_example
***** Tackling process
:LOGBOOK:
CLOCK: [2019-09-27 Fri 20:06]--[2019-09-27 Fri 20:14] =>  0:08
CLOCK: [2019-09-27 Fri 16:35]--[2019-09-27 Fri 17:02] =>  0:27
:END:
This is pretty transactional. We just need to follow the instructions and the program should be done.

#+name: my solution 985
#+begin_src python
from typing import List

def sum_even_after_queries(A: List[int], queries: List[List[int]]) -> List[int]:
    evens = {index:(val if val %2 ==0 else 0) for index, val in enumerate(A)}
    ans = []
    for val, index in queries:
        A[index] += val
        if A[index] % 2 == 0:
            evens[index] = A[index]
        else:
            evens.pop(index, None)
            ans.append(sum(evens.values()))
    return ans
return sum_even_after_queries([1,2,3,4], [[1,0],[-3,1],[-4,0],[2,3]])
#+end_src

#+RESULTS: my solution 985
| 8 | 6 | 2 | 4 |

#+name: my solution 985 using list
#+begin_src python
from typing import List

def sum_even_after_queries(A: List[int], queries: List[List[int]]) -> List[int]:
    evens = [(val if val %2 ==0 else 0) for val in A]
    ans = []
    for val, index in queries:
        A[index] += val
        if A[index] % 2 == 0:
            evens[index] = A[index]
        else:
            evens[index] = 0
            ans.append(sum(evens))
    return ans
return sum_even_after_queries([1,2,3,4], [[1,0],[-3,1],[-4,0],[2,3]])
#+end_src

#+RESULTS: my solution 985 using list
| 8 | 6 | 2 | 4 |

#+name: my solution 985 even faster
#+begin_src python
from typing import List

def sum_even_after_queries(A: List[int], queries: List[List[int]]) -> List[int]:
    evens_sum = sum([(val if val %2 ==0 else 0) for val in A])
    ans = []
    for val, index in queries:
        temp = A[index] + val
        if A[index] % 2 == 0:
            if val % 2 == 0:
                evens_sum += val
            else:
                evens_sum -= A[index]
        else:
            if val % 2 == 1:
                evens_sum += temp
                ans.append(evens_sum)
                A[index] = temp
    return ans
return sum_even_after_queries([1,2,3,4], [[1,0],[-3,1],[-4,0],[2,3]])
#+end_src

#+RESULTS: my solution 985 even faster
| 8 | 6 | 2 | 4 |

#+name: leetcode solution 985
#+begin_src python
def sum_even_after_queries(A, queries):
    total = sum([x for x in A if x % 2 ==0])
    ans = []

    for val, idx in queries:
        if A[idx] % 2 == 0: total -= A[idx] # take A[idx[ from the original total first
        A[idx] += val
        if A[idx] % 2 == 0: total += A[idx] # add the new A[idx] back to total
        ans.append(total)

    return ans
#+end_src
**** DONE 104 Maximum depth of binary tree    :tree:binary_tree:recursion:
***** Basic info
:LOGBOOK:
CLOCK: [2019-09-27 Fri 20:20]--[2019-09-27 Fri 20:21] =>  0:01
:END:
Given a binary tree, find its maximum depth.
***** Tackling process
:LOGBOOK:
CLOCK: [2019-09-27 Fri 20:24]--[2019-09-27 Fri 20:45] =>  0:21
:END:
We start from root node, and the depth is 1.
We can use a recursive function (dfs) to traverse the tree.
Use one variable to store the deepest depth.

#+name: my solution 104
#+begin_src python
def max_depth(root):

    def dfs(node, cur_depth):
        if node:
            cur_depth += 1
            if node.left or node.right:
                return max(dfs(node.left, cur_depth),
                           dfs(node.right, cur_depth))
            else:
                return cur_depth
        else:
            return 0
    return dfs(root, 0)
#+end_src

#+name: my solution 104 more simplified
#+begin_src python
def max_depth(root):

    def dfs(node, cur_depth):
        # this is the reverse calculation of the leetcode solution below
        if node:
            cur_depth += 1
            return max(dfs(node.left, cur_depth), dfs(node.right, cur_depth))
        else:
            return cur_depth
    return dfs(root, 0)
#+end_src

#+name: leetcode solution
#+begin_src python
def max_depth(root):
    def recursive(node):
        if node is None:
            return 0
        return max(recursive(node.left)+1,recursive(node.right)+1)

    return recursive(root)
#+end_src
***** Thoughts
:LOGBOOK:
CLOCK: [2019-09-27 Fri 21:02]--[2019-09-27 Fri 21:08] =>  0:06
:END:
No need to record /max_depth/ during each recursion.
$max()$ function helps get the maximum.

**** DONE 682 Baseball game
***** Basic info
:LOGBOOK:
CLOCK: [2019-09-28 Sat 13:22]--[2019-09-28 Sat 13:34] =>  0:12
:END:
Given a list of strings, each string can be one of the 4 following types:
1. $Integer$ (one round's score): Directly represents the number of points you get in this round.
2. $+$ (one round's score): Represents that the points you get in this round are the sum of the last two *valid* round's points
3. $D$ (one round's score): represents that the points you get in this round are the doubled data of the last *valid* round's points
4. $C$ (an operation, which isn't a round's score): indicates that the last *valid* round's points were invalid and should be removed.
Each round's operation is permanent and could have an impact on the round before and the round after.
You need to return the sum of the points you could get in all the rounds.

Example:
#+name: 682 example
#+begin_example
Input: ["5","2","C","D","+"]
Output: 30
Explanation: 
Round 1: You could get 5 points. The sum is: 5.
Round 2: You could get 2 points. The sum is: 7.
Operation 1: The round 2's data was invalid. The sum is: 5.  
Round 3: You could get 10 points (the round 2's data has been removed). The sum is: 15.
Round 4: You could get 5 + 10 = 15 points. The sum is: 30.
#+end_example

|            | 5 | 2 |  c | d   | +       |   |
| new points | 5 | 2 | -2 | 5*2 | 5 + 5*2 |   |
| total      | 5 | 7 |  5 | 15  | 30      |   |


***** Tackling process
:LOGBOOK:
CLOCK: [2019-09-28 Sat 13:34]--[2019-09-28 Sat 13:41] =>  0:07
:END:
total
#+name: my solution 682
#+begin_src python
from typing import List

def cal_points(ops: List[str]) -> int:
    total = 0
    valid_points = []

    for op in ops:
        if op == "C":
            cancelled_points = valid_points.pop()
            total -= cancelled_points
        elif op == "D":
            valid_points.append(valid_points[-1] * 2)
        elif op == "+":
            valid_points.append(valid_points[-1] + valid_points[-2])
        else:
            valid_points.append(int(op))
        if op != "C":
            total += valid_points[-1]
    return total


return cal_points(["5", "2", "C", "D", "+"])

#+end_src

#+RESULTS: my solution 682
: 30

**** DONE 136 Single number                             :bit_manipulation:
***** Basic info
:LOGBOOK:
CLOCK: [2019-09-28 Sat 13:47]--[2019-09-28 Sat 13:48] =>  0:01
:END:
Given a non-empty array of integers, every element appears /twice/ except for one. Find that single one.
The algorithm should have a linear runtime complexity, and preferrably without using extra memory.

***** Tackling process
:LOGBOOK:
CLOCK: [2019-09-28 Sat 13:48]--[2019-09-28 Sat 13:59] =>  0:11
:END:

We can easily accomplish it with $O(N)$ time complexity using a hash table.
#+name: my solution 136 with hash table
#+begin_src python
def single_number(nums):
    test = {}
    for num in nums:
        test[num] = test.get(num, 0) + 1

    for k, v in test.items():
        if v == 1:
            return k
return single_number([2,2,1])
#+end_src

#+RESULTS: my solution 136 with hash table
: 1
***** Thoughts
Math solution based on:
$2\times(a+b+c)-(a+a+b+b+c) = c$
#+name: 136 leetcode set solution
#+begin_src python
def single_num(nums):
    return 2 * sum(set(nums)) - sum(nums)
#+end_src

*Bit manipulation*
If we take XOR of zero and some bit, it will return that bit:
$a\oplus 0 = a$
If we take XOR of two same bits, it will return 0
$a\oplus a=0$
$a\oplus b \oplus a= (a\oplus a)\oplus b= 0\oplus b = b$

#+name: 136 leetcode bit manipulation solution
#+begin_src python
def single_num(nums):
    a=0
    for i in nums:
        a ^= i
    return a
return single_num([2,2,1])
#+end_src

#+RESULTS: 136 leetcode bit manipulation solution
: 1

**** DONE 884 Uncommon words from two sentences         :set_manipulation:
***** Basic info
:LOGBOOK:
CLOCK: [2019-09-28 Sat 14:11]--[2019-09-28 Sat 14:31] =>  0:20
:END:
Given two sentences $A$ and $B$. (A sentence is a string of space separated words. Each word consists only of lower case letters).
A word is /uncommon/ if it appears exactly once in one of the sentences, and does not appear in the other sentence.
Return a list of all uncommon words.
You may return the list in any order.
***** Tackling process
If it is guaranteed that there is only one word that is different in the two sentences, then we can use the bit manipulation from [[136 Single number]].

In this case we can use the math solution from [[136 Single number]]:
$2\times (a+b+c) - (a+a+b+c)=b+c$

No, we cannot use it because some words can appear more than twice.
The following is $O(N)$ for time and space complexity.
#+name: my solution 884
#+begin_src python
from typing import List
def uncommon_from_sentences(A: str, B: str) -> List[str]:
    count = {}
    ans = []

    for i in (A.split() + B.split()):
        count[i] = count.get(i, 0) + 1

    for k, v in count.items():
        if v == 1:
            ans.append(k)
    return ans

return uncommon_from_sentences("this apple is sweet", "this apple is sour")
#+end_src

#+RESULTS: my solution 884
| sweet | sour |

***** Thoughts
:LOGBOOK:
CLOCK: [2019-09-29 Sun 09:54]--[2019-09-29 Sun 10:06] =>  0:12
:END:
Here is set manipulation solution
$filter(function, iterable)$ returns those elements of $iterable$ for which $function$ returns true. 
It's equivalent to ~(item for item in iterable if function(item))~.
Time complexity: $O(M^{2} + N^{2})$ where $M$,$N$ are the numbers of elements in $A$ and $B$.
#+name: leetcode set manipulation 884
#+begin_src python
def uncommon_from_sentences(A, B):
    a = A.split()
    b = B.split()
    # count() has to be run N times for each element x, therefore the complexity is O(N^2)
    rep = set(filter(lambda x: a.count(x) != 1, a)) | set(filter(lambda x: b.count(x) != 1, b))
    a = set(a)
    b = set(b)
    # this is O(N)
    return ((a - b) | (b - a)) -rep
return uncommon_from_sentences("this apple is sweet", "this apple is sour")
#+end_src

#+RESULTS: leetcode set manipulation 884
| sour | sweet |

**** DONE 669 Trim a binary tree                          :tree:recursive:
***** Basic info
Given a BST and the lowest and highest boundaries as $L$ and $R$, trim the tree so that all its elements lies in 
$[L, R], (R\geq L)$. You might need to change the roort of the tree, so that the result should return the new root of the trimmed BST.

Example:
#+begin_example
Input: 
    1
   / \
  0   2

  L = 1
  R = 2

Output: 
    1
      \
       2
#+end_example
#+begin_example
Input: 
    3
   / \
  0   4
   \
    2
   /
  1

  L = 1
  R = 3

Output: 
      3
     / 
   2   
  /
 1
#+end_example

***** Tackling process
:LOGBOOK:
CLOCK: [2019-09-29 Sun 10:11]--[2019-09-29 Sun 10:46] =>  0:35
:END:

The following is wrong.
#+begin_quote
Because we are dealing with a BST, it's true that:
1. if $node.val < L$, then this branch can be safely discarded.
2. if $node.val > R$, then this branch can be safely discarded.
#+end_quote

#+name: my solution 669
#+begin_src python
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def trim_BST(root: TreeNode, L: int, R: int) -> TreeNode:
    def recursive(node, L, R):
        if node is None:
            return node
        if node.val < L:
            node = recursive(node.right, L, R)
        if node.val > R:
            node = recursive(node.left, L, R)
        return node
    return new_root
#+end_src

#+name: leetcode solution 669
#+begin_src python
def trim_BST(root, L, R):
    def trim(node):
        if not node:
            return None
        elif node.val > R:
            return trim(node.left)
        elif node.val < L:
            return trim(node.right)
        else:
            node.left = trim(node.left)
            node.right = trim(node.right)
            return node
        returm trim(root)
#+end_src
***** Thoughts
:LOGBOOK:
CLOCK: [2019-09-29 Sun 10:46]--[2019-09-29 Sun 10:49] =>  0:03
:END:
In recursion, we need to find the following:
1. The base case(s)
2. Recursion
#+begin_src python
def trim_BST(root, L, R):
    def trim(node):
        if not node:
            # base case
            return None
        elif node.val > R:
            return trim(node.left)
        elif node.val < L:
            return trim(node.right)
        else:
            # base case
            node.left = trim(node.left)
            node.right = trim(node.right)
            return node
        returm trim(root)
#+end_src
**** DONE 496 Next greater element 1
***** Basic info
:LOGBOOK:
CLOCK: [2019-09-30 Mon 19:47]--[2019-09-30 Mon 19:52] =>  0:05
:END:
Given two arrays (without duplicates), $nums1$ and $nums2$, where $num1$'s elements are subset of $nums2$.
Find all the next greater numbers from $nums1$'s elements in the corresponding places of $nums2$.
The Next Greater Element of a number $x$ in $nums1$ is the first greater number to its right in $nums2$. If it does not exists,
output -1 for this number.

Example:
#+name: example 1
#+begin_example
Input: nums1 = [4,1,2], nums2 = [1,3,4,2].
Output: [-1,3,-1]
Explanation:
    For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1.
    For number 1 in the first array, the next greater number for it in the second array is 3.
    For number 2 in the first array, there is no next greater number for it in the second array, so output -1.
#+end_example

#+name: example 2
#+begin_example
Input: nums1 = [2,4], nums2 = [1,2,3,4].
Output: [3,-1]
Explanation:
    For number 2 in the first array, the next greater number for it in the second array is 3.
    For number 4 in the first array, there is no next greater number for it in the second array, so output -1.
#+end_example
***** Tackling process
:LOGBOOK:
CLOCK: [2019-09-30 Mon 19:52]--[2019-09-30 Mon 19:58] =>  0:06
:END:
$nums1 \subset nums2$
We need to find the element $x$ in $nums1$ the position in $nums2$, and then check if the rest of $nums2$ has any element that is greater than $x$.

#+name: my solution 496
#+begin_src python
from typing import List

def next_greater_element(nums1, nums2) -> List[int]:
    ans = []
    for i in nums1:
        for j in nums2[nums2.index(i):]:
            if j > i:
                ans.append(j)
                break
        else:
            ans.append(-1)
    return ans
return next_greater_element([2,4],[1,2,3,4])
#+end_src

#+RESULTS: my solution 496
| 3 | -1 |

**** DONE 762 Prime number of set bits in binary representation :bit_manipulation:
***** Basic info
:LOGBOOK:
CLOCK: [2019-09-30 Mon 20:26]--[2019-09-30 Mon 20:27] =>  0:01
:END:
Given two integers $L$ and $R$, find the count of numbers in the range $[L, R]$ (inclusive) having a prime number of set bits in their binary representation.

L, R will be integers L <= R in the range [1, 10^6].
R - L will be at most 10000.
***** Tackling process
:LOGBOOK:
CLOCK: [2019-10-01 Tue 08:43]--[2019-10-01 Tue 09:04] =>  0:21
CLOCK: [2019-09-30 Mon 20:27]--[2019-09-30 Mon 21:05] =>  0:38
:END:
Straightforward solution would be convert the number to binary and then count the number of '1's and check if the count is prime.
We can use the *Miller-Rabin* algorithm to test if the number is a prime (in this case this is guaranteed to give the correct result as $R<10^{6}$).

#+name: my solution 762
#+begin_src python
import math
import random

def count_prime_set_bits(L, R):
    def is_prime(n, k):
        if n == 2 or n == 3:
            return True
        if n % 2 == 0:
            return False
        
        temp = n - 1
        r = 0
        while temp % 2 == 0:
            r += 1
            temp = temp // 2
            d = temp // (2**r)


        for _ in range(k):
            a = random.randint(2, n - 2)
            x = a ** d % n
            if x == 1 or x == n - 1:
                continue
            for i in range(r - 1):
                x = x**2 % n
                if x == n - 1:
                    break
            return False
        return True
    
            
    ans = 0
    for num in range(L, R + 1):
        count = sum([int(i) for i in format(num, 'b')])
        if is_prime(count, 100):
            ans += 1
    return ans
return count_prime_set_bits(17, 30)
#+end_src

#+RESULTS: my solution 762
: 10

#+name: miller-rabin test
#+begin_src python
def count_prime_set_bits(L, R):
    import random

    def power(x, y, p):
        res = 1

        x = x % p
        while (y>0):
            if (y&1):
                res = (res*x)%p

            y = y>>1
            x = (x*x)%p
        return res

    def miller_test(d, n):
        a = 2 + random.randint(1, n-4)
        x = power(a, d, n)
        if (x == 1) or (x == n - 1):
            return True
        while (d != n-1):
            x = (x*x)%n
            d *= 2

            if x==1:
                return False
            if x == n-1:
                return True
        return False
    def is_prime(n, k):
        if n<=1 or n ==4:
            return False
        if n<=3:
            return True
        d = n - 1
        while d%2==0:
            d //= 2
        for _ in range(k):
            if not miller_test(d, n):
                return False
        return True

    ans = 0
    for i in range(L, R+1):
        test = sum([int(j) for j in format(i, 'b')])
        if is_prime(test, 100):
            ans += 1
    return ans
return count_prime_set_bits(842, 888)        
#+end_src

#+RESULTS: miller-rabin test
: 23

**** DONE 1103 Distribute candies to people
***** Basic info
:LOGBOOK:
CLOCK: [2019-10-02 Wed 19:06]--[2019-10-02 Wed 19:12] =>  0:06
:END:
We distribute some number of $candies$, to a row of $n = num\_people$ people in the following way:
We give 1 candy to the first person, 2 candies to the second person, and so on until we give $n$ candies to the last person.
Then we go back to the start of the row, giving $n+1$ candies to the first person, $n+2$ candies to the second person, and so on 
until we give $2*n$ candies to the last person.
This process repeats until we run out of candies. the last person will receive all of our remaining candies (not necessarily one more than the previous gift)

Return an array (of length $num_people$ and sum $candies$) that represents the final distribution of candies.
$1\leq candies\leq 10^{9}$
$1\leq num\_people\leq 10^{3}$

Example:
#+begin_example
Input: candies = 7, num_people = 4
Output: [1,2,3,1]
Explanation:
On the first turn, ans[0] += 1, and the array is [1,0,0,0].
On the second turn, ans[1] += 2, and the array is [1,2,0,0].
On the third turn, ans[2] += 3, and the array is [1,2,3,0].
On the fourth turn, ans[3] += 1 (because there is only one candy left), and the final array is [1,2,3,1].
#+end_example


***** Tackling process
:LOGBOOK:
CLOCK: [2019-10-02 Wed 19:12]--[2019-10-02 Wed 19:27] =>  0:15
:END:
We need to keep track of the $total$, total number of candies, $distributed$, number of candies that have been given out, and $next_needed$, the number of candies needed for the next person.
Loop while $total-distributed\geq next\_needed$.

#+name: my solution 1103
#+begin_src python
from typing import List

def distribute_candies(candies, num_people) -> List[int]:
    next_needed = 1
    distributed = 0

    ans = [0] * num_people
    while candies - distributed >= next_needed:
        ans[(next_needed - 1) % num_people] += next_needed
        distributed += next_needed
        next_needed += 1
        ans[(next_needed - 1) % num_people] += candies - distributed
    return ans

return distribute_candies(10, 3)
#+end_src

#+RESULTS: my solution 1103
| 5 | 2 | 3 |

**** DONE 412 Fizz buzz
***** Basic info
:LOGBOOK:
CLOCK: [2019-10-02 Wed 19:37]--[2019-10-02 Wed 19:39] =>  0:02
:END:
Write a program that outputs the string representation of numbers from 1 to $n$.
For multiples of three it should output "Fizz" and for the multiples of five output "Buzz".
For numbers which are multiples of both three and five output "FizzBuzz".
***** Tackling process
:LOGBOOK:
CLOCK: [2019-10-02 Wed 19:39]--[2019-10-02 Wed 19:47] =>  0:08
:END:
Basically it's asking us how to determine if and how a number is divisible by 3 and by 5.
For divisibility by 3, just add up the digits of the number and check if the sum is divisible by 3.
For divisibility by 5, just check if the last digit is 5 or 0.

#+name: my solution 412
#+begin_src python
from typing import List

def fizz_buzz(n:int) -> List[str]:
    def divisible_by_3(num):
        new_num = num
        while len(str(new_num)) > 1:
            new_num = sum([int(digit) for digit in str(new_num)])
        return new_num % 3 == 0
    
    ans = []
    for i in range(1, n + 1):
        word = ""
        if divisible_by_3(i):
            word += "Fizz"
        if str(i)[-1] in ["5", "0"]:
            word += "Buzz"
        if word:
            ans.append(word)
        else:
            ans.append(str(i))

    return ans
return fizz_buzz(15)
#+end_src

#+RESULTS: my solution 412
| 1 | 2 | Fizz | 4 | Buzz | Fizz | 7 | 8 | Fizz | Buzz | 11 | Fizz | 13 | 14 | FizzBuzz |

**** DONE 575 Distribute candies
***** Basic info
:LOGBOOK:
CLOCK: [2019-10-02 Wed 19:52]--[2019-10-02 Wed 19:56] =>  0:04
:END:
Given an integer array with *even* length, where different numbers in this array represent different *kinds* of candies.
Each number means one candy of the corresponding kind. You need to distribute these candies *equally* in number to brother and sister.
Return the maximum number of *kinds* of candies the sister could gain.

Examples:
#+begin_example
Input: candies = [1,1,2,2,3,3]
Output: 3
Explanation:
There are three different kinds of candies (1, 2 and 3), and two candies for each kind.
Optimal distribution: The sister has candies [1,2,3] and the brother has candies [1,2,3], too. 
The sister has three different kinds of candies. 
#+end_example

#+begin_example
Input: candies = [1,1,2,3]
Output: 2
Explanation: For example, the sister has candies [2,3] and the brother has candies [1,1]. 
The sister has two different kinds of candies, the brother has only one kind of candies. 
#+end_example

***** Tackling process
:LOGBOOK:
CLOCK: [2019-10-02 Wed 19:56]--[2019-10-02 Wed 20:02] =>  0:06
:END:

We can use $set()$ to get the *number of kinds* of candies, $num_kinds$.
If $num_kinds \leq array\_len/2$, then the sister could get $num_kinds$ different kinds of candies.
Else, she could get $array\_len/2$ different kinds of candies.

#+name: my solution 575
#+begin_src python
from typing import List

def distribute_candies(candies: List[int]) -> int:
    num_kinds = len(set(candies))
    if num_kinds <= len(candies)//2:
        return num_kinds
    return len(candies)//2
return distribute_candies([1,1,2,3])
#+end_src

#+RESULTS: my solution 575
: 2

***** Thoughts
Quite straightforward.
**** DONE 868 Binary gap
***** Basic info
:LOGBOOK:
CLOCK: [2019-10-02 Wed 20:27]--[2019-10-02 Wed 20:30] =>  0:03
:END:
Given a positive integer $N$, find and return the longest distance between two consecutive 1's in the binary representation of $N$.
If there arn't two consecutive 1's, return 0.
$1\leq N\leq 10^{9}$.

Example:
#+begin_example
Input: 22
Output: 2
Explanation: 
22 in binary is 0b10110.
In the binary representation of 22, there are three ones, and two consecutive pairs of 1's.
The first consecutive pair of 1's have distance 2.
The second consecutive pair of 1's have distance 1.
The answer is the largest of these two distances, which is 2.
#+end_example

***** Tackling process
:LOGBOOK:
CLOCK: [2019-10-02 Wed 20:30]--[2019-10-02 Wed 20:46] =>  0:16
:END:
This question basically asks us to count the *longest continuous sequence of 0's*.
We need a $max_dist$ to store the maximum distance.
A $cur_dist$ to count the current distance, and this $cur_dist$ should be reset to 0 when the number at the loop index transits from 1 to 0, and then transits to 0 when it hits 1.
Finally we need to compare $cur_dist$ with $max_dist$, when we hit a new 1.

#+name: my solution 868
#+begin_src python
from typing import List

def binary_gap(N:int) -> int:
    bin_rep = bin(N)[2:]

    max_dist = 0
    cur_dist = 0
    only_one_one = 2 # edge case when the binary only has one 1.
    for i in bin_rep:
        if i == "1":
            only_one_one -= 1
            if cur_dist > max_dist:
                max_dist = cur_dist
                cur_dist = 0
        else:
            cur_dist += 1
    if only_one_one <= 0:
        max_dist += 1
    return max_dist
return binary_gap(8)
#+end_src

#+RESULTS: my solution 868
: 0

#+begin_src python
return bin(12)
#+end_src

#+RESULTS:
: 0b1100

***** Thoughts
Time complexity is $O(logN)$, where $logN$ is the number of digits in the binary representation of $N$.
**** DONE 637 Average of levels in binary tree            :tree:recursive:
***** Basic info
:LOGBOOK:
CLOCK: [2019-10-02 Wed 20:56]--[2019-10-02 Wed 20:58] =>  0:02
:END:
Given a non-empty binary tree, return the average value of the nodes on each level in the form of an array.
The range of node's value is in the range of 32-bit signed integer.

Example:

#+begin_example
Input:
    3
   / \
  9  20
    /  \
   15   7
Output: [3, 14.5, 11]
Explanation:
The average value of nodes on level 0 is 3,  on level 1 is 14.5, and on level 2 is 11. Hence return [3, 14.5, 11].
#+end_example

***** Tackling process
:LOGBOOK:
CLOCK: [2019-10-02 Wed 20:58]--[2019-10-02 Wed 21:14] =>  0:16
:END:
We need a hash map that stores level depth and values on that level.
Recursively walk down the tree to fill up the hash map.

#+name: my solution 637
#+begin_src python# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
def average_of_levels(root):
    # root is non-empty
    def rec(node, level, hash_map: dict):
        if node:
            if hash_map.get(level, None) is None:
                hash_map[level] = []
            hash_map[level].append(node.val)
            hash_map = rec(node.left, level + 1, hash_map)
            hash_map = rec(node.right, level + 1, hash_map)

        return hash_map
        
    hash_map = {}
    hash_map = rec(root, 1, hash_map)
    ans = [sum(v)/len(v) for v in hash_map.values()]
    return ans
#+end_src

***** Thoughts
:LOGBOOK:
CLOCK: [2019-10-02 Wed 21:14]--[2019-10-02 Wed 21:22] =>  0:08
:END:
Time complexity $O(N)$, where $N$ is the number of nodes.
Space complexity $O(N)$, where $N$ is the number of nodes.

[[https://leetcode.com/problems/average-of-levels-in-binary-tree/solution/][Leetcode solution]]
Approach #1 Using Depth First Search [Accepted]
Algorithm

One of the methods to solve the given problem is to make use of Depth First Search. In DFS, we try to exhaust each branch of the given tree during the tree traversal before moving onto the next branch.

To make use of DFS to solve the given problem, we make use of two lists countcount and resres. Here, count[i]count[i] refers to the total number of nodes found at the i^{th}i 
th
level(counting from root at level 0) till now, and res[i]res[i] refers to the sum of the nodes at the i^{th}i 
th
level encountered till now during the Depth First Search.

We make use of a function average(t, i, res, count), which is used to fill the resres and countcount array if we start the DFS from the node tt at the i^{th}i 
th
level in the given tree. We start by making the function call average(root, 0, res, count). After this, we do the following at every step:

Add the value of the current node to the resres(or sumsum) at the index corresponding to the current level. Also, increment the countcount at the index corresponding to the current level.

Call the same function, average, with the left and the right child of the current node. Also, update the current level used in making the function call.

Repeat the above steps till all the nodes in the given tree have been considered once.

Populate the averages in the resultant array to be returned.
#+name: leetcode java solution
#+begin_src java
/**
 ,* Definition for a binary tree node.
 ,* public class TreeNode {
 ,*     int val;
 ,*     TreeNode left;
 ,*     TreeNode right;
 ,*     TreeNode(int x) { val = x; }
 ,* }
 ,*/
public class Solution {
    public List < Double > averageOfLevels(TreeNode root) {
        List < Integer > count = new ArrayList < > ();
        List < Double > res = new ArrayList < > ();
        average(root, 0, res, count);
        for (int i = 0; i < res.size(); i++)
            res.set(i, res.get(i) / count.get(i));
        return res;
    }
    public void average(TreeNode t, int i, List < Double > sum, List < Integer > count) {
        if (t == null)
            return;
        if (i < sum.size()) {
            sum.set(i, sum.get(i) + t.val);
            count.set(i, count.get(i) + 1);
        } else {
            sum.add(1.0 * t.val);
            count.add(1);
        }
        average(t.left, i + 1, sum, count);
        average(t.right, i + 1, sum, count);
    }
}

#+end_src

**** DONE 226 Invert binary tree                                    :tree:
***** Basic info
:LOGBOOK:
CLOCK: [2019-10-03 Thu 08:34]--[2019-10-03 Thu 08:37] =>  0:03
:END:
Invert a binary tree.
(swap node.left and node.right)

Example:

#+begin_example
     4
   /   \
  2     7
 / \   / \
1   3 6   9

to

     4
   /   \
  7     2
 / \   / \
9   6 3   1
#+end_example


Trivia:
Google to Max Howell: Google: 90% of our engineers use the software you wrote (Homebrew), but you can't invert a binary tree on a whiteboard so f*** off.
***** Tackling process
:LOGBOOK:
CLOCK: [2019-10-03 Thu 08:40]--[2019-10-03 Thu 08:43] =>  0:03
:END:
Basically we want to recursively invert/swap the children of every node.
We stop when the node is None.

#+name: my solution 226
#+begin_src python
def invert_binary_tree(root):
    if root is None:
        return root
    left = root.left
    root.left = invert_binary_tree(root.right)
    root.right = invert_binary_tree(left)
    return root
#+end_src
***** Thoughts
I'm getting better at writing the recursive solution.
**** DONE 566 Reshape the matrix                                  :matrix:
***** Basic info
:LOGBOOK:
CLOCK: [2019-10-03 Thu 08:48]--[2019-10-03 Thu 08:53] =>  0:05
:END:
Given a matrix represented by a two-dimensional array, and two *positive* integers $r$ and $c$ representing the *row* number and *column* number
of the wanted reshaped matrix, respectively.
The reshaped matrix needs to be filled with all the elements of the orginal matrix in the same *row-traversing* order as they were.
If the 'reshape' operation with given parameters is possible and legal, output the new reshaped matrix; otherwise, output the original matrix.

The height and width of the given matrix is in range [1, 100]
The given $r$ and $c$ are all positive.
****** Examples

#+name: example 1
#+begin_example
Input: 
nums = 
[[1,2],
 [3,4]]
r = 1, c = 4
Output: 
[[1,2,3,4]]
Explanation:
The row-traversing of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list.
#+end_example

#+name: example 2
#+begin_example
Input: 
nums = 
[[1,2],
 [3,4]]
r = 2, c = 4
Output: 
[[1,2],
 [3,4]]
Explanation:
There is no way to reshape a 2 * 2 matrix to a 2 * 4 matrix. So output the original matrix.
#+end_example
***** Tackling process
:LOGBOOK:
CLOCK: [2019-10-03 Thu 08:53]--[2019-10-03 Thu 09:09] =>  0:16
:END:
In order to reshape a matrix, $r\times c == r_{o}\times c_{o}$, where $r_{o}$ and $c_{o}$ is the original number of rows and number of columns.

#+name: my solution 566
#+begin_src python
from typing import List

def matrix_reshape(nums: List[List[int]], r: int, c: int) -> List[List[int]]:
    ro = len(nums)
    co = len(nums[0])

    if ro*co != r*c:
        return nums
    else:
        ans = [[] for _ in range(r)]
        row_idx = 0
        col_idx = 0
        elements = []
        for row in nums:
            elements.extend(row)
        for i in elements:
            if col_idx == c:
                row_idx += 1
                col_idx = 0
                ans[row_idx].append(i)
                col_idx += 1
        return ans
return matrix_reshape([[1,2],[3,4]], 1,4)
#+end_src

#+RESULTS: my solution 566
| 1 | 2 | 3 | 4 |

***** Thoughts
:LOGBOOK:
CLOCK: [2019-10-03 Thu 10:33]--[2019-10-03 Thu 10:51] =>  0:18
:END:
****** Leetcode solutions
******* Approach 1 Using queue
This is basically what I had at [[my solution 566]].
******** Algorithm
The simplest method is to extract all the elements of the given matrix by reading the elements in a row-wise fashion.
In this implementation, we use a queue to put the extracted elements. Then we can take out the elements of the queue formed in a serial order and arrange the elements in the 
resultant required matrix in a row-by-row fashion again.

The formation of the resultant matrix won't be possible if the number of elements in the original matrix isn't equal to the number of elements in the resultant matrix.
******** Complexity
Time, space complexity: $O(m\times n)$.
******* Approach 3 using division and modulus, without extra space
******** Algorithm
In Approach 2, we needed to keep track of when we reached the end of columns for the resultant matrix and needed to update the current row and column numbers for putting the extracted elements by checking the current indices every time.
Instead of doing these limit checks at every step, we can use maths to help ease the situation.

The idea is as follows: Do you know how a 2-D array is stored in the main memory? It is internally represented as a 1-D array. The elements $nums[i][j]$ of $nums$ array is represented in the form of a one dimensional array by using the index in the form: $nums[n\times i+j]$, where $m$ is the number of columns in the given matrix. Looking at the same in the reverse order, while putting the elements in the resultant matrix, we can make use of a $count$ variable which gets incremented for every element traversed as if we are putting the elements in a 1-D resultant array. But, to convert the $count$ back into 2-D matrix indices with a column count of $c$, we can obtain the indices as $res[count//c][count%c]$ where $count//c$ is the row number and $count%c$ is the column number. Thus we can save the extra checking required at each step.

#+name: approach 3 code
#+begin_src python
def matrix_reshape(nums, r, c):
    res = [[None]*c for _ in range(r)]
    if len(nums) == 0 or r*c != len(nums) * len(nums[0]):
        return nums
    count = 0
    for i in range(len(nums)):
        for j in range(len(nums[0])):
            res[count // c][count % c] = nums[i][j]
            count += 1
    return res
#+end_src
******** Complexity
Time, space complexity: $O(m\times n)$.
**** DONE [#A] 784 Letter case permutation    :recursive:tree:binary_tree:
***** Basic info
:LOGBOOK:
CLOCK: [2019-10-03 Thu 10:53]--[2019-10-03 Thu 10:56] =>  0:03
:END:
Given a string $S$, we can transform every letter individually to be lowercase or uppercase to create another string. Return a list of all possible strings we could create.
$S$ will be a string with length between 1 and 12, consisting only of letters and digits.
****** Examples:
#+name: 784 Example
#+begin_example
Examples:
Input: S = "a1b2"
Output: ["a1b2", "a1B2", "A1b2", "A1B2"]

Input: S = "3z4"
Output: ["3z4", "3Z4"]

Input: S = "12345"
Output: ["12345"]
#+end_example
***** Tackling process
:LOGBOOK:
CLOCK: [2019-10-03 Thu 19:00]--[2019-10-03 Thu 19:19] =>  0:19
CLOCK: [2019-10-03 Thu 12:30]--[2019-10-03 Thu 12:32] =>  0:02
CLOCK: [2019-10-03 Thu 11:04]--[2019-10-03 Thu 11:20] =>  0:16
:END:
This has to be done recursively, otherwise it's quite hard to mentally think of it.
By looping through the string, we can construct a binary tree and later traverse it to construct the list we want.

#+name: my solution 784
#+begin_src python
from typing import List

def letter_case_permutation(S: str) -> List[str]:
    alphabet = [i for i in range(ord('a'), ord('Z')+1)]
    class Node:
        def __init__(self, val):
            self.val = val
            self.left = None
            self.right = None
    def append_node(node, c):
        if ord(c) in alphabet:
            node.left = Node(c.lower())
            node.right = Node(c.upper())
        else:
            node.left = Node(c)
        return node

    def construct_tree(root,S):
        node = root
        for c in S:
            node.left = append_node(node.left, c)
            node.right = append_node(node.right, c)
#+end_src
#+name: leetcode solution 784
#+begin_src python
def letter_case_permutation(S):
    def dfs(path, i):
        if i >= len(S):
            opt.append(path)
            return
        if S[i] not in num_char:
            dfs(path+S[i].upper(), i+1)
            dfs(path+S[i].lower(), i+1)
        else:
            dfs(path+S[i], i+1)
            num_char = [str(i) for i in range(10)]
            opt = []
            dfs('', 0)
    return opt
return letter_case_permutation("a2b3")
#+end_src

#+RESULTS: leetcode solution 784
| A2B3 | A2b3 | a2B3 | a2b3 |

***** Thoughts
:LOGBOOK:
CLOCK: [2019-10-03 Thu 19:19]--[2019-10-03 Thu 19:21] =>  0:02
:END:
It's a question that's easy to know what to use to solve it (recursion) but hard to implement because it's hard to find a base case and the recursion part.

**** DONE 1089 Duplicate zeros
***** Basic info
:LOGBOOK:
CLOCK: [2019-10-03 Thu 19:22]--[2019-10-03 Thu 19:23] =>  0:01
:END:
Given a fixed length array $arr$ of integers, duplicate each occurrence of zero, shifting the remaining elements to the right.
Note that elements beyond the length of the original array are not written.
Do the above modifications to the input array *in place*, do not return anything from your function.

****** Examples:
#+begin_example
Input: [1,0,2,3,0,4,5,0]
Output: null
Explanation: After calling your function, the input array is modified to: [1,0,0,2,3,0,0,4]
#+end_example
***** Tackling process
:LOGBOOK:
CLOCK: [2019-10-03 Thu 19:33]--[2019-10-03 Thu 19:41] =>  0:08
CLOCK: [2019-10-03 Thu 19:23]--[2019-10-03 Thu 19:24] =>  0:01
:END:
We can have a loop and a position counter from left to right to do the checking and shifting.
#+begin_src python
def duplicate_zeros(arr) -> None:
    idx = 0

    while idx < len(arr):
        if arr[idx] == 0:
            for j in range(len(arr)-1, idx + 1, -1):
                arr[j] = arr[j-1]
                # edge case when the last element becomes 0
            if idx != len(arr) - 1:
                arr[idx+1] = arr[idx]
                idx += 2
        else:
            idx += 1
    return arr
return duplicate_zeros([0,0,0,0,0,0,0])
#+end_src

#+RESULTS:
| 0 | 0 | 0 | 0 | 0 | 0 | 0 |

***** Thoughts
:LOGBOOK:
CLOCK: [2019-10-03 Thu 19:45]--[2019-10-03 Thu 19:47] =>  0:02
CLOCK: [2019-10-03 Thu 19:41]--[2019-10-03 Thu 19:42] =>  0:01
:END:
1. We need to always make sure that there is an *explicit exit for a while loop*.
2. We need to consider edge cases.
A great solution on Leetcode:
#+name: 1089 leetcode discussion solution
#+begin_src python
def duplicate_zeros(arr):
    i = 0

    while i <len(arr):
        if arr[i] == 0:
            arr.insert(i + 1, 0)
            arr.pop()
            i += 2
        else:
            i += 1
#+end_src

**** DONE 824 Goat latin
***** Basic info
:LOGBOOK:
CLOCK: [2019-10-04 Fri 20:48]--[2019-10-04 Fri 20:51] =>  0:03
:END:
A sentence $S$ is given, composed of words separated by spaces. Each word consists of lowercase and uppercase letters only.
We'd like to convert the sentence to "Goat Latin" that follows the rules:
1. If a word begins with a vowel (a,e,i,o,u), append "ma" to the end of the word.
2. If a word begins with a consonant, remove the first letter and append it to the end, then add "ma". For example, "goat" to "oatgma".
3. Add one letter "a" to the end of each word per its word index in the sentence, starting with 1. For example, the first word gets "a" added to the end, the second gets "aa" and so on.

****** Examples:
#+name: 824 Goat latin example
#+begin_example
Input: "The quick brown fox jumped over the lazy dog"
Output: "heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa"
#+end_example

***** Tackling process

****** Algorithm
We should be able to achieve $O(N)$ time complexity where $N$ is the length of the sentence.
| position | 1 |    2 |      3 |         4 |    5 |
| word     | I | like | eating | delicious | food |

We can loop through the characters and use space to determine the word position.
****** Code
:LOGBOOK:
CLOCK: [2019-10-04 Fri 21:04]--[2019-10-04 Fri 21:26] =>  0:22
:END:
#+name: 824 Goat latin my solution
#+begin_src python
def to_goat_latin(S: str) -> str:

    vowels = ["a", "e", "i", "o", "u", "A", "E", "I", "O", "U"]
    pos = 1
    tail = "ma"

    ans = ""
    temp_word = ""
    for char in S:
        if char != " ":
            if len(temp_word) + len(tail) == 2:
                if char not in vowels:
                    tail = char + tail
                else:
                    temp_word += char
                    
            else:
                temp_word += char
                
        else:
            for i in range(pos):
                tail += "a"
                temp_word += tail
                temp_word += char
                ans += temp_word

            temp_word = ""
            tail = "ma"
            pos += 1
    for i in range(pos):
        tail += "a"
        temp_word += tail
        ans += temp_word
    return ans
return to_goat_latin("I speak Goat")
#+end_src

#+RESULTS: 824 Goat latin my solution
: Imaa peaksmaaa oatGmaaaa

****** Complexity
Time complexity:
$O(N^{2})$ because there is a nested loop
Space complexity: 
$O(N)$ because the space to store "a" increases along side the position change

***** Thoughts
#+name: 824 Goat latin leetcode solution
#+begin_src python
class Solution(object):
    def toGoatLatin(self, S):

        def convert(word):
            if word[0] not in 'aeiouAEIOU':
                word = word[1:] + word[:1]
            return word + 'ma'

        return " ".join(convert(word) + 'a' * i
                        for i, word in enumerate(S.split(), 1))

#+end_src

Time Complexity: O(N) With only one loop, we can add one more 'a' each time, so we don't need to make another loop for add character 'a'.
****** Complexity
Time complexity:
$O(N^{2})$
Space complexity: 
$O(N^{2})$

**** DONE 1137 N-th Tribonacci Number                          :recursive:
***** Basic info
The Tribonacci sequence $T_{n}$ is defined as follows:
T0 = 0, T1 = 1, T2 = 1 and $T_{n+3} = T_{n} + T_{n+1} + T_{n+2}$
Given n, return the value of $T_{n}$.

****** Examples:
#+name: 1137 N-th Tribonacci Number example
#+begin_example
Input: n = 4
Output: 4
Explanation:
T_3 = 0 + 1 + 1 = 2
T_4 = 1 + 1 + 2 = 4
#+end_example

***** Tackling process

****** Algorithm
:LOGBOOK:
CLOCK: [2019-10-04 Fri 21:31]--[2019-10-04 Fri 21:32] =>  0:01
:END:
This is a classic recursive problem (see Fibonacci number).
We only need to find the base cases.

****** Code
:LOGBOOK:
CLOCK: [2019-10-04 Fri 21:32]--[2019-10-04 Fri 21:35] =>  0:03
:END:
#+name: 1137 N-th Tribonacci Number my solution
#+begin_src python
def tribonacci(n):
    if n == 0:
        return 0
    if n == 1 or n == 2:
        return 1
    return tribonacci(n-1) + tribonacci(n-2) + tribonacci(n-3)
return tribonacci(25)
#+end_src

#+RESULTS: 1137 N-th Tribonacci Number my solution
: 1389537

#+name: 1137 N-th Tribonacci Number my solution faster with pre-calculated answers
#+begin_src python
def tribonacci(n):
    answers = [0, 1, 1]
    if n < 2:
        return answers[n]
    for i in range(2, n):
        answers.append(answers[-1] + answers[-2] + answers[-3])
    return answers[-1]
return tribonacci(25)
#+end_src

#+RESULTS: 1137 N-th Tribonacci Number my solution faster with pre-calculated answers
: 1389537

****** Complexity
Time complexity:

Space complexity: 

***** Thoughts
:LOGBOOK:
CLOCK: [2019-10-04 Fri 21:44]--[2019-10-04 Fri 21:45] =>  0:01
:END:
We store precalculated answers to accelerate the calculation.
ansers = [0, 1, 1, 2, 4, 7, 13...].

**** DONE 69 3 Binary number with alternating bits
***** Basic info
Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will always have different values.

****** Examples:
#+name: 693 Binary number with alternating bits example
#+begin_example
Input: 5
Output: True
Explanation:
The binary representation of 5 is: 101
#+end_example

#+name: 693 Binary number with alternating bits example 2
#+begin_example
Input: 11
Output: False
Explanation:
The binary representation of 11 is: 1011.
#+end_example
***** Tackling process

****** Algorithm
We first convert the integer to its binary representation, then we can use a ~prev~ to store the previous valua and compare it with the current value while we loop through the binary bits.
****** Code
:LOGBOOK:
CLOCK: [2019-10-05 Sat 10:24]--[2019-10-05 Sat 10:25] =>  0:01
:END:
#+name: 693 Binary number with alternating bits my solution
#+begin_src python
def has_alternating_bits(n) -> bool:
    bin_rep = bin(n)[2:]
    prev = "-1"
    for i in bin_rep:
        if prev == i:
            return False
        else:
            prev = i
    return True
return has_alternating_bits(7)
#+end_src

#+RESULTS: 693 Binary number with alternating bits my solution
: False

****** Complexity
Time complexity:
$O(N)$, where $N$ is the number of bits of the number, which in this case is less than or equal to 32.
Space complexity: 
$O(1)$

***** Thoughts
:LOGBOOK:
CLOCK: [2019-10-05 Sat 10:29]--[2019-10-05 Sat 10:33] =>  0:04
:END:

We can get the last bit and the rest of the bits via $n%2$ and $n//2% operations (also we can do $n&1$ and $n >>=1$ instead).
Let's remember ~cur~, the last bit of $n$. If ~cur~ ever equals the last bit of the reamining, then two adjacent bits have the same value, and the answer is ~False~. Otherwise, the answer is ~True~.
#+name: 693 Binary number with alternating bits leetcode solution
#+begin_src python
def has_alternating_bits(n):
    n, cur = divmod(n,2)
    while n:
        if cur == n%2: return False
        n, cur = divmod(n, 2)
    return True
#+end_src
Time complexity:
$O(N)$, where $N$ is the number of bits of the number, which in this case is less than or equal to 32.
Space complexity: 
$O(1)$
**** DONE 206 Reverse linked list                  :linked_list:recursive:
***** Basic info
:LOGBOOK:
CLOCK: [2019-10-05 Sat 10:41]--[2019-10-05 Sat 10:41] =>  0:00
:END:
Reverse a singly linked list.
A linked list can be reversed either iteratively or recursively. Could you implement both?
****** Examples:
#+name: 206 Reverse linked list example
#+begin_example
Input: 1->2->3->4->5->NULL
Output: 5->4->3->2->1->NULL
#+end_example

***** Tackling process
:LOGBOOK:
CLOCK: [2019-10-05 Sat 10:41]--[2019-10-05 Sat 11:02] =>  0:21
:END:

****** Algorithm
Iteratively, we can store the nodes in a list and then start the linked list from the right.
****** Code
#+name: 206 Reverse linked list my solution recursive
#+begin_src python
def reverse_list(head):
    def rec(prev, node):
        if node:
            next_node = node.next
            node.next = prev
            return rec(node, next_node) # we have to return here, so that the last prev is returned to the outer scope
        return prev
    return rec(None, head)
#+end_src

#+name: 206 Reverse linked list my solution iterative
#+begin_src python
def reverse_list(head):
    node = head
    prev = None
    while node:
        next_node = node.next
        node.next = prev
        prev = node
        node = next_node
    return prev
#+end_src
****** Complexity
Time complexity:
$O(N)

Space complexity: 
$O(N)$ for recursive (we need a stack to store the recursion)
$O(1)$ for iterative

***** Thoughts
:LOGBOOK:
CLOCK: [2019-10-05 Sat 11:02]--[2019-10-05 Sat 11:18] =>  0:16
:END:
In the following code, if we do not have the ~return rec(node, next_node)~, then when we finally ~return prev~, it will be lost because it's only returned to its *direct* outer scope, but not subsequently to its *grand-direct* outer scope.
#+caption: Scope diagram
#+name: fig:scope_diagram_linked_list
[[file:leetcode_imgs/206_reverse_linked_list.png]]
#+begin_src python
    def rec(prev, node):
        if node:
            next_node = node.next
            node.next = prev
            return rec(node, next_node) # we have to return here, so that the last prev is returned to the outer scope
        return prev
#+end_src

**** DONE 976 Largest perimeter triangle
***** Basic info
Given an array ~A~ of positive lengths, return the largest perimeter of a triangle with *non-zero* area, formed from 3 of these lengths.
If it is impossible to form any triangle of non-zero area, return 0.

$3\leq A.length \leq 10000$ and $1\leq A[i] \leq 10^{6}$.
****** Examples:
:LOGBOOK:
CLOCK: [2019-10-07 Mon 20:23]--[2019-10-07 Mon 20:25] =>  0:02
:END:
#+name: 976 Largest perimeter triangle example
#+begin_example
Input: [2,1,2]
Output: 5

Input: [1,2,1]
Output: 0

Input: [3,2,3,4]
Output: 10
#+end_example

***** Tackling process
:LOGBOOK:
CLOCK: [2019-10-07 Mon 20:25]--[2019-10-07 Mon 20:44] =>  0:19
:END:

****** Algorithm
To form a triangle, the sum of any two sides must be greater than the third side: $a+b>c$.
We only need to first sort the array, then pick the largest three numbers that would meet $a+b>c$.
****** Code
#+name: 976 Largest perimeter triangle my solution
#+begin_src python
def largest_perimeter(A) -> int:
    def makes_triangle(a, b, c):
        if a + b <= c or a + c <= b or b + c <= a:
            return False
        return True

    sorted_A = sorted(A, reverse=True)
    
    i = 0
    while i <= len(sorted_A)-3:
        a = sorted_A[i]
        b = sorted_A[i+1]
        c = sorted_A[i+2]
        if makes_triangle(a, b, c):
            return a + b + c
        i += 1
    return 0

return largest_perimeter([2,1,2])
#+end_src

#+RESULTS: 976 Largest perimeter triangle my solution
: 5

When len(A) == 3, the following for loop would fail because the loop never gets executed.
#+begin_src python
A = [2,1,2]
for i in range(len(A)-3, 0):
    return i
#+end_src

#+RESULTS:
: None

****** Complexity
Time complexity:
$O(NlogN)$
Space complexity: 
$O(1)$
***** Thoughts
:LOGBOOK:
CLOCK: [2019-10-07 Mon 20:46]--[2019-10-07 Mon 20:50] =>  0:04
:END:
A copy of the leetcode explanation:

#+begin_quote
Without loss of generality, say the sidelengths of the triangle are $a\leq b\leq c$. The necessary and sufficient condition for these lengths to form a triangle of non-zero area is $a+b>c$.

Say we know $C$ already. There is *no reason not to choose the largest possible $a$ and $b$ from the array*.
#+end_quote

The time complexity of sorting the array is $O(NlogN)$ and the time complexity to check the sorted array is $O(N)$, thus overall $O(NlogN)$.
**** DONE [#A] 349 Intersection of two arrays                 :follow_ups:
***** Basic info
Given two arrays, write a function to compute their intersection.

Each element in the result must be unique. The result can be in any order.
****** Examples:
#+name: 349 Intersection of two arrays example
#+begin_example
Input: nums1 = [1,2,2,1], nums2 = [2,2]
Output: [2]

Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
Output: [9,4]
#+end_example

***** Tackling process
:LOGBOOK:
CLOCK: [2019-10-07 Mon 20:53]--[2019-10-07 Mon 21:02] =>  0:09
:END:

****** Algorithm
We can use Python's ~set()~ to calculate the intersection.

****** Code
#+name: 349 Intersection of two arrays my solution
#+begin_src python
from typing import List

def intersection(nums1, nums2) -> List[int]:
    n1 = set(nums1)
    n2 = set(nums2)

    return list(n1.intersection(n2))
return intersection([4,9,5], [9,4,9,8,4]) 
#+end_src

#+RESULTS: 349 Intersection of two arrays my solution
| 9 | 4 |

****** Complexity
Time complexity:
$O(n+m)$, average.
$O(n\times m)$, worst case when [[https://cs.nyu.edu/courses/fall17/CSCI-UA.0102-001/Notes/HashTableImplementation.html][load factor]] is high enough.

(load factor: the number of keys stored in the hash table divided by the capacity)
Space complexity: 
$O(n+m)$, the worst case when all elements in the arrays are different.

***** Thoughts
Copy from leetcode comments:

#+begin_quote
This is a Facebook intervie question.
They ask for the intersection, which has a trivial solution using a hash or a set.

Then they ask you to solve it under these constraints:
$O(n) time and O(1) space (the resulting array of intersections is not taken into consideration).
You are told the lists are sorted.

Cases to take into consideration include:
duplicates, negative values, single value lists, 0's, and empty list arguments.

Other considerations might include sparse arrays.
#+end_quote

#+name: python O(1) space
#+begin_src python
 def intersection2(nums1: List[int], nums2: List[int]) -> List[int]:
     nums1.sort()
     nums2.sort()

    res = []

    left, right = 0, 0
    while left < len(nums1) and right < len(nums2):
        left_val = nums1[left]
        right_val = nums2[right]

        if right_val == left_val:
            res.append(nums2[right])
            while right < len(nums2) and nums2[right] == right_val:
                right += 1
            while left < len(nums1) and nums1[left] == left_val:
                left += 1
        if right_val > left_val:
            while left < len(nums1) and left_val == nums1[left]:
                left += 1
        else:
            while right < len(nums2) and right_val == nums2[right]:
                right += 1
    return res
#+end_src
**** DONE [#B] 892 Surface area of 3d shapes
***** Basic info
:LOGBOOK:
CLOCK: [2019-10-08 Tue 16:03]--[2019-10-08 Tue 16:04] =>  0:01
CLOCK: [2019-10-08 Tue 16:02]--[2019-10-08 Tue 16:03] =>  0:01
:END:
On a $N*N$ grid, we place some $1*1*1$ cubes.

Each value $v=grid[i][j]$ represents a tower of $v$ cubes placed on the top of grid cell $(i, j)$.

Return the total surface area of the resulting shapes.

****** Examples:
#+name: 892 Surface area of 3d shapes example
#+begin_example
Input: [[2]]
Output: 10

Input: [[1,2],[3,4]]
Output: 34
#+end_example

***** Tackling process
:LOGBOOK:
CLOCK: [2019-10-08 Tue 16:04]--[2019-10-08 Tue 16:18] =>  0:14
:END:
Basically we have the following top view for a $4*4$ grid.

#+name: 4*4 grid [[1,1], [2,2]]
|   | j |   | 
| i | 1 | 1 | 
|   | 2 | 2 | 
#+name: 4*4 grid [[1,0], [0,2]]
|   | j |   | 
| i | 1 | 0 | 
|   | 0 | 2 | 
****** Algorithm
:LOGBOOK:
CLOCK: [2019-10-08 Tue 19:11]--[2019-10-08 Tue 19:27] =>  0:16
:END:
+We calculate the top area first, then 2 * (left area and front area).+
Initially I thought the bottom of the 3d object does not count.
Also we need to consider when a cell does not have any cubes.

****** Code
#+name: 892 Surface area of 3d shapes my solution
#+begin_src python
from typing import List

def surface_area(grid: List[List[int]]) -> int:
    # because the grid is N*N
    # top_area = len(grid) * len(grid)

    def top_area(grid):
        # we need to count non-zero values
        # in this case, the 1 and 2
        # |   | j |   | 
        # | i | 0 | 1 | 
        # |   | 2 | 0 | 
        return len([cell for row in grid for cell in row if cell > 0])

    def front_area(grid):
        # we need the highest values in a column
        # in this case, the (2, 2)
        # |   | j |   | 
        # | i | 1 | 1 | 
        # |   | 2 | 2 | 
        return sum([max(col) for col in zip(*grid)])

    def left_area(grid):
        # we need the highest values in a row
        # in this case, the (1, 2)
        # |   | j |   | 
        # | i | 1 | 1 | 
        # |   | 2 | 2 | 
        return sum([max(row) for row in grid])
    return 2*(top_area(grid) + left_area(grid) + front_area(grid))
return surface_area([[1,1,1], [1,0,1], [1,1,1]])
#+end_src

#+RESULTS: 892 Surface area of 3d shapes my solution
: 28

#+begin_src python
return list(zip(*[[1,2,3],[1,2,3]]))
#+end_src

#+RESULTS:
| 1 | 1 |
| 2 | 2 |
| 3 | 3 |

****** Complexity
Time complexity:

Space complexity: 

***** Thoughts
:LOGBOOK:
CLOCK: [2019-10-08 Tue 19:27]--[2019-10-08 Tue 19:41] =>  0:14
:END:
Ok, I didn't realize that I must count more than projections(top, left, front) of the object.

*Every face on the cube counts* to the total area.

Let $v=grid[r][c]$, when $v>0$, the top and bottom surface contribute an area of 2.

Then, for each side of the column at $grid[r][c]$, the neighboring cell with value $nv$ means our square contrbutes $max(v-nv,0)$.
#+name: 892 Surface area of 3d shapes leetcode solution
#+begin_src python
def surface_area(grid):
    N = len(grid)

    ans = 0
    for r in range(N):
        for c in range(N):
            if grid[r][c]:
                ans += 2

                # the tower at (r,c) has four surrounding sides (east, west, north, south)
                # which all share the same area
                for nr, nc in ((r-1, c), (r+1,c), (r, c-1), (r, c+1)):
                    if 0 <= nr <N and 0 <= nc <N:
                        # get the neighbour value on one side
                        nval = grid[nr][nc]
                    else:
                        nval = 0
                        # only get the difference between two neighbouring sides if it's positive
                    ans += max(grid[r][c] - nval, 0)
    return ans
#+end_src

**** DONE 888 Fair candy swap                                       :math:
***** Basic info
:LOGBOOK:
CLOCK: [2019-10-08 Tue 19:57]--[2019-10-08 Tue 20:05] =>  0:08
:END:
Alice and Bob have candy bars of different sizes: ~A[i]~ is the size of the i-th bar of candy that Alice has, and ~B[j]~is the size of the j-th bar of candy that Bob has.

Since they are friends, they would like to exchange one candy bar each so that after the exchange, they both have the same total amount of candy. /(The total amount of candy a person has is the sum of the sizes of candy bars they have)./

Return an integer array ~ans~, where ~ans[0]~ is the size of the candy bar that Alice must exchange, and ~ans[1]~ is the size of the candy bar that Bob must exchange.

If there are multiple answers, you may return any one of them. It is guaranteed an answer exists.

1 <= A.length <= 10000
1 <= B.length <= 10000
1 <= A[i] <= 100000
1 <= B[i] <= 100000
It is guaranteed that Alice and Bob have different total amounts of candy.
It is guaranteed there exists an answer.

****** Examples:
#+name: 888 Fair candy swap example
#+begin_example
Input: A = [1,1], B = [2,2]
Output: [1,2]

Input: A = [1,2], B = [2,3]
Output: [1,2]

Input: A = [2], B = [1,3]
Output: [2,3]

Input: A = [1,2,5], B = [2,4]
Output: [5,4]
#+end_example

***** Tackling process
:LOGBOOK:
CLOCK: [2019-10-08 Tue 20:06]--[2019-10-08 Tue 20:51] =>  0:45
:END:

****** Algorithm
We want to achieve the following:
$A = [a_1, a_2, ..., a_n]$ and $B = [b_1, b_2, ..., b_n]$, find an $f()$ such that $A', B' = f(A, B), A' = [a_1, a_2, ..., a_{i-1}, b_j, a_{i+1}, ..., a_n], B' = [b_1, b_2, ..., b_{j-1}, a_i, b_{j+1}, ..., b_m]$ and ~sum(A') == sum(B')~.

We can calculate the sum of ~A~ and ~B~, then get the average of the two, ~avg~, and calculate the difference between ~A~ and ~avg~.

+Plus, it seems that we only need to exchange the larget two numbers from ~A~ and ~B~.+

A test case would be ~[1,1,2,3,4] and [1,2,4]~ against the above sentence.
****** Code
#+name: 888 Fair candy swap my solution
#+begin_src python
def fair_candy_swap(A, B):
    def find_ans(outer, inner):
        for i in outer:
            for j in inner:
                if i - j == diff:
                    return [i, j]
                
    sum_A = sum(A)
    sum_B = sum(B)
    avg = (sum_A + sum_B) // 2

    outer = set(A if sum_A > sum_B else B)
    inner = set(B if sum_A > sum_B else A)

    diff = abs(sum_A - avg)

    ans = []

    i, j = find_ans(outer, inner)
    if sum_A > sum_B:
        return [i, j]
    else:
        return [j, i]
return fair_candy_swap([20, 35, 22, 6, 13], [31, 57])
#+end_src

#+RESULTS: 888 Fair candy swap my solution
| 35 | 31 |

****** Complexity
Time complexity:
$O(M\times N)$.

My solution has exceeded the time limit. 

Space complexity: 
$O(M + N)$ worst case

***** Thoughts
:LOGBOOK:
CLOCK: [2019-10-08 Tue 20:57]--[2019-10-08 Tue 20:59] =>  0:02
:END:

If Alice gives candy ~x~, and Bob gives cand ~Y~,
the key is to find out the relation that:
~sum(A) - x + y == sum(B) - y + x~ and 
~y = x + (sum(B) - sum(A))//2)~.

****** Leetcode solution

#+name: 888 Fair candy swap leetcode solution
#+begin_src python
def fair_candy_swap(A, B):
    sa, sb = sum(A), sum(B)
    setB = set(B)

    for x in A:
        if x + (sb - sa) // 2 in setB:
            return [x, x + (sb-sa)//2]
#+end_src

Time complexity:
$O(m+n)$
Space complexity: 
$O(n)$, where $n$ is the length of array B.

**** DONE 521 Longest uncommon subsequence 1                        :math:
***** Basic info
:LOGBOOK:
CLOCK: [2019-10-09 Wed 20:26]--[2019-10-09 Wed 20:30] =>  0:04
:END:
Given a group of two strings, you need to find the longest *uncommon subsequence of this group of two strings*, which is defined as the 
longest subsequence of one of these strings, and this subsequence should not be any subsequence of the other string.

A subsequence is a sequence that can be derived from one sequence by /deleting some characters without changing the order of the remaining elements/.
Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string.

The input will be two strings, and the output needs to be the length of the longest uncommon subsequence.
If the longest subsequence doesn't exist, return -1.

Both strings' lengths will not exceed 100.

Only letters from a-z will appear in input strings.


****** Examples:
#+name: 521 Longest uncommon subsequence 1 example
#+begin_example
Input: "aba", "cdc"
Output: 3
Explanation: The longest uncommon subsequence is "aba" (or "cdc"), 
because "aba" is a subsequence of "aba", 
but not a subsequence of any other strings in the group of two strings. 
#+end_example

***** Tackling process

****** Algorithm
:LOGBOOK:
CLOCK: [2019-10-09 Wed 20:49]--[2019-10-09 Wed 20:51] =>  0:02
CLOCK: [2019-10-09 Wed 20:32]--[2019-10-09 Wed 20:46] =>  0:14
:END:
Let $sub(A)$ be the set that holds all of $A$'s subsequences defined previously.

Then for two strings $A$ and $B$, we are looking for a $longest\_sub$ such that $longest\_sub=max(longest\_sub_A, longest\_sub_B)$,
where $longest\_sub_A = max(\{len(sub_A)\mid ( sub_A \in sub(A) ) \land sub_A \notin sub(B)\})$ and 
$longest\_sub_B = max(\{len(sub_B)\mid ( sub_B \in sub(B) ) \land sub_B \notin sub(A)\})$

There seems to be no faster solution than looping by deleting one, two, ..., len(A) character(s).

We can first generate all possible subsequences for each string in a hashmap, then compare them one by one.
****** Code
:LOGBOOK:
CLOCK: [2019-10-09 Wed 21:05]--[2019-10-09 Wed 21:11] =>  0:06
CLOCK: [2019-10-09 Wed 20:54]--[2019-10-09 Wed 21:05] =>  0:11
:END:
#+name: 521 Longest uncommon subsequence 1 my solution
#+begin_src python
def find_LUS_length(a, b) -> int:
    def get_subsequences(s):
        ans = set()
        ans.add("")
        ans.add(s)

        for num_to_delete in range(0, len(s)):
            # num_to_delete = 2
            # | string | a | b | c        |
            # | pos    | 0 | 1 | 2        |
            # | i      |   | 1 | 1 + 2 =3 |
            i = 0
            while i + num_to_delete <= len(s):
                sub = s[i:i+num_to_delete]
                ans.add(sub)
                i += 1
        return ans
    sub_a = get_subsequences(a)
    sub_b = get_subsequences(b)
    diff_a = sub_a.difference(sub_b)
    diff_b = sub_b.difference(sub_a)
    
    longest_a =max([len(s) for s in diff_a]) if len(diff_a) > 0 else 0
    longest_b =max([len(s) for s in diff_b]) if len(diff_b) > 0 else 0
    
    if longest_a == 0 and longest_b == 0:
        return -1
    else:
        return max([ longest_a, longest_b ])
return find_LUS_length("cd", "cdc")
#+end_src

#+RESULTS: 521 Longest uncommon subsequence 1 my solution
: 3

****** Complexity
Time complexity:
$O(2^{x} + 2^{y})$

Space complexity: 
$O(2^{x} + 2^{y})$

***** Thoughts


****** Leetcode solution
We only need to find the longest string......

So obvious but I missed it though initially had vaguely questioned...
#+name: 521 Longest uncommon subsequence 1 leetcode solution
#+begin_src python
def find_LUS_length(a, b):
    if a == b:
        return -1
    return max(len(a), len(b))
#+end_src

Time complexity:
$O(min(x, y))$

Space complexity: 
$O(1)$

**** DONE 812 Largest triangle area                                 :math:
***** Basic info
You have a list of points in the plane. Return the area of the largest triangl3 <= points.length <= 50.

No points will be duplicated.
-50 <= points[i][j] <= 50.
Answers within 10^-6 of the true value will be accepted as correct.e that can be formed by any 3 of the points.

****** Examples:
#+name: 812 Largest triangle area example
#+begin_example
Input: points = [[0,0],[0,1],[1,0],[0,2],[2,0]]
Output: 2
Explanation: 
The five points are show in the figure below. The red triangle is the largest.
#+end_example

***** Tackling process
:LOGBOOK:
CLOCK: [2019-10-09 Wed 21:27]--[2019-10-09 Wed 21:57] =>  0:30
:END:

****** Algorithm
Because the question limits the total number of points to 50, we can find all possible triangles and find their areas.

Worst case we have $C_{50}^{3}=19600$ triangles.

We also use Heron's formula to calculate the area.
****** Code
#+name: 812 Largest triangle area my solution
#+begin_src python
from typing import List
def largest_triangle_area(points) -> float:
    # def is_triangle(a, b, c):
    #     return a+b>c and a+c>b and b+c>a
    def get_area(x1, y1, x2, y2, x3, y3):
        return (x1*y2 + x2*y3+x3*y1 - x1*y3 - x2*y1- x3*y2)/2
    ans = set()
    for i, point1 in enumerate(points[:len(points) - 2]):
        x1, y1 = point1

        for j, point2 in enumerate(points[i+1:len(points) - 1]):
            x2, y2 = point2
            for k, point3 in enumerate(points[i+1:len(points)]):
                x3, y3 = point3
                ans.add(abs( get_area(x1, y1, x2, y2, x3, y3) ))
    return max(ans)
return largest_triangle_area([[0,0],[0,1], [1,0], [0, 2],[2,0]])
#+end_src

#+RESULTS: 812 Largest triangle area my solution
: 2.0

****** Complexity
Time complexity:
$O(N^{3})$ but limited to a constant.

Space complexity: 
$O(N^{3})$ but limited to a constant.

***** Thoughts

We will have 3 for loops to cycle through each choice of 3 points in the array.

After, we'll need a function to calculate the area given 3 points. Here we have some options:

We can use the Shoelace formula directly, which tells us the area given the 3 points;

We can use Heron's formula, which requires the 3 side lengths which we can get by taking the distance of two points;

We can use the formula area = 0.5 * a * b * sin(C) and calculate the angle C with trigonometry.

Our implementation illustrates the use of the shoelace formula.

If we did not know the shoelace formula, we could derive it for triangles with the following approach: starting with points (px, py), (qx, qy), (rx, ry), the area of this triangle is the same under a translation by (-rx, -ry), so that the points become (px-rx, py-ry), (qx-rx, qy-ry), (0, 0).

From there, we could draw a square around the triangle with sides touching the coordinate axes, and calculate the area of the square minus the area of the right triangles surrounding the inner triangle.

For more on this approach, see the Wikipedia entry for the Shoelace formula.
****** Leetcode solution
:PROPERTIES:
:CUSTOM_ID: 812_leetcode_solution
:END:

#+name: 812 Largest triangle area leetcode solution
#+begin_src python
class Solution(object):
    def largestTriangleArea(self, points):
        def area(p, q, r):
            return .5 * abs(p[0]*q[1]+q[0]*r[1]+r[0]*p[1]
                            -p[1]*q[0]-q[1]*r[0]-r[1]*p[0])

        return max(area(*triangle)
            for triangle in itertools.combinations(points, 3))
#+end_src

Time complexity:
$O(N^{3})$ but limited to a constant.

Space complexity: 
$O(1)$

**** DONE 896 Monotonic array
***** Basic info
:LOGBOOK:
CLOCK: [2019-10-10 Thu 16:53]--[2019-10-10 Thu 16:57] =>  0:04
:END:
An array is /monotonic/ if it is either monotone increasing or monotone decreasing.

An array is monotone increasing if $\forall i\leq j, A[i] \leq A[j]$.
An array is monotone decreasing if $\forall i\leq j, A[i] \geq A[j]$.

Return ~true~ iff the given array ~A~ is monotonic.

$1\leq A.length \leq 50000$

$-100000\leq A[i]\leq 100000$
****** Examples:
#+name: 896 Monotonic array example
#+begin_example
Input: [1,2,2,3]
Output: true
Input: [1,1,1]
Output: true
#+end_example

***** Tackling process

****** Algorithm
:LOGBOOK:
CLOCK: [2019-10-10 Thu 16:57]--[2019-10-10 Thu 17:11] =>  0:14
:END:
\begin{equation}
\[
    f(A)= 
\begin{cases}
    True,& \text{if } A.length == 1 \text{  or } A.length == 2\\
    True,              & \text{if } \forall i\leq j, A[i] \leq A[j]\\
    True,              & \text{if } \forall i\leq j, A[i] \geq A[j]\\
    False, & \text{otherwise}
\end{cases}
\]
\end{equation}
****** Code
:LOGBOOK:
CLOCK: [2019-10-10 Thu 17:11]--[2019-10-10 Thu 17:26] =>  0:15
:END:
#+name: 896 Monotonic array my solution
#+begin_src python
from typing import List

def is_monotonic(A: List[int]) -> bool:
    if len(A) == 1 or len(A) == 2:
        return True
    prev_diff = 0
    for i in range(len(A)-1):
        diff = A[i] - A[i+1]
        if diff == 0:
            continue
        elif diff > 0 and prev_diff < 0:
            return False
        elif diff < 0 and prev_diff > 0:
            return False
        else:
            prev_diff = diff
    return True

return is_monotonic([1,1,0])
#+end_src

#+RESULTS: 896 Monotonic array my solution
: True

****** Complexity
Time complexity:
$O(N)$, we need to check all elements in the array.
Space complexity: 
$O(1)$.

***** Thoughts


****** Leetcode solution
:LOGBOOK:
CLOCK: [2019-10-10 Thu 17:26]--[2019-10-10 Thu 17:28] =>  0:02
:END:

#+name: 896 Monotonic array leetcode solution
#+begin_src python
def is_monotonic(A):
    inc = dec = True

    for i in range(len(A) - 1):
        if A[i] > A[i+1]:
            inc = False
        if A[i] < A[i+1]:
            dec = False
    return inc or dec
#+end_src

Time complexity:
$O(N)$, however this runs slightly slower on average because it always tries to loop through all of the elements.

Space complexity: 
$O(1)$

**** DONE 917 Reverse only letters
***** Basic info
:LOGBOOK:
CLOCK: [2019-10-10 Thu 20:44]--[2019-10-10 Thu 20:45] =>  0:01
:END:
Given a string ~S~, return the "reversed" string where all characters that are not a letter stay in the same place, and all letters reverse their positions.

S.length <= 100

33 <= S[i].ASCIIcode <= 122 

S doesn't contain \ or "
****** Examples:
#+name: 917 Reverse only letters example
#+begin_example
Input: "ab-cd"
Output: "dc-ba"

Input: "a-bC-dEf-ghIj"
Output: "j-Ih-gfE-dCba"

Input: "Test1ng-Leet=code-Q!"
Output: "Qedo1ct-eeLg=ntse-T!"
#+end_example

***** Tackling process

****** Algorithm
:LOGBOOK:
CLOCK: [2019-10-10 Thu 20:45]--[2019-10-10 Thu 20:50] =>  0:05
:END:
Two cases to consider:
\begin{equation}
  \[
    \begin{cases}
      S.length = 0 \\
      S.length \neq 0
      \end{cases}
   \]
\end{equation}

Also, we want to leave the non-letters to stay *exactly* where they are in the string.

Then we reorder the letters and place them one-by-one back to the string.
****** Code
:LOGBOOK:
CLOCK: [2019-10-10 Thu 21:13]--[2019-10-10 Thu 21:16] =>  0:03
CLOCK: [2019-10-10 Thu 20:51]--[2019-10-10 Thu 21:12] =>  0:21
:END:
#+name: 917 Reverse only letters my solution
#+begin_src python
def reverse_only_letters(S: str) -> str:
    ans = [None for _ in range(len(S))]

    letters = []
    for i, c in enumerate(S):
        if not c.isalpha():
            ans[i] = c
        else:
            letters.append(c)

    pos = 0
    while len(letters) > 0:
        c = letters.pop()
        while ans[pos] is not None:
            pos += 1
            ans[pos] = c
    return "".join(ans)
return reverse_only_letters("78_2]")
#+end_src

#+RESULTS: 917 Reverse only letters my solution
: 78_2]

#+begin_src python
alphabets = list(range(ord("A"), ord("z") + 1))
def is_letter(c):
    return ord(c) in alphabets
return ord("z")
return is_letter("a")
#+end_src

#+RESULTS:
: 122

****** Complexity
Time complexity:
$O(N)$, two pass.

Space complexity: 
$O(N)$

***** Thoughts
#+name: 917 Reverse only letters my solution improved based on leetcode solution
#+begin_src python
def reverse_only_letters(S: str) -> str:
    ans = [None for _ in range(len(S))]

    letters = [c for c in S if c.isalpha()]
    for c in S:
        if c.isalpha():
            # the original positions where hold letters are 
            # still filled with letters, just reversed.
            ans.append(letter.pop())
        else:
            ans.append(c)
    return "".join(ans)
return reverse_only_letters("78_2]")
#+end_src



****** Leetcode solution
Reverse pointer.

Write the characters of S one by one. When we encounter a letter, we want to write the next letter that occurs if we iterated through the string backwards.

So we do just that: keep track of a pointer j that iterates through the string backwards. When we need to write a letter, we use it.
#+name: 917 Reverse only letters leetcode solution
#+begin_src python
class Solution(object):
    def reverseOnlyLetters(self, S):
        ans = []
        j = len(ans) - 1
        for i, x in enumerate(S):
            if x.isalpha():
                while not S[j].isalpha():
                    j -= 1
                    ans.append(S[j])
                    j -= 1
            else:
                ans.append(x)
                
        return "".join(ans)
#+end_src

Time complexity:

Space complexity: 

**** DONE 237 Delete node in a linked list
***** Basic info
Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.

1. The linked list will have at least two elements.
2. All of the nodes' values will be unique.
3. The given node will not be the tail and it will always be a valid node of the linked list.
4. Do not return anything from your function.
****** Examples:
#+name: 237 Delete node in a linked list example
#+begin_example
Input: head = [4,5,1,9], node = 5
Output: [4,1,9]
Explanation: You are given the second node with value 5, the linked list should become 4 -> 1 -> 9 after calling your function.

Input: head = [4,5,1,9], node = 1
Output: [4,5,9]
Explanation: You are given the third node with value 1, the linked list should become 4 -> 5 -> 9 after calling your function.
#+end_example

***** Tackling process

****** Algorithm
:LOGBOOK:
CLOCK: [2019-10-14 Mon 13:08]--[2019-10-14 Mon 13:10] =>  0:02
:END:
+Say the node we are going to delete is ~node_d~, which holds a value ~val~ and a next node ~node_n~,+
+because we do not know any information about ~node_d~'s previous node, we must make ~node_d~ variable point to ~node_n~,
and do this recursively/iteratively for all nodes after ~node_d~.+
We simply let the current node point to its grandchild node.
****** Code
:LOGBOOK:
CLOCK: [2019-10-14 Mon 13:12]--[2019-10-14 Mon 13:25] =>  0:13
:END:
#+name: 237 Delete node in a linked list my solution
#+begin_src python
def delete_node(node):
    node.val = node.next.val
    node.next = node.next.next
    
#+end_src

****** Complexity
Time complexity:
$O(1)$

Space complexity: 
$O(1)$

***** Thoughts
Note we still have the /missing node/ in the memory. Unfortunately this is the only weay to solve it.

In lower level programming languages, this could be an issue because the lack of gabbage collectors.
****** Leetcode solution

#+name: 237 Delete node in a linked list leetcode solution
#+begin_src python

#+end_src

Time complexity:

Space complexity: 

**** DONE [#A] 292 Nim game                               :recursive:math:
***** Basic info
:LOGBOOK:
CLOCK: [2019-10-14 Mon 13:31]--[2019-10-14 Mon 13:32] =>  0:01
:END:
There is a heap of stones on the table, each time one of the two players takes turns to remveo 1 to 3 stones.
The one who removes the last stone will be the winner. You will take the first turn to remvoe the stones.

Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the 
game givein the number of stones in the heap.

****** Examples:
#+name: 292 Nim game example
#+begin_example
Input: 4
Output: false 
Explanation: If there are 4 stones in the heap, then you will never win the game;
             No matter 1, 2, or 3 stones you remove, the last stone will always be 
             removed by your friend.
#+end_example

***** Tackling process

****** Algorithm
:LOGBOOK:
CLOCK: [2019-10-14 Mon 13:32]--[2019-10-14 Mon 13:34] =>  0:02
:END:
This should be solved recursively by the look of it, because we are facing *a series of moves that ultimately depend on the first three choices*, namely, removing 1, 2, 3 stones.

****** Code
:LOGBOOK:
CLOCK: [2019-10-14 Mon 13:40]--[2019-10-14 Mon 13:55] =>  0:15
:END:
#+name: 292 Nim game my solution
#+begin_src python
def can_win_nim(n) -> bool:
    def can_win(n, me:bool) -> bool:
        # because i'm taking the first turn
        if 0 < n <= 3:
            return True
        else:
            # if any of these three steps returns True, then i win
            if me:
                return can_win(n-1, not me) or can_win(n-2, not me) or can_win(n-3, not me)
            else:
                return not (can_win(n-1, not me) or can_win(n-2, not me) or can_win(n-3, not me))
            
    return can_win(n, True)
return can_win_nim(5)
#+end_src

#+RESULTS: 292 Nim game my solution
: False

#+begin_src python
return not
#+end_src

#+RESULTS:
: False

****** Complexity
Time complexity:

Space complexity: 

***** Thoughts


****** Leetcode solution
:LOGBOOK:
CLOCK: [2019-10-14 Mon 13:55]--[2019-10-14 Mon 14:02] =>  0:07
:END:

You can *always* win a Nim game if the number of stones $n$ in the pile is not divisible by 4.

It is clear that if there are only one, two or three stones in the pile, and it is your turn, you can win the game by taking all of them.
If there are four stones in the pile, you will lose. Because no matter how many you take, you will leave some stones behind for your opponent to take and win the game.
So in order to win, you have to ensure that you never leave four stones for yourself to pick.

Similarly, if there are five, six, or seven stones, you can win by just taking enough to leave four stones for your opponent so that they lose.
Buf if there are eight stones on the pile, you will inevitably lose, because regardless whether you pick one, two, or three stones from the pile,
your opponent can pick three, two or one stone to ensure that, again, four stones will be left on your turn.

It is obvious that the same pattern repeats itself for $n=4,8,12,16\text{...}$.

#+name: 292 Nim game leetcode solution
#+begin_src python
def can_win_nim(n):
    return (n % 4 != 0)
#+end_src

Time complexity:
$O(1)$
Space complexity: 
$O(1)$

**** DONE 953 Verifying an alien dectionary
***** Basic info
:LOGBOOK:
CLOCK: [2019-10-14 Mon 14:19]--[2019-10-14 Mon 14:23] =>  0:04
:END:
In an alien language, they also use English lowercase letters, but possibly in a different ~order~. 
The ~order~ of the alphabet is some permutation of lowercase letters.

Given a sequence of ~words~ written in the alien language, and the ~order~ of the alphabet, return ~True~ iff the given ~words~ are
sorted lexicographicaly in this alien language.

1 <= words.length <= 100
1 <= words[i].length <= 20
order.length == 26
All characters in words[i] and order are english lowercase letters.
****** Examples:
#+name: 953 Verifying an alien dectionary example
#+begin_example
Input: words = ["hello","leetcode"], order = "hlabcdefgijkmnopqrstuvwxyz"
Output: true
Explanation: As 'h' comes before 'l' in this language, then the sequence is sorted.

Input: words = ["word","world","row"], order = "worldabcefghijkmnpqstuvxyz"
Output: false
Explanation: As 'd' comes after 'l' in this language, then words[0] > words[1], hence the sequence is unsorted.

Input: words = ["apple","app"], order = "abcdefghijklmnopqrstuvwxyz"
Output: false
Explanation: The first three characters "app" match, and the second string is shorter (in size.) According to lexicographical rules "apple" > "app", because 'l' > '', where '' is defined as the blank character which is less than any other character.
#+end_example

***** Tackling process

****** Algorithm
We can use a loop to check the order of letters from each string.
****** Code
:LOGBOOK:
CLOCK: [2019-10-14 Mon 14:24]--[2019-10-14 Mon 14:45] =>  0:21
:END:
#+name: 953 Verifying an alien dectionary my solution
#+begin_src python
from typing import List
def is_alien_sorted(words: List[str], order: str) -> bool:
    def two_sorted(word1, word2) -> bool:
        i = j = 0
        while i < len(word1) and j < len(word2):
            if order.index(word1[i]) > order.index(word2[j]):
                return False
            elif order.index(word1[i]) < order.index(word2[j]):
                return True
            else:
                i += 1
                j += 1
        if i < len(word1) or j < len(word2):
            return len(word1) < len(word2)
    for i in range(len(words) - 1):
        if not two_sorted(words[i], words[i+1]):
            return False
    return True

return is_alien_sorted(["apple", "app"], "abcdefghijklmnopqrstuvwxyz")
#+end_src

#+RESULTS: 953 Verifying an alien dectionary my solution
: False

****** Complexity
Time complexity:
$O(N)$, where $N$ is the total number of characters in ~words~.

Space complexity: 
$O(1)$

***** Thoughts

I could've solved this faster if I didn't think that sorting two words lexicographically means all letters in one word need to precede the corresponding one in the other word.

****** Leetcode solution

#+name: 953 Verifying an alien dectionary leetcode solution
#+begin_src python
class Solution(object):
    def isAlienSorted(self, words, order):
        order_index = {c: i for i, c in enumerate(order)}

        for i in xrange(len(words) - 1):
            word1 = words[i]
            word2 = words[i+1]

            # Find the first difference word1[k] != word2[k].
            for k in xrange(min(len(word1), len(word2))):
                # If they compare badly, it's not sorted.
                if word1[k] != word2[k]:
                    if order_index[word1[k]] > order_index[word2[k]]:
                        return False
                    break
            else:
                # If we didn't find a first difference, the
                # words are like ("app", "apple").
                if len(word1) > len(word2):
                    return False

        return True
#+end_src

Time complexity:
$O(N)$, where $N$ is the total number of characters in ~words~.

Space complexity: 
$O(1)$.

**** DONE 788 Rotated digits
***** Basic info
:LOGBOOK:
CLOCK: [2019-10-14 Mon 15:58]--[2019-10-14 Mon 16:01] =>  0:03
:END:
~X~ is a good number if after rotating each digit individually by 180 degrees, we get a valid number that is different from ~X~.
Each digit must be rotated - we cannot choose to leave it alone.

A number is valid if each digit remains a digit after rotation. 0, 1, and 8 rotate to themselves; 2 and 5 rotate to each other;
6 and 9 rotate to each other; and the rest of numbers do not rotate to any other number and become invalid.

Now given a positive number ~N~, how many numbers ~X~ from ~1~ to ~N~ are good?

****** Examples:
#+name: 788 Rotated digits example
#+begin_example
Input: 10
Output: 4
Explanation: 
There are four good numbers in the range [1, 10] : 2, 5, 6, 9.
Note that 1 and 10 are not good numbers, since they remain unchanged after rotating.
#+end_example

***** Tackling process
:LOGBOOK:
CLOCK: [2019-10-14 Mon 16:04]--[2019-10-14 Mon 16:14] =>  0:10
:END:

****** Algorithm
We have a map that checks if a digit rotates to a valid digit.

We check each number one by one.
****** Code
#+name: 788 Rotated digits my solution
#+begin_src python
def rotated_digits(N) -> int:
    valid_digits = {"1":"1", "0":"0", "8":"8", "2":"5", "5":"2", "6":"9", "9":"6"}
    def is_good(n) -> bool:
        rotated = ""
        for d in str(n):
            if d not in valid_digits.keys():
                return False
            rotated += valid_digits[d]
        else:
            return rotated != str(n)
        ans = 0
    for n in range(1, N + 1):
        if is_good(n):
            ans += 1 
    return ans
return rotated_digits(857)
#+end_src

#+RESULTS: 788 Rotated digits my solution
: 247

****** Complexity
:LOGBOOK:
CLOCK: [2019-10-14 Mon 16:14]--[2019-10-14 Mon 16:19] =>  0:05
:END:
Time complexity:
$O(N)$, where N is the number input. Precisely, this should be $O(N\times m)$ where $m$ is the number of digits of the largest integer number.

Space complexity: 
$O(1)$, variable ~rotated~ will not exceed ~N.length~, which should be under 32 bit.

***** Thoughts
Understanding the problem is harder than implementing the solution, which is almost always true in solving any problems, not only programming.

****** Leetcode solution
Not available.
#+name: 788 Rotated digits leetcode solution
#+begin_src python

#+end_src

Time complexity:

Space complexity: 

**** DONE 283 Move zeros
***** Basic info
:LOGBOOK:
CLOCK: [2019-10-14 Mon 20:04]--[2019-10-14 Mon 20:07] =>  0:03
:END:
Given an array ~nums~, write a function to move all 0's to the end of of it,
while maintaining the relative order of the non-zero elements.

You must do this *in-place* without making a copy of the array.
Minimize the total number of operations.
****** Examples:
#+name: 283 Move zeros example
#+begin_example
Input: [0,1,0,3,12]
Output: [1,3,12,0,0]
#+end_example

***** Tackling process
:LOGBOOK:
CLOCK: [2019-10-14 Mon 20:07]--[2019-10-14 Mon 20:24] =>  0:17
:END:

****** Algorithm
We need a ~cur~ that loops through the array, and a ~num_checked~ to record the 
*number of total numbers checked* so far.

| 0 | 1 |             2 | 3 | 4 | 5 |
| 1 | 2 |             0 | 3 | 0 | 4 |
|   |   |         cur=2 |   |   |   |
|   |   | num_checked=3 |   |   |   |

$\downarrow$

| 0 | 1 |             2 | 3 | 4 | 5 |
| 1 | 2 |             3 | 0 | 4 | 0 |
|   |   |         cur=2 |   |   |   |
|   |   | num_checked=4 |   |   |   |

$\downarrow$
| 0 | 1 | 2 |             3 | 4 | 5 |
| 1 | 2 | 3 |             0 | 4 | 0 |
|   |   |   |         cur=3 |   |   |
|   |   |   | num_checked=5 |   |   |
****** Code
#+name: 283 Move zeros my solution
#+begin_src python
from typing import List
def move_zeros(nums: List[int]) -> None:
    nums_checked = 0
    cur = 0

    length = len(nums)

    while nums_checked < length:
        if nums[cur] == 0:
            nums.append(nums.pop(cur))
        else:
            cur += 1
            nums_checked += 1
return move_zeros([])
#+end_src

#+RESULTS: 283 Move zeros my solution
: []

****** Complexity
Time complexity:
$O(N)$

Space complexity: 
$O(1)$

***** Thoughts
:LOGBOOK:
CLOCK: [2019-10-14 Mon 20:26]--[2019-10-14 Mon 20:29] =>  0:03
:END:
Based on leetcode solutions, there can be an easier way to solve this, which does not
involve the use of ~nums_checked~.


****** Leetcode solution

#+name: 283 Move zeros leetcode solution
#+begin_src python
from typing import List
def move_zeros(nums: List[int]) -> None:
    cur = 0

    length = len(nums)

    for i in range(len(nums)):
        if nums[i] == 0:
            nums.append(nums.pop(i))
            # return nums
return move_zeros([1,2,3,0,4,0])
#+end_src

#+RESULTS: 283 Move zeros leetcode solution
| 1 | 2 | 3 | 4 | 0 | 0 |

Time complexity:
$O(N)$

Space complexity: 
$O(1)$
**** DONE 748 Shortest completing word
***** Basic info
:LOGBOOK:
CLOCK: [2019-10-14 Mon 20:36]--[2019-10-14 Mon 20:41] =>  0:05
:END:
Find the minimum length word from a given dictionary ~words~, which has all the letters from 
the string ~licensePlate~. Such a word is said to /complete/ the given string ~licensePlate~.
 
We ignore case.

It is guaranteed that an answer exists. If there are multiple answers, return the one that occurs first in the array.

The license plate might have the same letter occurring multiple times.
For example, given a ~licensePlate~ of "PP", the word "pair" does not complete the
~licensePlate~, but the word "supper" does.

1. licensePlate will be a string with length in range [1, 7].
2. licensePlate will contain digits, spaces, or letters (uppercase or lowercase).
3. words will have a length in the range [10, 1000].
4. Every words[i] will consist of lowercase letters, and have length in range [1, 15].
****** Examples:
#+name: 748 Shortest completing word example
#+begin_example
Input: licensePlate = "1s3 PSt", words = ["step", "steps", "stripe", "stepple"]
Output: "steps"
Explanation: The smallest length word that contains the letters "S", "P", "S", and "T".
Note that the answer is not "step", because the letter "s" must occur in the word twice.
Also note that we ignored case for the purposes of comparing whether a letter exists in the word.

Input: licensePlate = "1s3 456", words = ["looks", "pest", "stew", "show"]
Output: "pest"
Explanation: There are 3 smallest length words that contains the letters "s".
We return the one that occurred first.
#+end_example

***** Tackling process

****** Algorithm
:LOGBOOK:
CLOCK: [2019-10-14 Mon 20:42]--[2019-10-14 Mon 20:48] =>  0:06
:END:
Obviously we need to first remove non-letters from ~licencePlate~, and at the same time convert these letters to lowercase letters.

Because we need to find the smallest possible word, it is necessary for us to check *all* words in ~words~, which leads to $O(N)$ time complexity.

+We can simply sort these strings so we can easily check if ~licencePlate~ is in ~words[i]~.+
We can not simply sort them because "ah" is not in "abdh".
****** Code
#+name: 748 Shortest completing word my solution
#+begin_src python
from typing import List
def shortest_completing_word(licensePlate: str, words: List[str]) -> str:
    def stripped_licence(licensePlate):
        ans = ""
        for c in licensePlate:
            if c.isalpha():
                ans += c.lower()
        return ans

    def word_map(word) -> dict:
        ans = {}
        for c in word:
            ans[c] = ans.get(c, 0) + 1
        return ans

    license = word_map((stripped_licence(licensePlate)))
    
    ans = "some random text as a place holder"
    for word in words:
        # we can use this length test because there is a guaranteed answer
        if len(word) < len(ans):
            word_dict = word_map(word)
            for k, v in license.items():
                if k not in word_dict.keys() or word_dict[k] < v:
                    break
            else:
                ans = word
    return ans
return shortest_completing_word("Ah71752", ["suggest","letter","of","husband","easy","education","drug","prevent","writer","old"])
#+end_src

#+RESULTS: 748 Shortest completing word my solution
: husband

#+begin_src python
return "".join(sorted("Ah")) in "".join(sorted("husband"))
#+end_src

#+RESULTS:
: False

#+begin_src python
test = ["1", "2", "1"]
test.pop("1")
return test
#+end_src

#+RESULTS:

****** Complexity
:LOGBOOK:
CLOCK: [2019-10-14 Mon 21:02]--[2019-10-14 Mon 21:18] =>  0:16
:END:
Time complexity:
$O(N)$ where $N$ is the number of words. This can be slightly more complicated but because there is a length limit on ~licensePlate~, its related complexity is a constant.

Space complexity: 
$O(1)$

***** Thoughts
To count how many times a character has appeared in a string, it's easier just to use a dictionary.

****** Leetcode solution
Not available.

#+name: 748 Shortest completing word leetcode solution
#+begin_src python

#+end_src

Time complexity:

Space complexity: 

**** DONE 690 Employee importance
***** Basic info
:LOGBOOK:
CLOCK: [2019-10-15 Tue 15:30]--[2019-10-15 Tue 15:32] =>  0:02
:END:
You are given a data structure of employee information, which includes the employee's *unique id*, his *importance value*, and his *direct* subordinates' id.

For example, employee 1 is the leader of employee 2, and employee 2 is the leader of employee 3. They have importance value 15, 10, and 5, respectively.
Then employee 1 has a datastructure like ~[1, 15, [2]]~, and employee 2 has ~[2, 10, [3]]~. Note that although employee 3 is also a subordinate of 
employee 1, the relationship is *not direct*.

Now given the employee information of a company, and an employee id, you need to return the total importance value of this employee and all his subordinates.

1. One employee has at most one direct leader and may have several subordinates.
2. The maximum number of employees won't exceed 2000.
****** Examples:
#+name: 690 Employee importance example
#+begin_example
Input: [[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1
Output: 11
Explanation:
Employee 1 has importance value 5, and he has two direct subordinates: employee 2 and employee 3. They both have importance value 3. So the total importance value of employee 1 is 5 + 3 + 3 = 11.
#+end_example

***** Tackling process

****** Algorithm
:LOGBOOK:
CLOCK: [2019-10-15 Tue 15:35]--[2019-10-15 Tue 15:42] =>  0:07
CLOCK: [2019-10-15 Tue 15:32]--[2019-10-15 Tue 15:33] =>  0:01
:END:
+It's basically a tree problem.+
+We can walk the tree down recursively and get the importance value of each node/employee under the root.+

Unfortunately the data is given as a list, not a tree.

We need to scan the list and at the same time construct a hash map that
maps ~id~ to ~importance~ value and ~subordinates~.

We also need a set to check if we have added one employee's ~importance~ to 
avoid double counting.
****** Code
:LOGBOOK:
CLOCK: [2019-10-16 Wed 13:58]--[2019-10-16 Wed 14:16] =>  0:18
:END:
#+name: 690 Employee importance my solution
#+begin_src python
from typing import List

class Employee:
    def __init__(self, id, importance, subordinates):
        # It's the unique id of each node.
        # unique id of this employee
        self.id = id
        # the importance value of this employee
        self.importance = importance
        # the id of direct subordinates
        self.subordinates = subordinates

def get_importance(employees: List[Employee], id):
    visited_employees = set()
    employees_map = {}
    ans = 0

    for emp in employees:
        employees_map[emp.id] = (emp.importance, emp.subordinates)
        # get the first employee
        if emp.id == id:
            root = emp
            
    stack = []
    stack.append(root)
    while len(stack) > 0:
        emp = stack.pop()
        ans += emp.importance
        visited_employees.add(emp.id)
        # O(N) complexity
        for sub_id in emp.subordinates:
            if sub_id not in visited_employees:
                # O(N) complexity
                for i in employees:
                    if i.id == sub_id:
                        sub = i
                        break
                    stack.append(sub)
    return ans
#+end_src

****** Complexity
:LOGBOOK:
CLOCK: [2019-10-16 Wed 14:16]--[2019-10-16 Wed 14:19] =>  0:03
:END:
Time complexity:
$O(N\times N)$, where N is the total number of employees.
Space complexity: 
$O(N)$ worst case.

***** Thoughts
:LOGBOOK:
CLOCK: [2019-10-16 Wed 14:22]--[2019-10-16 Wed 14:28] =>  0:06
:END:
The nice thing here is that I could quickly think of the ~stack~ to do this sort of tree tasks - keep getting the children of a node in a loop.

Compared to the leetcode solution, I already had the ~employees_map~ but didn't use it. Instead I added complexity by trying to find
the employee whose id is ~sub_id~.
****** Leetcode solution
This solution is neat, but does not verify if the subordinate has been visited already.
#+name: 690 Employee importance leetcode solution
#+begin_src python
def get_importance(employees, query_id):
    emap = {e.id: e for e in employees}
    def dfs(eid):
        employee = emap[eid]
        return (employee.importance +
                sum(dfs(eid) for eid in employee.subordinates))
    return dfs(query_id)
#+end_src

Time complexity:

Space complexity: 

**** DONE 1029 Two city scheduling
***** Basic info
:LOGBOOK:
CLOCK: [2019-10-16 Wed 14:30]--[2019-10-16 Wed 14:32] =>  0:02
:END:
There are ~2N~ people a company is planning to interview. The cost of flying the i-th person to city ~A~ 
is ~costs[i][0]~, and the cost of flying the i-th person to city ~B~ is ~costs[i][1]~.

Return the minimum cost to fly every person to a city such that exactly ~N~ people arrive in each city.

1. 1 <= costs.length <= 100
2. It is guaranteed that costs.length is even.
3. 1 <= costs[i][0], costs[i][1] <= 1000
****** Examples:
#+name: 1029 Two city scheduling example
#+begin_example
Input: [[10,20],[30,200],[400,50],[30,20]]
Output: 110
Explanation: 
The first person goes to city A for a cost of 10.
The second person goes to city A for a cost of 30.
The third person goes to city B for a cost of 50.
The fourth person goes to city B for a cost of 20.

The total minimum cost is 10 + 30 + 50 + 20 = 110 to have half the people interviewing in each city.
#+end_example

***** Tackling process

****** Algorithm
:LOGBOOK:
CLOCK: [2019-10-16 Wed 14:36]--[2019-10-16 Wed 14:39] =>  0:03
:END:
We can fist fly all people to ~A~, which gives a total cost, and calculate the differences ~d[i] = costs[i][1] - cost[i][0]~, 
sort the differences, and then add the first ~N~ differences to the total cost.

****** Code
:LOGBOOK:
CLOCK: [2019-10-16 Wed 14:39]--[2019-10-16 Wed 14:43] =>  0:04
:END:
#+name: 1029 Two city scheduling my solution
#+begin_src python
from typing import List
def two_city_sched_cost(costs: List[List[int]]) -> int:
    d = []
    total_cost = 0
    for cost in costs:
        d.append(cost[1] - cost[0])
        total_cost += cost[0]
        sorted_d = sorted(d)
    return total_cost + sum(sorted_d[:len(costs)//2])
return two_city_sched_cost([[10,20],[30,200],[400,50],[30,20]])
#+end_src

#+RESULTS: 1029 Two city scheduling my solution
: 110

****** Complexity
Time complexity:
$O(NlogN)$, where $N$ is the number of items in ~costs~.

We need to sort the list.
Space complexity: 
$O(N)$

***** Thoughts
This is an easy problem. Just need to find the pattern.

****** Leetcode solution
Not available.
#+name: 1029 Two city scheduling leetcode solution
#+begin_src python

#+end_src

Time complexity:

Space complexity: 

**** DONE 169 Majority element
***** Basic info
:LOGBOOK:
CLOCK: [2019-10-16 Wed 15:22]--[2019-10-16 Wed 15:26] =>  0:04
:END:
Given an array of size ~n~, find the majority element.
The majority element is the element that appears *more than* $\left \lfloor{n/2}\right \rfloor$ times.

You may assume that the array is non-empty and the majority element always exists in the array.

****** Examples:
#+name: 169 Majority element example
#+begin_example
Input: [3,2,3]
Output: 3

Input: [2,2,1,1,1,2,2]
Output: 2
#+end_example

***** Tackling process

****** Algorithm
:LOGBOOK:
CLOCK: [2019-10-16 Wed 15:26]--[2019-10-16 Wed 15:27] =>  0:01
:END:
Each array has and only has one majority element.

We can simply loop throught the array and count each element.
****** Code
#+name: 169 Majority element my solution
#+begin_src python
def majority_element(nums):
    count = {}
    for i in nums:
        count[i] = count.get(i, 0) + 1

    sorted_count = sorted(count.items(), key=lambda kv: (kv[1], kv[0]), reverse=True)
    return sorted_count[0][0]
return majority_element([2,2,1,1,1,2,2])
#+end_src

#+RESULTS: 169 Majority element my solution
: 2

****** Complexity
Time complexity:
$O(NlogN)$, used by sorting.

Space complexity: 
$O(N)$

***** Thoughts
:LOGBOOK:
CLOCK: [2019-10-16 Wed 15:37]--[2019-10-16 Wed 15:42] =>  0:05
:END:
The key is how to sort the dictionary.

****** Leetcode solution
Because $count(majority\_element)>=\left \lfloor{n/2}\rfloor \right + 1$, if we sort the array, it's guaranteed that the majority element 
will appear at position ~n//2~. 
#+name: 169 Majority element leetcode solution
#+begin_src python
class Solution:
    def majorityElement(self, nums):
        nums.sort()
        return nums[len(nums)//2]
return [1,3,3]
#+end_src

#+RESULTS: 169 Majority element leetcode solution
| 1 | 3 | 3 |

Time complexity:
$O(NlgN)$.
Space complexity: 
$O(1)$, because we used in-place sort here.


There are [[https://leetcode.com/problems/majority-element/][many other solutions]] .
**** DONE 696 Count binary substrings
***** Basic info
:LOGBOOK:
CLOCK: [2019-10-16 Wed 21:16]--[2019-10-16 Wed 21:19] =>  0:03
:END:
Given a string ~s~, count the number of non-empty (contiguous) substrings that have the same number of 0's and 1's,
and all the 0's and 1's in these substrings are grouped consecutively.

Substrings that occur multiple times are counted the number of times they occur.

~s~ will only consist of "0" or "1" characters.

~s.length~ will be between 1 and 50000.
****** Examples:
#+name: 696 Count binary substrings example
#+begin_example
Input: "00110011"
Output: 6
Explanation: There are 6 substrings that have equal number of consecutive 1's and 0's: "0011", "01", "1100", "10", "0011", and "01".

Notice that some of these substrings repeat and are counted the number of times they occur.

Also, "00110011" is not a valid substring because all the 0's (and 1's) are not grouped together.


Input: "10101"
Output: 4
Explanation: There are 4 substrings: "10", "01", "10", "01" that have equal number of consecutive 1's and 0's.
#+end_example

***** Tackling process

****** Algorithm
:LOGBOOK:
CLOCK: [2019-10-16 Wed 21:20]--[2019-10-16 Wed 21:33] =>  0:13
:END:
/Observation/: 
1. the substring must have at its middle "01" or "10".
2. using the middle part as a axis, the substring must have all 1's and 0's on one side, respectively.

/Steps/:
1. Find the "01" or "10" as ~mid~
2. Starting from ~mid~ and check its left and right hand side, see if all 1's and 0's are on one side, respectively.
3. Add one to the answer until we reach the point where a number is on the wrong side.
4. Repeat till we cannot find any "01" or "10" in ~s~.
****** Code
:LOGBOOK:
CLOCK: [2019-10-16 Wed 21:33]--[2019-10-16 Wed 21:40] =>  0:07
:END:
#+name: 696 Count binary substrings my solution
#+begin_src python
def count_binary_substrings(s: str) -> int:
    ans = 0

    for i in range(len(s) - 1):
        if int(s[i]) + int(s[i+1]) == 1:
            ans += 1 # add 1 to ans for the mid part
            left = i - 1
            right = i + 1 + 1
            while left >= 0 and right < len(s):
                # when one of the numbers is on the wrongside
                if s[left] != s[i] or s[right] != s[i+1]:
                    break
                ans += 1
                left -= 1
                right += 1
    return ans
return count_binary_substrings("10001")
#+end_src

#+RESULTS: 696 Count binary substrings my solution
: 2

****** Complexity
Time complexity:
$O(N)$.

This may look like $O(N^2)$ but it isn't, because if the ~while~ loop checks $N$ elements, then this operation will only happen once when we are at ~mid~.

Space complexity: 
$O(1)$.

***** Thoughts
I think my way of thinking about this is easier than the one on Leetcode.

****** Leetcode solution
Just for future [[https://leetcode.com/problems/count-binary-substrings/solution/][reference]].
#+name: 696 Count binary substrings leetcode solution
#+begin_src python
class Solution(object):
    def countBinarySubstrings(self, s):
        ans, prev, cur = 0, 0, 1
        for i in xrange(1, len(s)):
            if s[i-1] != s[i]:
                ans += min(prev, cur)
                prev, cur = cur, 1
            else:
                cur += 1

        return ans + min(prev, cur)
#+end_src

Time complexity:
$O(N)$

Space complexity: 
$O(1)$

**** DONE 448 Find all numbers disappeared in an array
***** Basic info
:LOGBOOK:
CLOCK: [2019-10-17 Thu 09:15]--[2019-10-17 Thu 09:18] =>  0:03
:END:
Given an array of integers wehre $1\leq a[i] \leq a.length$, some elements appear twice and others appear once.

Find all the elements of $[1,a.length]$ inclusive that do not appear in this array.

Coud you do it without extra space and in $O(N)$ run time? You may assume the returned list does not count as extra space.

****** Examples:
#+name: 448 Find all numbers disappeared in an array example
#+begin_example
Input:
[4,3,2,7,8,2,3,1]

Output:
[5,6]
#+end_example

***** Tackling process

****** Algorithm
:LOGBOOK:
CLOCK: [2019-10-17 Thu 09:26]--[2019-10-17 Thu 09:42] =>  0:16
:END:
We must do this in N scans to achieve $O(n)$ time complexity.

We cannot sort the original array as this gives us $O(nlgn)$ time.

We cannot create any extra space.
****** Code
#+name: 448 Find all numbers disappeared in an array my solution
#+begin_src python
from typing import List

def find_disappeared_numbers(nums) -> List[int]:
    ans = set(nums)
    for i in range(1, len(nums) + 1):
        if i in ans:
            ans.remove(i)
        else:
            ans.add(i)
    return list(ans)
return find_disappeared_numbers([4,3,2,7,8,2,3,1])
#+end_src

#+RESULTS: 448 Find all numbers disappeared in an array my solution
| 5 | 6 |

#+begin_src python
test = set([1,2,2,3])
for i in [1,3]:
    if i in test:
        test.remove(i)
return list(test)
#+end_src

#+RESULTS:
| 2 |

****** Complexity
Time complexity:
$O(n)$, ~set.add()~, ~set.remove()~ are constant time.
Space complexity: 
$O(1)$, we do not count ~ans~ space.
***** Thoughts
:LOGBOOK:
CLOCK: [2019-10-17 Thu 09:48]--[2019-10-17 Thu 09:58] =>  0:10
:END:

Well the [[448 Find all numbers disappeared in an array my solution]]
doesn't exactly fit in as an $O(1)$ space answer. We are just playing the word game.

****** Leetcode solution
:LOGBOOK:
CLOCK: [2019-10-17 Thu 09:58]--[2019-10-17 Thu 10:07] =>  0:09
:END:
#+begin_quote
We definitely need to keep track of all the ~unique~ numbers that appear in the array.
However, we don't want to use any extra space for it. This solution that we will look at in just
a moment springs from the fact that *All the elements are in the range [1, n]*.

Since we are given this information, we can make use of the input array itself to somehow 
*mark visited* numbers and then find our missing numbers. Now, we don't want to change
the actual data in the array but who's stopping us from changing the *magnitude* of the numbers
in the array? That is the basic idea behind this algorithm.

*We will be negating the numbers in the array and use the sign of each of the numbers for*
*finding our missing numbers. We will be treating numbers in the array as indices and mark corresponding
*locations in the array as negative.*

Algorithm:

1. iterate over the input array one element at a time.
2. for each element ~nums[i]~, mark he element at the corresponding location negative if it's not already marked negative.
3. Now, loop over from 1 to n and for each number check if ~nums[j-1]~ is negative. If it is negative, that means we've seen this number somewhere in the array.
4. Add all the numbers to the resultant array which don't have their corresponding locations marked as negative in the original array.
#+end_quote

#+name: 448 Find all numbers disappeared in an array leetcode solution
#+begin_src python
def find_disappeared_numbers(nums):
    ans = []
    for i in nums:
        if nums[abs(i) - 1] > 0:
            nums[abs(i) - 1] = nums[abs(i) - 1] * (-1)
    for j in range(len(nums)):
        if nums[j] > 0:
            ans.append(j + 1)
            
    return ans
return find_disappeared_numbers([4,3,2,7,8,2,3,1])
#+end_src

#+RESULTS: 448 Find all numbers disappeared in an array leetcode solution

Time complexity:
$O(n)$

Space complexity: 
$O(1)$

**** DONE 937 Reorder data in log files
***** Basic info
:LOGBOOK:
CLOCK: [2019-10-17 Thu 10:26]--[2019-10-17 Thu 10:30] =>  0:04
:END:
You have an array of logs. Each log is a space delimited string of words.

For each log, the first word in each log is an alphanumeric /identifier/. Then, either:
- Each word after the identifier will consist only of lowercase letters, or;
- Each word after the identifier will only consist of digits.

We will call these two varieties of logs *letter-logs* and *digit-logs*. It is guaranteed that each log has at
least one word after its identifier.

Reorder the logs so that all of the letter-logs come before any digit-log. The letter-logs are ordered lexicographically ignoring
identifier, with the identifier used in case of ties. The digit-logs should be put in their original order.

Return the final order of the logs.

1. 0 <= logs.length <= 100
2. 3 <= logs[i].length <= 100
3. logs[i] is guaranteed to have an identifier, and a word after the identifier.
****** Examples:
#+name: 937 Reorder data in log files example
#+begin_example
Input: logs = ["dig1 8 1 5 1","let1 art can","dig2 3 6","let2 own kit dig","let3 art zero"]
Output: ["let1 art can","let3 art zero","let2 own kit dig","dig1 8 1 5 1","dig2 3 6"]
#+end_example

***** Tackling process

****** Algorithm
1. We loop through the logs
2. for each log, we check first character after the first space
   - if it's alphabet, we add the log to alphabet, with /identifier/ at the end
   - if it's a numeric, we add the log to numeric
3. We sort the alphabet lexicographically
4. We put the /identifier/ back at the front of each log
5. add alphabet and numeric together
****** Code
:LOGBOOK:
CLOCK: [2019-10-17 Thu 10:36]--[2019-10-17 Thu 10:56] =>  0:20
:END:
#+name: 937 Reorder data in log files my solution
#+begin_src python
from typing import List

def reorder_log_files(logs: List[str]) -> List[str]:
    alphabet = []
    numeric = []
    ans = []

    for log in logs:
        for i in range(len(log)):
            if log[i] == " ":
                if log[i +1].isalpha():
                    alphabet.append("{data} {identifier}".format(data=log[i+1:], identifier=log[:i]))
                else:
                    numeric.append(log)
                break
            alphabet.sort()

    for log in alphabet:
        for i in range(len(log)-1, 0, -1):
            if log[i] == " ":
                ans.append("{identifier} {data}".format(identifier=log[i+1:], data=log[:i]))
                break
            ans.extend(numeric)
    return ans
return reorder_log_files(["dig1 8 1 5 1","let1 art can","dig2 3 6","let2 own kit dig","let3 art zero"])
#+end_src

#+RESULTS: 937 Reorder data in log files my solution
| let1 art can | let3 art zero | let2 own kit dig | dig1 8 1 5 1 | dig2 3 6 |

****** Complexity
Time complexity:
$O(NlgN)$, where $N$ is the length of ~logs~.
We need to sort once.

Space complexity: 
$O(N)$, where $N$ is the length of ~logs~.

***** Thoughts
:LOGBOOK:
CLOCK: [2019-10-17 Thu 10:57]--[2019-10-17 Thu 14:51] =>  3:54
:END:
The devil is in the details.
I initially had this:
#+begin_src python
alphabet.append("{data} {identifier}".format(data=log[i+1:], identifier=log[:i+1]))
#+end_src
Which added one space to the ~identifier~ and later was detected as the first space in the ~log~ when scanning from left to right.


****** Leetcode solution
:LOGBOOK:
CLOCK: [2019-10-17 Thu 14:51]--[2019-10-17 Thu 15:00] =>  0:09
:END:
We can sort the logs in a custom order that we specify.

The rules are:
1. letter-logs come before digit-logs
2. letter logs are sorted alphanumerically, by content then identifier
3. digit-logs remain in the same order

In this code, ~return (0, rest, id_) if rest[0].isalpha() else (1, )~,
we return a tuple as the ~log~'s key. The ~1~ makes sure that digit-logs are always after the letter-logs.
All digit-logs use the same key -- ~(1, )~ --, which in Python's ~sorted()~ function, means that these logs' order is kept as is.
The parenthesis around the ~1,~ is to make it a tuple so it's comparable to ~(0, rest, id_)~.
This is a brilliant solution.
#+name: 937 Reorder data in log files leetcode solution
#+caption: 937 Reorder data in log files leetcode solution
#+begin_src python
def reorder_log_files(logs):
    def f(log):
        id_, rest = log.split(" ", 1)
        return (0, rest, id_) if rest[0].isalpha() else (1, )
    return sorted(logs, key=f)
return reorder_log_files(["dig1 8 1 5 1","let1 art can","dig2 3 6","let2 own kit dig","let3 art zero"])
#+end_src

#+RESULTS: 937 Reorder data in log files leetcode solution
| let1 art can | let3 art zero | let2 own kit dig | dig1 8 1 5 1 | dig2 3 6 |

Time complexity:
$O(NlgN)$, where $N$ is the length of ~logs~.

Space complexity: 
$O(NlgN)$, where $N$ is the length of ~logs~.

**** DONE 242 Valid anagram
***** Basic info
:LOGBOOK:
CLOCK: [2019-10-17 Thu 16:26]--[2019-10-17 Thu 16:27] =>  0:01
:END:
Given two strings ~s~ and ~t~, write a function to determine if ~t~ is an anagram of ~s~.

You may assume the string contains only lowercase alphabets.

Follow up: what if the inputs contain unicode characters?
This seems to be not affecting Python.

****** Examples:
#+name: 242 Valid anagram example
#+caption: 242 Valid anagram example
#+begin_example
Input: s = "anagram", t = "nagaram"
Output: true

Input: s = "rat", t = "car"
Output: false
#+end_example

***** Tackling process

****** Algorithm
:LOGBOOK:
CLOCK: [2019-10-17 Thu 16:28]--[2019-10-17 Thu 16:28] =>  0:00
:END:
+We simply need to check the characters one by one.+

Okay I need to refresh my vocabulary. An anagram is actually a rearrangement of letters in a word, not simply just a reverse.
****** Code
:LOGBOOK:
CLOCK: [2019-10-17 Thu 16:28]--[2019-10-17 Thu 16:30] =>  0:02
:END:
#+name: 242 Valid anagram my solution
#+caption: 242 Valid anagram my solution
#+begin_src python
# -*- coding: utf-8 -*-
def is_anagram(s, t) -> bool:
    if len(s) != len(t):
        return False
    return sorted(s) == sorted(t)
return is_anagram("", "")
#+end_src

#+RESULTS: 242 Valid anagram my solution
: True

#+begin_src python
# -*- coding: utf-8 -*-

return len("")
#+end_src

#+RESULTS:
: 2

****** Complexity
Time complexity:
$O(NlgN)$.

Space complexity: 
$O(N)$, space used by sorting.

***** Thoughts


****** Leetcode solution
Not available. Only has Java solutions.
#+name: 242 Valid anagram leetcode solution
#+caption: 242 Valid anagram leetcode solution
#+begin_src python

#+end_src

Time complexity:

Space complexity: 

**** DONE 217 Contains duplicate
***** Basic info
:LOGBOOK:
CLOCK: [2019-10-17 Thu 16:45]--[2019-10-17 Thu 16:46] =>  0:01
:END:
Given an array of integers, find if the array contains any duplicates.

Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.
****** Examples:
#+name: 217 Contains duplicate example
#+caption: 217 Contains duplicate example
#+begin_example
Input: [1,2,3,1]
Output: true

Input: [1,2,3,4]
Output: false

Input: [1,1,1,3,3,4,3,2,4,2]
Output: true
#+end_example

***** Tackling process

****** Algorithm
:LOGBOOK:
CLOCK: [2019-10-17 Thu 16:46]--[2019-10-17 Thu 16:47] =>  0:01
:END:
Convert the list to a ~set~ and compare their length.

****** Code
:LOGBOOK:
CLOCK: [2019-10-17 Thu 16:47]--[2019-10-17 Thu 16:53] =>  0:06
:END:
#+name: 217 Contains duplicate my solution
#+caption: 217 Contains duplicate my solution
#+begin_src python
def contains_duplicate(nums):
    return len(set(nums)) != len(nums)
return contains_duplicate([1,2,3,34])
#+end_src

#+RESULTS: 217 Contains duplicate my solution
: False

****** Complexity
Time complexity:
$O(N)$
Space complexity: 
$O(N)$

***** Thoughts
Not too much for Python.

[[217 Contains duplicate my solution]] also reflects the Hash table idea provided in the Java solution by Leetcode.


****** Leetcode solution

Not available in Python.
#+name: 217 Contains duplicate leetcode solution
#+caption: 217 Contains duplicate leetcode solution
#+begin_src python

#+end_src

Time complexity:

Space complexity: 

**** DONE 653 Two sum 4 - input is a BST                            :tree:
***** Basic info
:LOGBOOK:
CLOCK: [2019-10-17 Thu 17:39]--[2019-10-17 Thu 17:41] =>  0:02
:END:
Given a binary search tree and a target number, return true if there exists two elements in the BST such that their sum is equal to the given target.

****** Examples:
#+name: 653 Two sum 4 - input is a BST example
#+caption: 653 Two sum 4 - input is a BST example
#+begin_example
Input: 
    5
   / \
  3   6
 / \   \
2   4   7

Target = 9

Output: True


Input: 
    5
   / \
  3   6
 / \   \
2   4   7

Target = 28

Output: False
#+end_example

***** Tackling process

****** Algorithm
:LOGBOOK:
CLOCK: [2019-10-17 Thu 17:41]--[2019-10-17 Thu 18:00] =>  0:19
:END:
We can convert this BST to a hash table.
Then for each element ~ele~ in the table, we check if ~target-ele~ is in the table.
The time complexity is $O(N+lgN)\arrow O(N)$, where $N$ is the number of nodes in the tree. $(lgN)$ is needed to construct the table, and $O(N)$ is needed to do a search for all elements.

+If we search the BST directly, the time complexity would be $O(NlgN)$ because to every search takes $O(lgN)$ time in BST.+
See Thoughts.
****** Code
#+name: 653 Two sum 4 - input is a BST my solution
#+caption: 653 Two sum 4 - input is a BST my solution
#+begin_src python
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None
def find_target(root, k):
    hash_table = set()
    def dfs(node):
        if node:
            hash_table.add(node.val)
            dfs(node.left)
            dfs(node.right)

    dfs(root)
    for i in hash_table:
        # can't use the same element twice
        if (k-i) in hash_table and (k-i != i):
            return True
    return False
return find_target(TreeNode(1), 2)
#+end_src

#+RESULTS: 653 Two sum 4 - input is a BST my solution
: False

****** Complexity
Time complexity:
$O(N)$.

Space complexity: 
$O(N)$.

***** Thoughts
:LOGBOOK:
CLOCK: [2019-10-17 Thu 18:05]--[2019-10-17 Thu 18:18] =>  0:13
:END:
We actually only need to traverse the BST once and generate a set based on the one time traversal.
At the same time of traversal, we can check if the set contains the complement element.
This also avoids the problem of checking ~k-i!=i~.

****** Leetcode solution
Java solutions have been given. Rewrite approach 2 in Python using BFS and HashSet.
#+name: 653 Two sum 4 - input is a BST leetcode solution
#+caption: 653 Two sum 4 - input is a BST leetcode solution
#+begin_src python
from collections import deque

def find_target(root, k):
    test = set()

    queue = deque()
    queue.add(root)
    while len(queue) > 0:
        node = queue.popleft()

        if node:
            if (k-node.val) in test:
                return True
            test.add(node.val)
            queue.append(node.left)
            queue.append(node.right)
    return False

#+end_src

Time complexity:
$O(N)$. This is actually significantly faster than [[653 Two sum 4 - input is a BST my solution]].
Becasue it only traverses the BST once.

Space complexity: 
$O(N)$.
**** DONE [#A] 122 Best time to buy and sell stock 2                :math:
***** Basic info
:LOGBOOK:
CLOCK: [2019-10-17 Thu 18:24]--[2019-10-17 Thu 18:28] =>  0:04
:END:
Say you have an array for which the i-th element is the price of a given stock on day ~i~.

Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e. buy one and sell one share of the stock multiple times).

You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).

****** Examples:
#+name: 122 Best time to buy and sell stock 2 example
#+caption: 122 Best time to buy and sell stock 2 example
#+begin_example
Input: [7,1,5,3,6,4]
Output: 7
Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.
             Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.
             
Input: [1,2,3,4,5]
Output: 4
Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.
             Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are
             engaging multiple transactions at the same time. You must sell before buying again.    
            
Input: [7,6,4,3,1]
Output: 0
Explanation: In this case, no transaction is done, i.e. max profit = 0.
#+end_example

***** Tackling process

****** Algorithm
:LOGBOOK:
CLOCK: [2019-10-18 Fri 10:25]--[2019-10-18 Fri 10:56] =>  0:31
CLOCK: [2019-10-17 Thu 19:42]--[2019-10-17 Thu 20:47] =>  1:05
CLOCK: [2019-10-17 Thu 18:28]--[2019-10-17 Thu 18:41] =>  0:13
:END:
We can make the following observation:
| 0 |      7 |   1 |   5 |   3 |   6 |   4 |
|   | stable | des | asc | des | asc | des |
|   |      0 |   1 |   2 |   3 |   4 |   5 |
| 0 |      0 |  -1 |  +1 |  -1 |  +1 |  -1 |
| 0 |      1 |   0 |   1 |   0 |   1 |   0 |
| 0 |      1 |   2 |   3 |   4 |   5 |   6 |

| 0 |      1 |   2 |   3 |      3 |   4 |
|   | stable | asc | asc | stable | asc |
| 0 |     +1 |  +1 |  +1 |     +0 |  +1 |
| 0 |      1 |   2 |   3 |      3 |   4 |
|   |      0 |   1 |   2 |      3 |   4 |



****** Code
:LOGBOOK:
CLOCK: [2019-10-17 Thu 20:50]--[2019-10-17 Thu 21:02] =>  0:12
:END:
#+name: 122 Best time to buy and sell stock 2 my solution
#+caption: 122 Best time to buy and sell stock 2 my solution
#+begin_src python
from typing import List

def max_profit(prices: List[int]) -> int:
    price_trend = [0]
    prices.insert(0,0)
    min_price = float('inf')
    max_price = -float('inf')
    profit = 0
    for i in range(1, len(prices)):
        if prices[i] > prices[i-1]:
            price_trend.append(price_trend[i-1]+1)
        elif prices[i] < prices[i-1]:
            price_trend.append(price_trend[i-1]-1)
        else:
            price_trend.append(price_trend[i-1])
        if price_trend[i] < min_price:
            min_price = price_trend[i]
        if price_trend[i] > max_price:
            max_price = price_trend[i]

    price_trend = price_trend[1:len(price_trend)]
    prices = prices[1:]
    for i, price_f in enumerate(price_trend):
        if i == 0:
            if price_trend[0] < price_trend[1]:
                profit -= price[0]
        else:

                
            
    return price_trend
return max_profit([6,1,3,2,4,7])
#+end_src

#+RESULTS: 122 Best time to buy and sell stock 2 my solution
| 1 | 0 | 1 | 0 | 1 | 2 |

#+begin_src python
def max_profit(prices):
    ans = 0

    if len(prices) < 2:
        return 0

    for i in range(1, len(prices)):
        if prices[i] < prices[i-1]:
            ans -= prices[i]
            if i > 1 and prices[i-1] > prices[i-2]:
                ans += prices[i-1]
        if prices[i] >= prices[i-1]:
            continue
    return ans
    if prices[i] >= prices[i-1]:
        ans += prices[i]
    return ans
return max_profit([1,2,3])
#+end_src

#+RESULTS:
: 0

#+begin_src python
from math import ceil
def max_profit(prices):
    trend = []
    for i in range(1, len(prices)):
        if prices[i] > prices[i-1]:
            trend.append(1)
        elif prices[i] == prices[i-1]:
            trend.append(0)
        else:
            trend.append(-1)

    profit = 0
    for i in range(len(trend)-1):
        if i == 0 and trend[i] == 1:
            profit -= prices[0]
        else:
            if trend[i] < trend[i+1]:
                profit -= prices[ceil((i+i+1)/2)]
            elif trend[i] == trend[i+1]:
                continue
            else:
                profit += prices[ceil((i+i+1)/2)]
        return profit
    if trend[-1] == 1:
        profit += prices[-1]
    return profit
return max_profit([6,1,3,2,2,4,7])
#+end_src

#+RESULTS:
: -1

****** Complexity
Time complexity:

Space complexity: 

***** Thoughts
This is actually a question similar to [[942 DI string match]]. We can construct a trend from the given data.

The problem with me not able to /implement/ it is that I did not clear my head before I sat down and coded.

Trial and error is not great when doing coding. Figure it out logically is the key.
If I had the graph of the trend, I could have solved it with so much less time.
****** Leetcode solution
$TotalProfit=\sum_i (height(peak_i) - height(valley_i))$ (I got the similar diea).
#+name: 122 Best time to buy and sell stock 2 leetcode solution
#+caption: 122 Best time to buy and sell stock 2 leetcode solution
#+begin_src python
def max_profit(prices):
    valley = prices[0]
    peak = prices[0]
    profit = 0
    i = 0

    while (i < len(prices) - 1):
        while (i < len(prices) - 1 and prices[i]>=prices[i+1]):
            i += 1
            valley = prices[i]
        while (i < len(prices) - 1 and prices[i] <= prices[i+1]):
            i += 1

        peak = prices[i]
        profit += peak-valley
    return profit
return max_profit([6,1,3,2,4,7])
#+end_src

#+RESULTS: 122 Best time to buy and sell stock 2 leetcode solution
: 7

Time complexity:
$O(N)$

Space complexity: 
$O(N)$

**** DONE 538 Convert BST to Greater Tree
***** Basic info
Given a BST, convert it to a Greater Tree such that every key of the original BST is changed to the original key plus sum of all keys greater than the original key in BST.

****** Examples:
#+name: 538 Convert BST to Greater Tree example
#+caption: 538 Convert BST to Greater Tree example
#+begin_example
Input: The root of a Binary Search Tree like this:
              5
            /   \
           2     13

Output: The root of a Greater Tree like this:
             18
            /   \
          20     13
#+end_example

***** Tackling process
:LOGBOOK:
CLOCK: [2019-12-10 Tue 15:32]--[2019-12-10 Tue 15:52] =>  0:20
:END:

The original question can be described as follows:
Given a BST, for each node of it, we need to set the value of node $n$: $vn$ such that $vn_{new}=vn_{old} + \sum(v-of-nodes-to-the-right-of-n)$.
To do this we need to use Inorder Traversal (a node is visited after its left subtree and before its right subtree).
****** Algorithm
:LOGBOOK:
CLOCK: [2019-12-10 Tue 15:52]--[2019-12-10 Tue 15:58] =>  0:06
:END:
We first convert this BST to an array and while doing so, for each new element added to the array, we also add it to the existing elements of the array and replace the old elements
with the new sum.

For example, for the tree from [[538 Convert BST to Greater Tree example]].
| nil | nil | nil |
|   2 | nil | nil |
|   7 |   5 | nil |
|  20 |  18 | 13  |

We finally return the original root node.
****** Code
:LOGBOOK:
CLOCK: [2019-12-10 Tue 20:01]--[2019-12-10 Tue 20:48] =>  0:47
:END:
#+name: 538 Convert BST to Greater Tree my solution
#+caption: 538 Convert BST to Greater Tree my solution
#+begin_src ein-python :session localhost :results output code 
from typing import List

# Definition for a binary tree node.
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None
def convertBST(root: TreeNode)->TreeNode:
    ans = []
    def inorder(node: TreeNode) -> None:
        if node is not None:
            inorder(node.left)
            # fixme: need to make this faster
            # it turns out we can traverse the right subtree first
            # to avoid this loop
            for x in ans:
                x.val += node.val
                ans.append(node)
                inorder(node.right)

    inorder(root)
    return root
root = TreeNode(5)
left = TreeNode(2)
right = TreeNode(13)
root.left = left
root.right = right
new_root = convertBST(root)
print(new_root.val, left.val, right.val)
#+end_src

#+RESULTS: 538 Convert BST to Greater Tree my solution
#+begin_src none
18 20 13
#+end_src

#+caption: 538 Convert BST to Greater Tree my solution 2
#+name: 538 Convert BST to Greater Tree my solution 2
#+begin_src ein-python :session localhost :results output code 
from typing import List

# Definition for a binary tree node.
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def convertBST(root:TreeNode) -> TreeNode:
    running_total = 0

    def inorder(node:TreeNode) -> None:
        nonlocal running_total
        if node is not None:
            inorder(node.right)
            running_total += node.val
            node.val = running_total
            inorder(node.left)

    inorder(root)
    return root
root = TreeNode(5)
left = TreeNode(2)
right = TreeNode(13)
root.left = left
root.right = right
new_root = convertBST(root)
print(new_root.val, left.val, right.val)
#+end_src

#+RESULTS: 538 Convert BST to Greater Tree my solution 2
#+begin_src none
18 20 13
#+end_src

****** Complexity
Time complexity:

$O(N)$.

Space complexity: 

$O(N)$. We need a stack to store pending operations.
***** Thoughts


****** Leetcode solution
:LOGBOOK:
CLOCK: [2019-12-10 Tue 21:55]--[2019-12-10 Tue 22:15] =>  0:20
:END:
The [[538 Convert BST to Greater Tree my solution 2]] was basically a copy of the leetcode recursive solution, so the actual recursive solution will not be added here.
I'll only include the iterative solution with a stack.
Then I'll document some ~nonlocal~, ~global~ information.
#+name: 538 Convert BST to Greater Tree leetcode solution
#+caption: 538 Convert BST to Greater Tree leetcode solution
#+begin_src ein-python :session localhost :results output code 
class Solution:
    def convertBST(self, root):
        total = 0

        node = root
        stack = []
        while stack or node is not None:
            # push all nodes up to (and including) this subtree's maximum on
            # the stack
            while node is not None:
                stack.append(node)
                node = node.right

            # this pop is quite complicated
            node = stack.pop()
            total += node.val
            node.val = total

            # all nodes with values between the current and its parent lie in the
            # left subtree.
            node = node.left

        return root
#+end_src

#+caption: test-empty-list
#+name: test-empty-list
#+begin_src ein-python :session localhost :results output code 
stack = []
print(len(stack))
while stack:
    print(len(stack))
    break
#+end_src

#+RESULTS: test-empty-list
#+begin_src none
0
#+end_src

#+caption: test-empty-list-results
Time complexity:

Space complexity: 

**** DONE 606 Construct String from Binary Tree
***** Basic info
You need to construct a string consisting of parenthesis and integers from a binary tree using 
preorder traversal.

****** Examples:
#+name: 606 Construct String from Binary Tree example
#+caption: 606 Construct String from Binary Tree example
#+begin_example
Input: Binary tree: [1,2,3,4]
       1
     /   \
    2     3
   /    
  4     

Output: "1(2(4))(3)"

Explanation: Originallay it needs to be "1(2(4)())(3()())", 
but you need to omit all the unnecessary empty parenthesis pairs. 
And it will be "1(2(4))(3)".

Input: Binary tree: [1,2,3,null,4]
       1
     /   \
    2     3
     \  
      4 

Output: "1(2()(4))(3)"

Explanation: Almost the same as the first example, 
except we can't omit the first parenthesis pair to break the one-to-one mapping relationship between the input and the output.
#+end_example

***** Tackling process

****** Algorithm
:LOGBOOK:
CLOCK: [2019-12-11 Wed 14:37]--[2019-12-11 Wed 14:40] =>  0:03
:END:
We need to use preorder traversal.
We need to parenthsize all nodes lower than the root node.
We need to remove parenthesis around an *empty left node*.

****** Code
:LOGBOOK:
CLOCK: [2019-12-11 Wed 14:40]--[2019-12-11 Wed 15:12] =>  0:32
:END:
#+name: 606 Construct String from Binary Tree my solution
#+caption: 606 Construct String from Binary Tree my solution
#+begin_src ein-python :session localhost :results output code 
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def tree2str(t: TreeNode) -> str:
    ans = ""
    def preorder(node: TreeNode) -> None:
        nonlocal ans
        if node is not None:
            # 2
            ans += str(node.val)
            # if node.left then we must have (node.left.val) or (node.left.val)(node.right.val)
            # if node.right then we must have (node.left.val)(node.right.val) or ()(node.right.val)
            if node.left or node.right:
                # 2(
                ans += "("
                preorder(node.left)
                # 2()
                ans += ")"
                # 2()(
                if node.right:
                    ans += "("
                    preorder(node.right)
                    # 2()(4)
                    ans += ")"
                    preorder(t)
    return ans
root = TreeNode(1)
left = TreeNode(2)
right = TreeNode(3)
lower_r =TreeNode(4) 
root.left = left
root.right = right
left.left = None
left.right = lower_r
ans = tree2str(root)
print(ans)
#+end_src

#+RESULTS: 606 Construct String from Binary Tree my solution
#+begin_src none
1(2()(4))(3)
#+end_src

****** Complexity
Time complexity:

$O(N)$.

Space complexity: 

$O(N)$.
***** Thoughts
Not too much to say about it. More just another practice of Traversal of Trees.

****** Leetcode solution
Not included.
#+name: 606 Construct String from Binary Tree leetcode solution
#+caption: 606 Construct String from Binary Tree leetcode solution
#+begin_src python

#+end_src

Time complexity:

Space complexity: 

**** DONE 733 Flood Fill
***** Basic info
An image is represented by a 2d array of integers, each integer representing the pixel value of the image (0 to 65535).

Given a coordinate (sr, sc) representing the starting pixel (row and column) of the flood fill,
and a pixel value ~newColor~, "flood fill" the image.

To perform a "flood fill", consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel
of the same color as the starting pixel, plus any pixels connected 4 directionally to those pixels (also with the same color as the starting pixel),
and so on. Replace the color of all of the aformentioned pixels with the ~newColor~.

****** Examples:
#+name: 733 Flood Fill example
#+caption: 733 Flood Fill example
#+begin_example
Input: 
image = [[1,1,1],[1,1,0],[1,0,1]]
|1|1|1|
|1|1|0|
|1|0|1|
sr = 1, sc = 1, newColor = 2
Output: [[2,2,2],[2,2,0],[2,0,1]]
Explanation: 
From the center of the image (with position (sr, sc) = (1, 1)), all pixels connected 
by a path of the same color as the starting pixel are colored with the new color.
Note the bottom corner is not colored 2, because it is not 4-directionally connected
to the starting pixel.
#+end_example

***** Tackling process
:LOGBOOK:
CLOCK: [2019-12-11 Wed 15:24]--[2019-12-11 Wed 15:28] =>  0:04
:END:
Starting from the starting point $s$, we need to find it's neighbours at 4 directions (N, E, S, W),
and check each point's pixel value, it it is the same as the $s$, then we need to color it with ~newColor~.
We should be able to do this recursively.
****** Algorithm
:LOGBOOK:
CLOCK: [2019-12-11 Wed 15:24]--[2019-12-11 Wed 15:24] =>  0:00
:END:
for any point $p$, we get its neighbours' coordinates and then check if they have the same color as the $s$.
If yes, we color it with the new color, and check its neighbours.
If no, we do nothing.
****** Code
:LOGBOOK:
CLOCK: [2019-12-11 Wed 15:29]--[2019-12-11 Wed 15:56] =>  0:27
:END:
#+caption: boolean-test
#+name: boolean-test
#+begin_src ein-python :session localhost :results output code 
print((-1 < 0 < 1) and (-1 < 1 < 2))
#+end_src

#+RESULTS: boolean-test
#+begin_src none
True
#+end_src


#+name: 733 Flood Fill my solution
#+caption: 733 Flood Fill my solution
#+begin_src ein-python :session localhost :results output code
from typing import List, Tuple

def floodFill(image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:
    old_color = image[sr][sc]
    def color_points(sr: int, sc: int) -> None:
        def valid_coord(image: List[List[int]], coord: Tuple) -> bool:
            rows = len(image)
            cols = len(image[0])
            return (-1 < coord[0] < rows) and (-1 < coord[1] < cols)
        image[sr][sc] = newColor
        # northern neighbour
        nn = (sr-1, sc)
        sn = (sr+1, sc)
        en = (sr, sc+1)
        wn = (sr, sc-1)
        neighbours = (nn, sn, en, wn)
        for n in neighbours:
            if valid_coord(image, n) and image[n[0]][n[1]] == old_color:
                color_points(n[0], n[1])
                # image = [[0,0,0],[0,1,1]]
                # new_img = floodFill(image, sr=1, sc=1, newColor=1)
                # to avoid the above situation
                # we need to check the color first
                # it is guaranteed that if image[sr][sc] != newColor
                # the image is already flood filled
    if image[sr][sc] != newColor:
        color_points(sr, sc)
    return image
image = [[0,0,0],[0,1,1]]
new_img = floodFill(image, sr=1, sc=1, newColor=1)
print(new_img)
#+end_src

#+RESULTS: 733 Flood Fill my solution
#+begin_src none
[[0, 0, 0], [0, 1, 1]]
#+end_src

****** Complexity
Time complexity:

$O(N)$

Space complexity: 

$O(N)$
***** Thoughts
My solution is DFS like the one provided by leetcode.

****** Leetcode solution

#+name: 733 Flood Fill leetcode solution
#+caption: 733 Flood Fill leetcode solution
#+begin_src ein-python :session localhost :results output code

#+end_src

Time complexity:

Space complexity: 

**** DONE 461 Hamming distance
***** Basic info
:LOGBOOK:
CLOCK: [2020-01-27 Mon 09:22]--[2020-01-27 Mon 09:29] =>  0:07
:END:
The [[https://en.wikipedia.org/wiki/Hamming_distance][Hamming distance]] between two integers is the number of positions at which the corresponding bits are different.
Given two integers x and y, calculate the Hamming distance.
$0 \leq x, y < 2^{31}$
****** Examples:
#+name: 461 Hamming distance example
#+caption: 461 Hamming distance example
#+begin_example
Input: x = 1, y = 4

Output: 2

Explanation:
1   (0 0 0 1)
4   (0 1 0 0)
          

The above arrows point to positions where the corresponding bits are different.
#+end_example

***** Tackling process
:LOGBOOK:
CLOCK: [2020-01-27 Mon 09:30]--[2020-01-27 Mon 10:26] =>  0:56
:END:

****** Algorithm
1. Convert the numbers to binary sx and sy
2. Loop i from -1, -2, -3... until the starting bit of the longest number
3. Compare sx[i] and sy[i]
4. If sx[i] gives an error, treat it like a zero
5. Dont' stop until sx[i] and sy[i] both give an error
****** Code
#+name: 461 Hamming distance my solution
#+caption: 461 Hamming distance my solution
#+begin_src ein-python :session localhost :results output code
def hamming_distance(x: int, y: int) -> int:
    sx = bin(x)[2:]
    sy = bin(y)[2:]

    if len(sx) >= len(sy):
        outer = sx
        inner = sy
    else:
        outer = sy
        inner = sx

    count = 0
    for i in range(-1, -1 * (len(outer)+1), -1):
        try:
            count += (1 if int(outer[i]) ^ int(inner[i]) else 0)
        except IndexError:
            count += int(outer[i])
            
    return count

hamming_distance(93,73)
#+end_src

#+RESULTS: 461 Hamming distance my solution
#+begin_src none
2
#+end_src

#+caption: hamming-test
#+name: hamming-test
#+begin_src ein-python :session localhost :results output code 
bin(93)
bin(73)
#+end_src

#+RESULTS: hamming-test
#+begin_src none
'0b1001001'
#+end_src

#+caption: hamming-test-results
****** Complexity
Lengths of the numbers are limited.

Time complexity:

$O(1)$

Space complexity: 

$O(1)$

***** Thoughts
:LOGBOOK:
CLOCK: [2020-01-27 Mon 10:47]--[2020-01-27 Mon 10:52] =>  0:05
:END:
This initial solution did not take care of the addition carry.

#+name: 461 Hamming distance initial solution
#+caption: 461 Hamming distance initial solution
#+begin_src ein-python :session localhost :results output code
def hamming_distance(x: int, y: int) -> int:
    return bin(x+y).count("1")
#+end_src

****** Leetcode solution

#+name: 461 Hamming distance leetcode solution
#+caption: 461 Hamming distance leetcode solution
#+begin_src ein-python :session localhost :results output code
def hamming_distance(x: int, y: int) -> int:
    return bin(x^y).count("1")
hamming_distance(93, 73)
#+end_src

#+RESULTS: 461 Hamming distance leetcode solution
#+begin_src none
2
#+end_src

Time complexity:

$O(1)$

Space complexity: 

$O(1)$

**** DONE 485 Max consecutive ones
***** Basic info
:LOGBOOK:
CLOCK: [2020-01-27 Mon 11:21]--[2020-01-27 Mon 11:21] =>  0:00
:END:
Given a binary array, find the maximum number of consecutive 1's in this array.

****** Examples:
#+name: 485 Max consecutive ones example
#+caption: 485 Max consecutive ones example
#+begin_example
Input: [1,1,0,1,1,1]
Output: 3
Explanation: The first two digits or the last three digits are consecutive 1s.
    The maximum number of consecutive 1s is 3.
#+end_example

***** Tackling process
:LOGBOOK:
CLOCK: [2020-01-27 Mon 11:21]--[2020-01-27 Mon 11:34] =>  0:13
:END:

****** Algorithm
1. Loop through the list
2. Count the number of consecutive 1's
3. If the loop encounters a 0, compare counter with max_count, and reset counter
****** Code
#+name: 485 Max consecutive ones my solution
#+caption: 485 Max consecutive ones my solution
#+begin_src ein-python :session localhost :results output code
def find_max_consecutive_ones(nums) -> int:
    max_c = 0
    counter = 0
    for num in nums:
        if num == 0:
            max_c = max(max_c, counter)
            counter = 0
        else:
            counter += num
            max_c = max(counter, max_c)
    return max_c
find_max_consecutive_ones([1])
#+end_src

#+RESULTS: 485 Max consecutive ones my solution
#+begin_src none
1
#+end_src

****** Complexity
Time complexity:

Extreme case: $N/2$ number of 1's followed by one 0, [1,1,1,1,0,1,1,1]
$O(N)$. We have to at least check $N/2$ number of elements.

Space complexity: 

$O(1)$
***** Thoughts
Simple and intuitive solution.

****** Leetcode solution
Not available.

#+name: 485 Max consecutive ones leetcode solution
#+caption: 485 Max consecutive ones leetcode solution
#+begin_src ein-python :session localhost :results output code

#+end_src

Time complexity:

Space complexity: 

**** DONE 108 Convert sorted array to binary search tree
***** Basic info
:LOGBOOK:
CLOCK: [2020-01-31 Fri 09:57]--[2020-01-31 Fri 10:03] =>  0:06
:END:
Given an array where elements are sorted in ascending order, convert it to a height balanced BST.

For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the
two subtrees of /every/ node never differ by more than 1.
****** Examples:
#+name: 108 Convert sorted array to binary search tree example
#+caption: 108 Convert sorted array to binary search tree example
#+begin_example
Given the sorted array: [-10,-3,0,5,9],

One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:

      0
     / \
   -3   9
   /   /
 -10  5
#+end_example

***** Tackling process
:LOGBOOK:
CLOCK: [2020-01-31 Fri 10:06]--[2020-01-31 Fri 10:41] =>  0:35
:END:

****** Algorithm

We use the middle point as the root of the tree, then its two nodes are its two neighbouring sub lists in the list.
Then we do the same for the sub lists, until we don't have any sub lists.
****** Code
#+name: 108 Convert sorted array to binary search tree my solution
#+caption: 108 Convert sorted array to binary search tree my solution
#+begin_src ein-python :session localhost :results output code
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def sorted_array_to_BST(nums) -> TreeNode:
    def bst_helper(lst, left, right):
        if left >= right: return None
        mid = (left + right) // 2
        node = TreeNode(lst[mid])
        node.left = bst_helper(lst, left, mid)
        node.right = bst_helper(lst, mid+1, right)
        return node
    return bst_helper(nums, 0, len(nums))
sorted_array_to_BST([-10, -3, 0, 5, 9]).left.left.val
#+end_src

#+RESULTS: 108 Convert sorted array to binary search tree my solution
#+begin_src none
-10
#+end_src

****** Complexity
Time complexity:

$O(N)$. We only examine each element once.

Space complexity: 

$O(N)$ for the stack used in recursion.
***** Thoughts
:LOGBOOK:
CLOCK: [2020-01-31 Fri 10:46]--[2020-01-31 Fri 10:58] =>  0:12
:END:
Can't believe that I did not have any idea how to do it in the first place.
I had to check other people's submissions to know how to do this.

This is basically a simple recursive questions that traverses from the middle of
the list to both ends.

****** Leetcode solution
Not available.
#+name: 108 Convert sorted array to binary search tree leetcode solution
#+caption: 108 Convert sorted array to binary search tree leetcode solution
#+begin_src ein-python :session localhost :results output code

#+end_src

Time complexity:

Space complexity: 

**** DONE 697 Degree of an array
***** Basic info
:LOGBOOK:
CLOCK: [2020-01-31 Fri 15:36]--[2020-01-31 Fri 15:39] =>  0:03
:END:
given a non-empty array of non-negative integers ~nums~, the *degree* of this array is defined 
as the maximum frequency of any one of its elements.

Your task is to find the smallest possible length of a (contiguous) subarray of ~nums~, that has the 
same degree as ~nums~.


****** Examples:
#+name: 697 Degree of an array example
#+caption: 697 Degree of an array example
#+begin_example
Input: [1, 2, 2, 3, 1]
Output: 2
Explanation: 
The input array has a degree of 2 because both elements 1 and 2 appear twice.
Of the subarrays that have the same degree:
[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]
The shortest length is 2. So return 2.

Input: [1,2,2,3,1,4,2]
Output: 6
#+end_example

***** Tackling process
:LOGBOOK:
CLOCK: [2020-01-31 Fri 15:39]--[2020-01-31 Fri 16:21] =>  0:42
:END:

****** Algorithm
1. Iterate the ~nums~ list.
2. Record the number of appearances of every element.
3. Calculate the distance between each number and its first position(index).
4. Get the degree from number of appearances.
5. Get the numbers ~nums_meet~ that meet the degree threshold.
6. Get the distances ~dis_meet~ of ~nums_meet~.
7. Get the smallest distance.

****** Code
#+name: 697 Degree of an array my solution
#+caption: 697 Degree of an array my solution
#+begin_src ein-python :session localhost :results output code
def find_shortest_sub_array(nums) -> int:
    counter = {}
    distances = {}
    first_pos = {}

    # O(N)
    for i, n in enumerate(nums):
        counter[n] = counter.get(n, 0) + 1
        # O(N)
        if not n in first_pos.keys():
            first_pos[n] = i
            distances[n] = i - first_pos[n]
            # O(NlogN)
    degrees = sorted(counter.items(), key=lambda item: item[1], reverse=True)

    # O(N)
    nums_meet = [degree[0] if degree[1]==degrees[0][1] for degree in degrees]
    min_sub = 50000
    # O(N)
    for n, dis in distances.items():
        if n in nums_meet:
            if dis < min_sub:
                min_sub = dis + 1

    return min_sub
find_shortest_sub_array([1,2,2,3,1])
#+end_src

#+RESULTS: 697 Degree of an array my solution
#+begin_src ein-python
[....]
#+end_src

****** Complexity
Time complexity:

$O(N^2)$

Space complexity: 

$O(N)$
***** Thoughts
This should be a fairly easy question and my algorithm is quite straightforward.

Implementing the algorithm took a while because at one point I lost track in the code and 
did not refer back to the written algorithm.

It'd be better to specify important variables in the algorithm and them try to define them
in the code as soon as possible so that they can also serve as a reminder of what I am doing.

****** Leetcode solution
:LOGBOOK:
CLOCK: [2020-01-31 Fri 16:32]--[2020-01-31 Fri 16:40] =>  0:08
:END:

An array that has degree ~d~, must have some element ~x~ occuring ~d~ times.
If some subarray has the same degree, then some element ~x~ that occured ~d~ times, still occured 
~d~ times in the subarray. The shortest such subarray would be from the first occurrence of ~x~
until the last occurrence.

For each element in the given array, let's know ~left~, the index of its first occurrence; and 
~right~, the index of its last occurrence. For example, with ~nums = [1,2,3,2,5]~, we have 
~left[2] == 1~ and ~right[2]==3~.

Then, for each element ~x~ that occurs the maximum number of times, ~right[x] - left[x] + 1~ 
will be our candidate answer, and we'll take the minimum of those candidates.
#+name: 697 Degree of an array leetcode solution
#+caption: 697 Degree of an array leetcode solution
#+begin_src ein-python :session localhost :results output code
def find_shortest_sub_array(nums):
    left, right, count = {}, {}, {}

    for i, x in enumerate(nums):
        if x not in left: left[x] = i
        right[x] = i
        count[x] = count.get(x, 0) + 1

    ans = len(nums)
    degree = max(count.values())
    for x in count:
        if count[x] == degree:
            ans = min(ans, right[x] - left[x] + 1)

    return ans
#+end_src

Time complexity:

$O(N)$

Space complexity: 

$O(N)$
**** DONE 167 Two sum II - Input array is sorted
#+BEGIN: clocktable :scope subtree :maxlevel 5
#+CAPTION: Clock summary at [2020-02-01 Sat 12:05]
| Headline                                       | Time   |   |   |      |      |
|------------------------------------------------+--------+---+---+------+------|
| *Total time*                                   | *0:27* |   |   |      |      |
|------------------------------------------------+--------+---+---+------+------|
| \_      167 Two sum II - Input array is sorted |        |   |   | 0:27 |      |
| \_        Basic info                           |        |   |   |      | 0:03 |
| \_        Tackling process                     |        |   |   |      | 0:24 |
#+END:

***** Basic info
:LOGBOOK:
CLOCK: [2020-02-01 Sat 11:37]--[2020-02-01 Sat 11:40] =>  0:03
:END:
Given an array of integers ~nums~ that is already sorted in ascending order, find two numbers such that they add up to a specific target number.

The functin twoSum should return indices of the two numbers such that they add up to the ~target~, where ~index1~ must be less than ~index2~.

1. Your returned answers (both ~index1~ and ~index2~) are not zero-based.
2. You may assume that each input would have /exactly/ one solution and you may not use the /same/ element twice.
****** Examples:
#+name: 167 Two sum II - Input array is sorted example
#+caption: 167 Two sum II - Input array is sorted example
#+begin_example
Input: numbers = [2,7,11,15], target = 9
Output: [1,2]
Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2.
#+end_example

***** Tackling process
:LOGBOOK:
CLOCK: [2020-02-01 Sat 11:40]--[2020-02-01 Sat 11:53] =>  0:13
:END:

****** Algorithm
1. Because the question has exactly one answer, then $target \in [nums[0] + nums[1], nums[-2] + nums[-1]]$.
2. We loop through ~nums~ and get element ~ele~ and index ~i~.
3. For each ~ele~, we get a possible answer ~pos_ans~, where ~pos_ans=target-ele~.
4. +If ~pos_ans <ele~, continue to the next element, because this is a sorted list.+
5. We also record ~pos_ans~'s index ~i~ so we get a dict ~pos_anses~
6. For each ~ele~, we also check if it is already in ~pos_anses~, if so, return ~pos_anses[ele]~ and ~i~.
****** Code
:LOGBOOK:
CLOCK: [2020-02-01 Sat 11:53]--[2020-02-01 Sat 12:04] =>  0:11
:END:
#+name: 167 Two sum II - Input array is sorted my solution
#+caption: 167 Two sum II - Input array is sorted my solution
#+begin_src ein-python :session localhost :results output code
def two_sum(numbers, target):
    pos_anses = {}
    for i, ele in enumerate(numbers):
        if ele in pos_anses.keys():
            return [pos_anses[ele] + 1, i + 1]
        pos_ans = target - ele
        pos_anses[pos_ans] = i

two_sum([2,7,15,18], 9)
#+end_src

#+RESULTS: 167 Two sum II - Input array is sorted my solution
#+begin_src ein-python
[....]
#+end_src

****** Complexity
Time complexity:

$O(N)$.

Space complexity: 

$O(N)$.
***** Thoughts


****** Leetcode solution
Not available.
#+name: 167 Two sum II - Input array is sorted leetcode solution
#+caption: 167 Two sum II - Input array is sorted leetcode solution
#+begin_src ein-python :session localhost :results output code

#+end_src

Time complexity:

Space complexity: 

**** DONE 1342 Number of steps to Reduce a number to zero
***** Basic info
:LOGBOOK:
CLOCK: [2020-04-09 Thu 09:01]--[2020-04-09 Thu 09:04] =>  0:03
:END:
Given a non-negative integer ~num~, return the number of steps to reduce it to zero. If the current number is even, you have to divide it by 2, otherwise, you have to subtract 1 from it.

0 <= ~num~ <= 10^6
****** Examples:
#+name: 1342 Number of steps to Reduce a number to zero example
#+caption: 1342 Number of steps to Reduce a number to zero example
#+begin_example
Input: num = 14
Output: 6
Explanation: 
Step (1) 14 is even; divide by 2 and obtain 7. 
Step (2) 7 is odd; subtract 1 and obtain 6.
Step (3) 6 is even; divide by 2 and obtain 3. 
Step (4) 3 is odd; subtract 1 and obtain 2. 
Step (5) 2 is even; divide by 2 and obtain 1. 
Step (6) 1 is odd; subtract 1 and obtain 0.

Input: num = 8
Output: 4
Explanation: 
Step (1) 8 is even; divide by 2 and obtain 4. 
Step (2) 4 is even; divide by 2 and obtain 2. 
Step (3) 2 is even; divide by 2 and obtain 1. 
Step (4) 1 is odd; subtract 1 and obtain 0.

Input: num = 123
Output: 12
#+end_example

***** Tackling process

****** Algorithm
:LOGBOOK:
CLOCK: [2020-04-09 Thu 09:04]--[2020-04-09 Thu 09:13] =>  0:09
:END:
Recursion.

count = count + reduce(num), ~reduce(num) returns either 1(continue) or 0(stop)~.

****** Code
:LOGBOOK:
CLOCK: [2020-04-09 Thu 09:13]--[2020-04-09 Thu 09:26] =>  0:13
:END:
#+name: 1342 Number of steps to Reduce a number to zero my solution
#+caption: 1342 Number of steps to Reduce a number to zero my solution
#+begin_src ein-python :session localhost :results output code
def reduce(num):
    count = 0
    if num == 0:
        return 0

    # else
    division = num / 2

    if division == num // 2:
        count = 1 + reduce(division)
    else:
        count = 1 + reduce(num - 1)
    return count
reduce(10)
#+end_src

#+RESULTS: 1342 Number of steps to Reduce a number to zero my solution
#+begin_src none
5
#+end_src

****** Complexity
Time complexity:
$O(\sqrt{num})$

Space complexity: 
$O(\sqrt{num})$

***** Thoughts
:LOGBOOK:
CLOCK: [2020-04-09 Thu 09:28]--[2020-04-09 Thu 09:41] =>  0:13
:END:

Initially I wanted to convert the number to binary and see if there is some pattern, but failed to find the pattern.


****** Leetcode solution
Here is one solution using binary.

1. Convert the number to binary
   1. ~bin(123)[2:]~ $\rightarrow$ ~1111011~
2. Every 0 takes 1 step (except the last one), every 1 takes two steps
   1. ~[int(d) + 1 for d in bin(123)[2:]]~ \rightarrow$ ~[2,2,2,2,1,2,2]~
3. Sum it up and we do not need to operate on the last zero, so subtract one
   1. ~sum([int(d) + 1 for d in bin(123)[2:]]) - 1~ \rightarrow$ ~sum([2,2,2,2,1,2,2-1])~
#+name: 1342 Number of steps to Reduce a number to zero leetcode solution
#+caption: 1342 Number of steps to Reduce a number to zero leetcode solution
#+begin_src ein-python :session localhost :results output code
def numOfSteps(num: int) -> int:
    return sum([int(d) + 1 for d in bin(num)[2:]]) - 1
numOfSteps(8)
#+end_src

#+RESULTS: 1342 Number of steps to Reduce a number to zero leetcode solution
#+begin_src none
4
#+end_src

Time complexity:
$O(n)$, where ~n~ is the number of digits of ~num~ in binary.

Space complexity: 
$O(1)$, $num<10^{6}$.

**** DONE 709 To lower case
***** Basic info
:LOGBOOK:
CLOCK: [2020-04-09 Thu 10:14]--[2020-04-09 Thu 10:15] =>  0:01
:END:
Implement function ~toLowerCase()~ that has a string parameter ~str~, and returns the same string in lowercase.

****** Examples:
#+name: 709 To lower case example
#+caption: 709 To lower case example
#+begin_example
Input: "Hello"
Output: "hello"

Input: "here"
Output: "here"

Input: "LOVELY"
Output: "lovely"
#+end_example

***** Tackling process

****** Algorithm
Use python's ~str.lower()~?
****** Code
#+name: 709 To lower case my solution
#+caption: 709 To lower case my solution
#+begin_src ein-python :session localhost :results output code
def toLowerCase(string: str) -> str:
    return string.lower()
toLowerCase("Hello")
#+end_src

#+RESULTS: 709 To lower case my solution
#+begin_src none
'hello'
#+end_src

****** Complexity
Time complexity:
$O(N)$, where ~N~ is the length of the string.

Space complexity: 
$O(N)$, where ~N~ is the length of the string.

***** Thoughts
This problem is designed for other languages that does not have python's ~str.lower()~ function.

****** Leetcode solution

#+name: 709 To lower case leetcode solution
#+caption: 709 To lower case leetcode solution
#+begin_src ein-python :session localhost :results output code

#+end_src

Time complexity:

Space complexity: 

**** DONE 1394 Find lucky integer in an array
***** Basic info
:LOGBOOK:
CLOCK: [2020-04-09 Thu 10:54]--[2020-04-09 Thu 10:56] =>  0:02
:END:
Given an array of integers ~arr~, a lucky integer is an integer which has a frequency in the array equal to its value.

Return a lucky integer in the array. If there are multiple lucky integers return the /largest/ of them.
If there is no luck integer return -1.

Constraints:
1. ~1 <= arr.length <= 500~
2. ~1 <= arr[i] <= 500~
****** Examples:
#+name: 1394 Find lucky integer in an array example
#+caption: 1394 Find lucky integer in an array example
#+begin_example
Input: arr = [2,2,3,4]
Output: 2
Explanation: The only lucky number in the array is 2 because frequency[2] == 2.

Input: arr = [1,2,2,3,3,3]
Output: 3
Explanation: 1, 2 and 3 are all lucky numbers, return the largest of them.

Input: arr = [2,2,2,3,3]
Output: -1
Explanation: There are no lucky numbers in the array.
#+end_example

***** Tackling process
:LOGBOOK:
CLOCK: [2020-04-09 Thu 11:26]--[2020-04-09 Thu 11:28] =>  0:02
CLOCK: [2020-04-09 Thu 10:57]--[2020-04-09 Thu 11:21] =>  0:24
:END:

****** Algorithm
We must count the number of occurrence of all elements in the array.
Can map their total number of occurrence to the element.

We can have one ~lucky~ that contains all elements that are lucky numbers,
another ~candidate~ that contains elements that haven't made it to ~lucky~,
and one last ~dropout~ that contains elemnts that dropped out from ~lucky~.

When scanning the original ~arr~, we check if the current integer is in ~lucky~, if so, 
move the integer out from lucky to ~dropout~. If not, check if it's in ~candidate~, if so, 
add one to the number of occurrence in ~candidate~, then check if it makes to ~lucky~,
if so, move it from ~candidate~ to ~luckt~. If element is not in ~candidate~, scan next.

We then sort the keys in ~lucky~ and get the largest lucky number if it exists.
****** Code
#+name: 1394 Find lucky integer in an array my solution
#+caption: 1394 Find lucky integer in an array my solution
#+begin_src ein-python :session localhost :results output code
from typing import List

def findLucky(arr: List[int]) -> int:
    lucky = []
    candidate = {}
    dropout = [] # once an integer is in dropout, we don't care about its count of occurrence

    for i in arr:
        if i in lucky:
            dropout.append(i)
            lucky.remove(i)
            continue

        if not i in dropout:
            new_count = candidate.get(i, 0) + 1
            if new_count == i:
                lucky.append(i)
                candidate.pop(i, None) # Give a default value if i is not in candidate
            else:
                candidate[i] = new_count
            continue

    return sorted(lucky, reverse=True)[0] if len(lucky) > 0 else -1
findLucky([2,2,3, 3, 3])
#+end_src

#+RESULTS: 1394 Find lucky integer in an array my solution
#+begin_src none
3
#+end_src

****** Complexity
Time complexity:
$O(NlogN)$ worst case senario when all numbers are lucky numbers.
~sorted()~ time complexity is $O(NlogN)$.
~list.remove()~ and ~dict.pop()~ should all take $O(1)$ time.

Space complexity: 

$O(N)$.

***** Thoughts


****** Leetcode solution

#+name: 1394 Find lucky integer in an array leetcode solution
#+caption: 1394 Find lucky integer in an array leetcode solution
#+begin_src ein-python :session localhost :results output code

#+end_src

Time complexity:

Space complexity: 

**** DONE 1337 The K weakest rows in a matrix
***** Basic info
:LOGBOOK:
CLOCK: [2020-04-09 Thu 13:34]--[2020-04-09 Thu 13:39] =>  0:05
:END:
Given a ~m*n~ matrix ~mat~ of 1's (representing soldiers) and 0's (representing civilians), 
return the indexes of the ~k~ weakest rows in the matrix ordered from the weakest to the strongest.

A row ~i~ is weaker than row ~j~, if the number of soldiers in row ~i~ is less than the number of 
soldiers in row ~j~, or they have the same number of soldiers but ~i~ is less than ~j~. Soldiers 
*always* stand in the frontier of a row. That is, 1's always appear first in a row.

****** Examples:
#+name: 1337 The K weakest rows in a matrix example
#+caption: 1337 The K weakest rows in a matrix example
#+begin_example
Input: mat = 
[[1,1,0,0,0],
 [1,1,1,1,0],
 [1,0,0,0,0],
 [1,1,0,0,0],
 [1,1,1,1,1]], 
k = 3
Output: [2,0,3]
Explanation: 
The number of soldiers for each row is: 
row 0 -> 2 
row 1 -> 4 
row 2 -> 1 
row 3 -> 2 
row 4 -> 5 
Rows ordered from the weakest to the strongest are [2,0,3,1,4]

Input: mat = 
[[1,0,0,0],
 [1,1,1,1],
 [1,0,0,0],
 [1,0,0,0]], 
k = 2
Output: [0,2]
Explanation: 
The number of soldiers for each row is: 
row 0 -> 1 
row 1 -> 4 
row 2 -> 1 
row 3 -> 1 
Rows ordered from the weakest to the strongest are [0,2,3,1]
#+end_example
***** Tackling process
:LOGBOOK:
CLOCK: [2020-04-09 Thu 13:39]--[2020-04-09 Thu 13:51] =>  0:12
:END:

****** Algorithm
We must scan all elements in ~mat~ to count the weakness of each row.
We store the row index ~i~ and its number of soldiers ~n~ in a map ~strongness~.
We then sort ~strongness~ by ~n~.
We then get the first ~k~ indexes from ~strongness~.
****** Code
#+name: 1337 The K weakest rows in a matrix my solution
#+caption: 1337 The K weakest rows in a matrix my solution
#+begin_src ein-python :session localhost :results output code
from typing import List

def kWeakestRows(mat: List[List[int]], k: int) -> List[int]:
    strongness = {}
    for i, row in enumerate(mat):
        strongness[i] = strongness.get(i, 0) + sum(row)
        sorted_strongness = sorted(strongness, key= lambda x: strongness[x])

    return sorted_strongness[:k]
kWeakestRows([[1,1,1,0], [1,1,1,1], [1,1,0,0]], 2)
#+end_src

#+RESULTS: 1337 The K weakest rows in a matrix my solution
#+begin_src none
[2, 0]
#+end_src

****** Complexity
Time complexity:
$O(NlogN)$ where $N$ is the number of rows in the matrix.

Space complexity: 
$O(N)$, where $N$ is the number of rows in the matrix.

***** Thoughts
Easy question.
Leetcode solution seems to be unavailable now.
****** Leetcode solution

#+name: 1337 The K weakest rows in a matrix leetcode solution
#+caption: 1337 The K weakest rows in a matrix leetcode solution
#+begin_src ein-python :session localhost :results output code

#+end_src

Time complexity:

Space complexity: 

**** DONE 344 Reverse String
***** Basic info
:LOGBOOK:
CLOCK: [2020-04-09 Thu 14:05]--[2020-04-09 Thu 14:08] =>  0:03
:END:
Write a function that reverses a string. The input string is given as an array of characters ~char[]~.

Do not allocate extra space for another array, you must do this by *modifying the input array* in-place
with $O(1)$ extra memory.

You may assume that all the charachters consist of /[[https://en.wikipedia.org/wiki/ASCII#Printable_characters][printable ascii characters]]/.

Printable ASCII characters: 32(dec) to 126(dec).
****** Examples:
#+name: 344 Reverse String example
#+caption: 344 Reverse String example
#+begin_example
Example 1:

Input: ["h","e","l","l","o"]
Output: ["o","l","l","e","h"]


Example 2:

Input: ["H","a","n","n","a","h"]
Output: ["h","a","n","n","a","H"]

#+end_example

***** Tackling process
:LOGBOOK:
CLOCK: [2020-04-09 Thu 14:09]--[2020-04-09 Thu 14:18] =>  0:09
:END:

****** Algorithm
We loop through ~s~ till index ~i == ceil(len(s)/2)~.
Let ~c=s[i]~, then ~s[i] = s[len(s) - 1 - i]~, then ~s[len(s) - 1 - i] = c~.
****** Code
#+name: 344 Reverse String my solution
#+caption: 344 Reverse String my solution
#+begin_src ein-python :session localhost :results output code
from typing import List

def reverseString(s: List[str]) -> None:
    length = len(s)
    
    for i in range(length // 2 + length % 2):
        c = s[i]
        s[i] = s[length - 1 - i]
        s[length - 1 - i] = c
        
    return s
reverseString(["H", "e", "d"])
#+end_src

#+RESULTS: 344 Reverse String my solution
#+begin_src none
['d', 'e', 'H']
#+end_src

****** Complexity
Time complexity:
$O(N)$, where $N$ is the length of the list.

Space complexity: 
$O(1)$.

***** Thoughts
Not a hard question, but my algorithm can be simplified by eliminating the need to calculate ~length//2~.

****** Leetcode solution

Two pointer solution.
#+name: 344 Reverse String leetcode solution
#+caption: 344 Reverse String leetcode solution
#+begin_src ein-python :session localhost :results output code
def reverseString(s):
    left, right = 0, len(s) - 1
    while left < right:
        s[left], s[right] = s[right], s[left] # this can happen without a temporary variable
        left, right = left + 1, right - 1
        
#+end_src

Time complexity:
$O(N)$, where $N$ is the length of the list.

Space complexity: 
$O(1)$.

Recursion, but this takes $O(N)$ space.
#+name: 344 Reverse String leetcode solution 2
#+caption: 344 Reverse String leetcode solution 2
#+begin_src ein-python :session localhost :results output code
def reverseString(s):
    def helper(left, right):
        if left < right:
            s[left], s[right] = s[right], s[left]
            helper(left + 1, right - 1)
            helper(0, len(s) - 1)
            
#+end_src
Time complexity:
$O(N)$, where $N$ is the length of the list.

Space complexity: 
$O(N)$, where $N$ is the length of the list.

**** DONE 476 Number complement
***** Basic info
:LOGBOOK:
CLOCK: [2020-04-09 Thu 14:44]--[2020-04-09 Thu 14:46] =>  0:02
:END:
Given a positive integer, output its complement number.
The complement strategy is to flip the bits of its binary representation.

Notes:
1. The given integer is guaranteed to fit within the range of a 32-bit signed integer.
2. You could assume no leading zero bit in the integers binary representation.
3. This question is the same as 1009: https://leetcode.com/problems/complement-of-base-10-integer/
****** Examples:
#+name: 476 Number complement example
#+caption: 476 Number complement example
#+begin_example
Input: 5
Output: 2
Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.

Input: 1
Output: 0
Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.
#+end_example

***** Tackling process
:LOGBOOK:
CLOCK: [2020-04-09 Thu 14:46]--[2020-04-09 Thu 14:54] =>  0:08
:END:

****** Algorithm
We get the binary representation of ~num~ as ~b_num~.
We then flip each digit in ~b_num~.
Output decimal representation of ~b_num~.
****** Code
#+name: 476 Number complement my solution
#+caption: 476 Number complement my solution
#+begin_src ein-python :session localhost :results output code
def findComplement(num: int) -> int:
    b_num = bin(num)[2:]
    return int("".join([str(1 - int(d)) for d in b_num]), 2)
findComplement(5)
#+end_src

#+RESULTS: 476 Number complement my solution
#+begin_src none
2
#+end_src

****** Complexity
Time complexity:
$O(N)$, where $N$ is the number of digits of ~num~ in binary.

Space complexity: 
$O(N)$, where $N$ is the number of digits of ~num~ in binary,
as we need to store the digits of the newly generated complement number in an array.

***** Thoughts
Easy question.

****** Leetcode solution
Not available.
#+name: 476 Number complement leetcode solution
#+caption: 476 Number complement leetcode solution
#+begin_src ein-python :session localhost :results output code

#+end_src

Time complexity:

Space complexity: 

**** DONE 1332 Remove palindromic subsequences                    :tricky:
***** Basic info
:LOGBOOK:
CLOCK: [2020-04-09 Thu 15:12]--[2020-04-09 Thu 15:16] =>  0:04
:END:
Given a string ~s~ consisting only of letters 'a' and 'b'. In a single step, you can remove one palindromic *subsequence* from ~s~.

Return the minimum number of steps to make the given string empty.

A string is a subsequence of a given string, if it is generated by deleting some characters of a given 
string without changing its order. (/this definition is not precise as we can also delete some characters inside a sequence of characters. For example, "bab" is not a subsequence of "baab"./).

A string is called palindrome if it is one that reads the same backward and forward.

Constriants:
1. 0 <= s.length <= 1000.
2. ~s~ only consists of letters 'a' and 'b'.
****** Examples:
#+name: 1332 Remove palindromic subsequences example
#+caption: 1332 Remove palindromic subsequences example
#+begin_example
Input: s = "ababa"
Output: 1
Explanation: String is already palindrome

Input: s = "abb"
Output: 2
Explanation: "abb" -> "bb" -> "". 
Remove palindromic subsequence "a" then "bb".

Input: s = "baabb"
Output: 2
Explanation: "baabb" -> "b" -> "". 
Remove palindromic subsequence "baab" then "b".


Input: s = ""
Output: 0
#+end_example

***** Tackling process
:LOGBOOK:
CLOCK: [2020-04-09 Thu 16:14]--[2020-04-09 Thu 16:20] =>  0:06
CLOCK: [2020-04-09 Thu 16:05]--[2020-04-09 Thu 16:14] =>  0:09
CLOCK: [2020-04-09 Thu 16:01]--[2020-04-09 Thu 16:05] =>  0:04
CLOCK: [2020-04-09 Thu 15:16]--[2020-04-09 Thu 16:01] =>  0:45
:END:

****** Algorithm
This requires us to continuously find the longest palindrome for each ~s~, and ~s~ after removing its longest palindrome.

Ideally, we do this recursively.
If ~len(s) == 0~ then return 0.
Else we find ~longest_palindrome(s)~ and remove it from ~s~.
****** Code
:LOGBOOK:
CLOCK: [2020-04-11 Sat 08:47]--[2020-04-11 Sat 08:58] =>  0:11
CLOCK: [2020-04-11 Sat 08:32]--[2020-04-11 Sat 08:41] =>  0:09
CLOCK: [2020-04-10 Fri 21:53]--[2020-04-10 Fri 21:57] =>  0:04
:END:
#+name: 1332 Remove palindromic subsequences my solution
#+caption: 1332 Remove palindromic subsequences my solution
#+begin_src ein-python :session localhost :results output code
def removePalindromeSub(s: str) -> int:
    def is_palindrome(s: str) -> bool:
        if len(s) <= 1:
            return True
        else:
            left, right = 0, -1
            return s[left] == s[right] and is_palindrome(s[left+1:right])

   # def remove_longest_palindrome(s: str) -> str:
   #     bound_l, bound_r = 0,0

   #     for left in range(len(s)):
   #         #for right in range(len(s), left-1, -1):
   #         for right in range(len(s)):
   #             if is_palindrome(s[left:right]):
   #                 if bound_r - bound_l <= right - left:
   #                     bound_l, bound_r = left, right
   #     return s[0:bound_l] + s[bound_r:-1]

    def remove_longest_palindrome(s: str) -> str:
        bound_l, bound_r = 0,0

        for left in range(len(s)):
            for right in range(len(s)):
                if is_palindrome(s[left:right]):
                    if bound_r - bound_l <= right - left:
                        bound_l, bound_r = left, right
        print(bound_l)
        print(bound_r)
        return s[0:bound_l] + s[bound_r:]
    count = 0

    while len(s) > 0:
        s = remove_longest_palindrome(s)
        count += 1
        if count>3:
            break
    return count
#print(removePalindromeSub("baabb"))
#print(removePalindromeSub("ababa"))
#print(removePalindromeSub("aabba"))
print(removePalindromeSub("ababb"))
#+end_src

#+RESULTS: 1332 Remove palindromic subsequences my solution
#+begin_src none
1
4
0
1
0
0
0
0
4
#+end_src

****** Complexity
Time complexity:

Space complexity: 

***** Thoughts
This question needs more thinking before diving into it. 
We need to put special consideration when it says the string only contains ~"a"~ and ~"b"~ characters,
which gives it a unique characteristic, i.e. the string takes at maximum 2 steps to remove palindromic subsequences.

****** Leetcode solution
:LOGBOOK:
CLOCK: [2020-04-13 Mon 13:53]--[2020-04-13 Mon 13:55] =>  0:02
:END:

#+name: 1332 Remove palindromic subsequences leetcode solution
#+caption: 1332 Remove palindromic subsequences leetcode solution
#+begin_src ein-python :session localhost :results output code
def removePalindromSubs(s):
    if len(s) == 0:
        return 0
    elif s == s[::-1]:
        # s is palindrome already
        return 1
    else:
        return 2
#+end_src

Time complexity:
$O(N)$, where N is the length of string ~s~. Used by ~s[::-1]~.

Space complexity: 
$O(N)$, where N is the length of string ~s~. Used by ~s[::-1]~.

**** DONE 1260 Shift 2D Grid
***** Basic info
:LOGBOOK:
CLOCK: [2020-04-13 Mon 14:01]--[2020-04-13 Mon 14:05] =>  0:04
:END:
Given a 2D grid of size ~m*n~ and an integer ~k~. You need to shift the grid ~k~ times.

In one shift operation:
1. Element at grid[i][j] moves to grid[i][j+1].
2. Element at grid[i][n-1] moves to grid[i+1][0].
3. Element at grid[m-1][n-1] moves to grid[0][0].

Return the 2D grid after applying shift operation ~k~ times.

Constraints:
1. m == grid.length
2. n == grid[i].length
3. 1 <= m <= 50
4. 1 <= n <= 50
5. -1000 <= grid[i][j] <= 1000
6. 0 <= k <= 100
****** Examples:
#+name: 1260 Shift 2D Grid example
#+caption: 1260 Shift 2D Grid example
#+begin_example
Input: grid = [[1,2,3],[4,5,6],[7,8,9]], k = 1
Output: [[9,1,2],[3,4,5],[6,7,8]]

Input: grid = [[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], k = 4
Output: [[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]]

Input: grid = [[1,2,3],[4,5,6],[7,8,9]], k = 9
Output: [[1,2,3],[4,5,6],[7,8,9]]
#+end_example

***** Tackling process

****** Algorithm
:LOGBOOK:
CLOCK: [2020-04-13 Mon 14:18]--[2020-04-13 Mon 14:22] =>  0:04
CLOCK: [2020-04-13 Mon 14:05]--[2020-04-13 Mon 14:18] =>  0:13
:END:
This question basically asks us to shift every element to the right ~k~ times.
The lower right element gets shifted to top left.

#+BEGIN_SRC ditaa :file 1260-shift-2d-grid.png :cmdline -r -s 2 
+-->1 -> 2 -> 3
|             |
|   +---------+
|   |
|   v
|   4 -> 5 -> 6
|             |
|   +---------+
|   |
|   v
|   7 -> 8 -> 9
|             |
+-------------+
#+END_SRC

#+RESULTS:
[[file:1260-shift-2d-grid.png]]

From observation, we can see that the elements of the 2D grid can be considered as a ring in order and ~k~ determines 
its starting element when we put the elements back to the grid.
#+BEGIN_SRC ditaa :file 1260-shift-2d-grid-ring.png :cmdline -r -s 2 
[
[1,2],
[3,4]
]
1 -> 2
^    |
|    v
4 <- 3
#+END_SRC
****** Code
:PROPERTIES:
:CUSTOM_ID: 1260_my_solution
:END:
:LOGBOOK:
CLOCK: [2020-04-13 Mon 14:24]--[2020-04-13 Mon 14:39] =>  0:15
:END:
#+name: 1260 Shift 2D Grid my solution
#+caption: 1260 Shift 2D Grid my solution
#+begin_src ein-python :session localhost :results output code
from typing import List
import itertools

def shiftGrid(grid: List[List[int]], k: int) -> List[List[int]]:
    m = len(grid[0])
    n = len(grid)

    ring = list(itertools.chain(*grid))
    remainder = k % (m*n)
    new_list = ring[-remainder:] + ring[:-remainder]
    new_grid = []
    row = []
    for i, e in enumerate(new_list):
        row.append(e)
        if i % m == (m-1):
            new_grid.append(row)
            row = []
            
    return new_grid
shiftGrid([[1,2],[3,4], [5, 6]], 3)
print(shiftGrid([[1],[2],[3],[4]], 6))
#+end_src

#+RESULTS: 1260 Shift 2D Grid my solution
#+begin_src none
[[3], [4], [1], [2]]
#+end_src

****** Complexity
Time complexity:
$O(m*n)$, we will interate all elements in the ~for~ loop.

Space complexity: 
$O(m*n)$, the output array.


***** Thoughts
:LOGBOOK:
CLOCK: [2020-04-13 Mon 14:47]--[2020-04-13 Mon 14:50] =>  0:03
:END:
Initially I thought about using simulation, but then realized that it would be easier to use modulo calculation. 

There is was some complication during coding, especially when:
1. converting the grid to a list.
2. calculating new_list. This is due to the fact that I used a small ~k~ (<m*n) during testing, so that
I did not see that k could actually be larger than ~m*n~ so that using ~ring[-k:]~ would be invalid, though Python does not give an exception.

****** Leetcode solution
Same as mine.
#+name: 1260 Shift 2D Grid leetcode solution
#+caption: 1260 Shift 2D Grid leetcode solution
#+begin_src ein-python :session localhost :results output code

#+end_src

Time complexity:

Space complexity: 

**** DONE 1046 Last Stone Weight
#+BEGIN: clocktable :scope subtree :maxlevel 2
#+CAPTION: Clock summary at [2020-04-13 Mon 16:23]
| Headline     | Time   |
|--------------+--------|
| *Total time* | *0:40* |
|--------------+--------|
#+END:

***** Basic info
:LOGBOOK:
CLOCK: [2020-04-13 Mon 15:18]--[2020-04-13 Mon 15:22] =>  0:04
:END:
We have a collection of stones, each stone has a positive integer weight.

Each turn, we choose the two *heaviest* stones and smash them together.
Suppose the stones have weights ~x~ and ~y~ with ~x<=y~.
The result of the smash is:
1. If ~x==y~, both stones are totally destroyed;
2. If ~x!=y~, the stone of weight ~x~ is totally destroyed, and the stone of weight ~y~
has new weight ~y-x~.

At the end, there is at most 1 stone left. Return the weight of this stone (or 0 if there are no stones left).

Constraints:
1. ~1<=stones.length<=30~
2. ~1<=stones[i] <=1000~
****** Examples:
#+name: 1046 Last Stone Weight example
#+caption: 1046 Last Stone Weight example
#+begin_example
Input: [2,7,4,1,8,1]
Output: 1
Explanation: 
We combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then,
we combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then,
we combine 2 and 1 to get 1 so the array converts to [1,1,1] then,
we combine 1 and 1 to get 0 so the array converts to [1] then that's the value of last stone.
#+end_example

***** Tackling process

****** Algorithm
:LOGBOOK:
CLOCK: [2020-04-13 Mon 15:25]--[2020-04-13 Mon 15:28] =>  0:03
:END:

1. We first sort the array in reverse (large -> small).
2. If ~len(stones) > 1~, we get a new stone ~new_stone~ from ~stones[:2]~.
3. We put ~new_stone~ back to ~stones~ by comparing its weight to others.
4. Repeat 2 and 3 until ~len(stones) <= 1~.
****** Code
:LOGBOOK:
CLOCK: [2020-04-13 Mon 15:41]--[2020-04-13 Mon 16:06] =>  0:25
:END:
#+name: 1046 Last Stone Weight my solution
#+caption: 1046 Last Stone Weight my solution
#+begin_src ein-python :session localhost :results output code
from typing import List

def lastStoneWeight(stones: List[int]) -> int:
    def get_new_stone(y, x) -> int:
        return 0 if y==x else (y-x)

    def put_stone_in(new_stone, sorted_stones: List[int]) -> List[int]:

        has_inserted = False
        for i, s in enumerate(sorted_stones):
            if new_stone >= s:
                sorted_stones.insert(i, new_stone)
                has_inserted = True
                break
        if not has_inserted:
            sorted_stones.append(new_stone)
        return sorted_stones
    
    # sorted_stones = [4,3,2,1]
    sorted_stones = sorted(stones, reverse=True)
    while len(sorted_stones) > 1:
        # new_stone = get_new_stone(sorted_stones.pop(0), sorted_stones.pop(0))
        y = sorted_stones.pop(0)
        x = sorted_stones.pop(0)
        new_stone = get_new_stone(y, x)
        if new_stone > 0:
            sorted_stones = put_stone_in(new_stone, sorted_stones)

    return sorted_stones[0] if len(sorted_stones) == 1 else 0
print(lastStoneWeight([3,7,8]))
print(lastStoneWeight([2,7,4,1,8,1]))
#+end_src

#+RESULTS: 1046 Last Stone Weight my solution
#+begin_src none
2
1
#+end_src

****** Complexity
:LOGBOOK:
CLOCK: [2020-04-13 Mon 16:10]--[2020-04-13 Mon 16:11] =>  0:01
:END:
Time complexity:
$O(N^2)$, ~while~ loop is $O(N)$, ~put_stone_in~ is $O(N)$.

Space complexity: 
$O(N)$.
***** Thoughts
:LOGBOOK:
CLOCK: [2020-04-13 Mon 16:14]--[2020-04-13 Mon 16:21] =>  0:07
:END:
Some tricky details in this question.

~list.pop(idx)~ must be carefully used.
#+begin_src python :results output code
lst = [1,2,3]
one, two = lst.pop(0), lst.pop(1)
print(one)
print(two)
#+end_src

#+RESULTS:
#+begin_src python
1
3
#+end_src

Insert a number into a /sorted list/.
#+begin_src python :results output
def insert_number(num, sorted_nums: List[int]) -> List[int]:

    # sorted_nums can be empty or 
    # all elements in it are larger than num
    has_inserted = False
    for i, s in enumerate(sorted_nums):
        if num >= s:
            sorted_nums.insert(i, num)
            has_inserted = True
            break
    if not has_inserted:
        sorted_nums.append(num)
    return sorted_nums
#+end_src
****** Leetcode solution
Not available.
#+name: 1046 Last Stone Weight leetcode solution
#+caption: 1046 Last Stone Weight leetcode solution
#+begin_src ein-python :session localhost :results output code

#+end_src

Time complexity:

Space complexity: 

**** DONE 997 Find the Town Judge
#+BEGIN: clocktable :scope subtree :maxlevel 2
#+CAPTION: Clock summary at [2020-04-13 Mon 21:04]
| Headline     | Time   |
|--------------+--------|
| *Total time* | *0:30* |
|--------------+--------|
#+END:

***** Basic info
:LOGBOOK:
CLOCK: [2020-04-13 Mon 20:30]--[2020-04-13 Mon 20:33] =>  0:03
:END:
In a town, there are N people labelled from 1 to N.
There is a rumour that one of these people is secretly the town judege.

If the town judege exists, then:
1. The town judge trusts no body.
2. Every body (except for the town judge) trusts the town judege.
3. There is exactly one person that satisfies properties 1 and 2.

You are given ~trust~, an array of pairs ~trust[i] = [a, b]~, representing that the person labelled ~a~ trusts the person labelled ~b~.

If the town judge exists and can be identified, return the label for the town judge. Otherwise, return -1.

Constraints:
1. 1 <= N <= 1000
2. trust.length <= 10000
3. trust[i] are all different
4. trust[i][0] != trust[i][1], one cannot trust himself
5. 1 <= trust[i][0], trust[i][1] <= N
****** Examples:
#+name: 997 Find the Town Judge example
#+caption: 997 Find the Town Judge example
#+begin_example
Input: N = 2, trust = [[1,2]]
Output: 2

Input: N = 3, trust = [[1,3],[2,3]]
Output: 3

Input: N = 3, trust = [[1,3],[2,3],[3,1]]
Output: -1

Input: N = 3, trust = [[1,2],[2,3]]
Output: -1

Input: N = 4, trust = [[1,3],[1,4],[2,3],[2,4],[4,3]]
Output: 3
#+end_example

***** Tackling process

****** Algorithm
:LOGBOOK:
CLOCK: [2020-04-13 Mon 20:38]--[2020-04-13 Mon 20:50] =>  0:12
CLOCK: [2020-04-13 Mon 20:33]--[2020-04-13 Mon 20:34] =>  0:01
:END:
The number of trusts the town judge receives must be ~N-1~.
And he must not trust other people, i.e., he's not in ~trust[i][0]~.

We first work out the trust map.
At the same time, we construct a list of ~trusters~ that trust other people.
Then we filter out those who received ~N-1~ trusts as ~potential~.
Then we check these ~potential~ against ~trusters~, get a list of people not in ~trusters~, as ~res~.
If ~len(res)==1~, return ~res[0]~, else return -1.
****** Code
:LOGBOOK:
CLOCK: [2020-04-13 Mon 20:50]--[2020-04-13 Mon 21:04] =>  0:14
:END:
#+name: 997 Find the Town Judge my solution
#+caption: 997 Find the Town Judge my solution
#+begin_src ein-python :session localhost :results output code
from typing import List

def findJudge(N: int, trust: List[List[int]]) -> int:
    if N == 1: # because one cannot trust himeself, this check is enough
        # leetcode thinks when there is only 1 person, he must be the town judge
        return 1
    trust_map = {}
    trusters = set()
    potential = []

    for t in trust:
        trust_map[t[1]] = trust_map.get(t[1], 0) + 1
        trusters.add(t[0])

    for k, v in trust_map.items():
        if v == N-1:
            potential.append(k)
            
    for e in trusters:
        try:
            potential.remove(e)
        except ValueError:
            continue
    if len(potential) == 1:
        return potential[0]
    return -1
print(findJudge(3,[[1,3], [2,3]]))
print(findJudge(3,[[1,2], [2,3]]))
print(findJudge(3,[[1,2], [2,3], [3,1]]))
print(findJudge(1,[])) # corner case
#+end_src

#+RESULTS: 997 Find the Town Judge my solution
#+begin_src none
3
-1
-1
-1
#+end_src

****** Complexity
Time complexity:
$O(N^2)$, where $N$ is the number of trust relationships.

Space complexity: 
$O(N)$, where $N$ is the number of trust relationships.
***** Thoughts
:LOGBOOK:
CLOCK: [2020-04-13 Mon 21:14]--[2020-04-13 Mon 21:20] =>  0:06
:END:
I think when given N=1, [], the result can be both 1 and -1, and I would say -1 is more reasonable.
It's easy to verify that the town judge can exist in this case, but what if the town judge does not exist? I don't see that contradicting any pre-requisites.
What makes it more reasonable is that it does not /assume/ the existence of the town judge.
****** Leetcode solution
Not available.
#+name: 997 Find the Town Judge leetcode solution
#+caption: 997 Find the Town Judge leetcode solution
#+begin_src ein-python :session localhost :results output code

#+end_src

Time complexity:

Space complexity: 

**** DONE 1009 Complement of base 10 integer            :bit_manipulation:
***** Basic info
:LOGBOOK:
CLOCK: [2020-04-14 Tue 09:00]--[2020-04-14 Tue 09:01] =>  0:01
:END:

Every non-negative integer ~N~ has a binary representation. The complement of a binary representation is the number in binary you get when changing every 1 to 0 and 0 to 1.

For a given number ~N~ in base-10, return the complement of its binary representation as a base-10 integer.

****** Examples:
#+name: 1009 Complement of base 10 integer example
#+caption: 1009 Complement of base 10 integer example
#+begin_example
Input: 5
Output: 2
Explanation: 5 is "101" in binary, with complement "010" in binary, which is 2 in base-10.

Input: 7
Output: 0
Explanation: 7 is "111" in binary, with complement "000" in binary, which is 0 in base-10.
#+end_example

***** Tackling process
:LOGBOOK:
CLOCK: [2020-04-14 Tue 09:02]--[2020-04-14 Tue 09:12] =>  0:10
:END:

****** Algorithm
This is the same question as [[476 Number complement]].
****** Code
#+name: 1009 Complement of base 10 integer my solution
#+caption: 1009 Complement of base 10 integer my solution
#+begin_src ein-python :session localhost :results output code
def bitwiseComplement(N: int) -> int:
    b = bin(N)[2:]
    comp = "".join([str((1 - int(i))) for i in b])
    # int(str, the base of the str)
    return int(comp, 2)
print(bitwiseComplement(10))
#+end_src

#+RESULTS: 1009 Complement of base 10 integer my solution
#+begin_src none
5
#+end_src

****** Complexity
Time complexity:
$O(N)$, where $N$ is the number of digits of ~num~ in binary.

Space complexity: 
$O(N)$, where $N$ is the number of digits of ~num~ in binary.

***** Thoughts
~int(x)~ returns a base-10 number.
~int(x, base=10)~ means ~x~ is a base-10 number. ~x~ could be a string.
See 
[[Toggle bit of positive integers in Python to find complement]]
****** Leetcode solution
:LOGBOOK:
CLOCK: [2020-04-14 Tue 09:25]--[2020-04-14 Tue 09:49] =>  0:24
:END:
Bit manipulation.
#+name: 1009 Complement of base 10 integer leetcode solution
#+caption: 1009 Complement of base 10 integer leetcode solution
#+begin_src ein-python :session localhost :results output code
def bitwiseComplement(N: int) -> int:
    if N == 0:
        return 1
    i = 0
    val = 1

    # we try to find the smallest power of 2 that is larger than N
    # because N at this point is positive, its bit representation must start with 1,
    # when we exclude any leading 0's.
    # Therefore, we can safely increase i, until val's bit representation is one bit more (to the left) than that of N
    # Even though N is changing, it's becoming smaller every time.

    # To make it more strict and easier to understand,
    # we can use the following condition
    # old_n = N
    # while val <= old_n:
    while val <= N:
        N ^= 1<<i
        i+= 1
        val = 2**i

    return N
print(bitwiseComplement(11))
#+end_src

#+RESULTS: 1009 Complement of base 10 integer leetcode solution
#+begin_src none
4
#+end_src

Time complexity:

Space complexity: 

**** DONE 993 Cousins in binary tree
***** Basic info
:LOGBOOK:
CLOCK: [2020-04-14 Tue 11:23]--[2020-04-14 Tue 11:27] =>  0:04
:END:
In a binary tree, the root node is at depth 0, and children of each depth ~k~ node are at depth ~k+1~.

Two nodes of a binary tree are /cousins/ if they have the same depth, but have *different parents*.

We are given the root of a binary tree with unique values, and the values ~x~ and ~y~ of two different nodes in the tree.

Return ~true~ iff the nodes corresponding to the values ~x~ and ~y~ are cousins.

Constraints:
1. The number of nodes in the tree will be between 2 and 100.
2. Each node has a unique integer value from 1 to 100.
****** Examples:
#+name: 993 Cousins in binary tree example
#+caption: 993 Cousins in binary tree example
#+begin_example
Input: root = [1,2,3,4], x = 4, y = 3
Output: false

Input: root = [1,2,3,null,4,null,5], x = 5, y = 4
Output: true

Input: root = [1,2,3,null,4], x = 2, y = 3
Output: false
#+end_example

***** Tackling process

****** Algorithm
:LOGBOOK:
CLOCK: [2020-04-14 Tue 11:52]--[2020-04-14 Tue 11:53] =>  0:01
:END:
We recursively compare each node with ~x~ and ~y~ to find their respective depths ~x_d~ and ~y_d~.
Then we compare ~x_d~ and ~y_d~.
If ~x_d==y_d~, return ~true~. Else return ~false~.

****** Code
:LOGBOOK:
CLOCK: [2020-04-14 Tue 11:53]--[2020-04-14 Tue 12:03] =>  0:10
:END:
#+name: 993 Cousins in binary tree my solution
#+caption: 993 Cousins in binary tree my solution
#+begin_src ein-python :session localhost :results output code
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def is_cousins(root: TreeNode, x: int, y: int) -> bool:
    x_p, y_p = None, None
    x_d, y_d = -1, -1
    def walk_tree(parent: TreeNode, node: TreeNode, depth: int) -> None:
        nonlocal x_d, y_d
        nonlocal x_p, y_p
        if not node:
            return
        if node.val == x:
            x_d = depth
            x_p = parent
        elif node.val == y:
            y_d = depth
            y_p = parent

        if x_d > -1 and y_d > -1:
            return
        else:
            # base case
            walk_tree(node, node.left, depth+1)
            walk_tree(node, node.right, depth+1)
            walk_tree(None, root, 0)
    return x_d == y_d and x_p.val != y_p.val
# testing code
left = TreeNode(2)
right = TreeNode(3)
root = TreeNode(1)
root.left = left
root.right = right
print(is_cousins(root, 2, 3))
#+end_src

#+RESULTS: 993 Cousins in binary tree my solution
#+begin_src none
False
#+end_src

****** Complexity
:LOGBOOK:
CLOCK: [2020-04-14 Tue 12:24]--[2020-04-14 Tue 12:25] =>  0:01
:END:
Time complexity:
$O(NlogN)$, where $N$ is the number of tree nodes.

Space complexity: 
$O(N)$ for the recursive stack, where $N$ is the number of tree nodes.

***** Thoughts
Need to figure out when and how to use ~global~ and ~nonlocal~.

****** Leetcode solution

#+name: 993 Cousins in binary tree leetcode solution
#+caption: 993 Cousins in binary tree leetcode solution
#+begin_src ein-python :session localhost :results output code

#+end_src

Time complexity:

Space complexity: 

**** DONE 989 Add to array-form of integer
***** Basic info
:LOGBOOK:
CLOCK: [2020-04-14 Tue 20:01]--[2020-04-14 Tue 20:04] =>  0:03
:END:
For a non-negative integer ~x~, the /array-form/ of ~x~ is an array of its digits in left to right order. For example, if ~x=1231~, then the array form is [1, 2, 3, 1].

Given the array form ~A~ of a non-negative integer ~x~, return the array form of the integer ~x+k~.

Constraints:
1. 1 <= A.length <= 10000
2. 0 <= A[i] <= 9
3. 0 <= K <= 10000
4. If A.length > 1, then A[0] != 0
****** Examples:
#+name: 989 Add to array-form of integer example
#+caption: 989 Add to array-form of integer example
#+begin_example
Input: A = [1,2,0,0], K = 34
Output: [1,2,3,4]
Explanation: 1200 + 34 = 1234

Input: A = [2,7,4], K = 181
Output: [4,5,5]
Explanation: 274 + 181 = 455

Input: A = [2,1,5], K = 806
Output: [1,0,2,1]
Explanation: 215 + 806 = 1021

Input: A = [9,9,9,9,9,9,9,9,9,9], K = 1
Output: [1,0,0,0,0,0,0,0,0,0,0]
Explanation: 9999999999 + 1 = 10000000000
#+end_example

***** Tackling process

****** Algorithm
:LOGBOOK:
CLOCK: [2020-04-14 Tue 20:04]--[2020-04-14 Tue 20:05] =>  0:01
:END:
The most straightforward way is to convert ~A~ back to the integer, add ~k~ and then convert the result back to the list.
****** Code
:LOGBOOK:
CLOCK: [2020-04-14 Tue 20:05]--[2020-04-14 Tue 20:08] =>  0:03
:END:
#+name: 989 Add to array-form of integer my solution
#+caption: 989 Add to array-form of integer my solution
#+begin_src ein-python :session localhost :results output code
from typing import List


def addToArrayForm(A: List[int], K: int) -> List[int]:
    temp = int("".join([str(i) for i in A])) + K
    return [int(i) for i in str(temp)]

print(addToArrayForm([2,1,5], 806))
print(addToArrayForm([0], 6))
#+end_src

#+RESULTS: 989 Add to array-form of integer my solution
#+begin_src none
[1, 0, 2, 1]
[6]
#+end_src

****** Complexity
:LOGBOOK:
CLOCK: [2020-04-14 Tue 20:08]--[2020-04-14 Tue 20:09] =>  0:01
:END:
Time complexity:
$O(N)$, where N is the number of digits in ~A~.

Space complexity: 
$O(N)$, the space taken by ~temp~, where N is the number of digits in ~A~.

***** Thoughts
:LOGBOOK:
CLOCK: [2020-04-14 Tue 20:09]--[2020-04-14 Tue 20:35] =>  0:26
:END:
Another way to solve the problem would be first add up the digits by multiplying the digit number by a factor of 10, 100, 1000... Then add ~k~, get a ~sum~. Then we can calculate ~mod(sum, 10)~, ~mod(sum, 100)~... Until we get ~mod(sum, 10^x) == sum~.
But this turns out to be slower than the solution above.
#+caption: 989 Add to array-form of integer my solution 2
#+name: 989 Add to array-form of integer my solution 2
#+begin_src ein-python :session localhost :results output code 
from typing import List

def add_to_array_form(A: List[int], K: int) -> List[int]:
    power = len(A) - 1
    s = K
    for e in A:
        s += e * 10**power
        power = power - 1

    power = 1
    new_list = []
    while 10**power <= s:
        # new_list.insert(0, s % (10**power) // 10**(power-1))
        new_list.append(s % (10**power) // 10**(power-1))
        power += 1

    # we still need to do one more operation
    new_list.append(s % (10**power) // 10**(power-1))
    return new_list[::-1]
print(add_to_array_form([1,2,6,3,0,7,1,7,1,9,7,5,6,6,4,4,0,0,6,3], 516))
#+end_src

#+RESULTS: 989 Add to array-form of integer my solution 2
#+begin_src none
[1, 2, 6, 3, 0, 7, 1, 7, 1, 9, 7, 5, 6, 6, 4, 4, 0, 5, 7, 9]
#+end_src

#+caption: 989 Add to array-form of integer my solution 2-results
****** Leetcode solution
:LOGBOOK:
CLOCK: [2020-04-14 Tue 20:44]--[2020-04-14 Tue 20:59] =>  0:15
:END:
We add the numbers column by column.
Taking 123+912 as an example, we first have [1,2,3+912], which gives us [1, 2, 915],
then we leave 5 in the digit, and carry 91 into the column to the left [1, 2+91, 5],
and we get [1, 93, 5], then we get [10, 3, 5], then [1,0,3,5].
#+name: 989 Add to array-form of integer leetcode solution
#+caption: 989 Add to array-form of integer leetcode solution
#+begin_src ein-python :session localhost :results output code
def add_to_array_form(A, K):
    A[-1] += K
    for i in range(len(A) - 1, -1, -1):

        # divmod(x, y, /)
        #    Return the tuple (x//y, x%y).  Invariant: div*y + mod == x.
        carry, A[i] = divmod(A[i], 10)
        if i: A[i-1] += carry

    # if carry is not 0
    if carry:
        # map() to convert number carry to a list of its digits
        A = map(int, str(carry)) + A

    return A

print(add_to_array_form([1,2,6,3,0,7,1,7,1,9,7,5,6,6,4,4,0,0,6,3], 516))
#+end_src

#+RESULTS: 989 Add to array-form of integer leetcode solution
#+begin_src none
[1, 2, 6, 3, 0, 7, 1, 7, 1, 9, 7, 5, 6, 6, 4, 4, 0, 5, 7, 9]
#+end_src

Time complexity:
$O(max(N, logK))$, where $N = len(A)$, when ~K~ is larger than ~A~, time complexity is determined by the number of digits that ~K~ has, which is proportional to $log{K}$.

Space complexity: 
$O(max(N, logK))$, where $N = len(A)$.

**** DONE 970 powerful integers
***** Basic info
:LOGBOOK:
CLOCK: [2020-04-14 Tue 21:13]--[2020-04-14 Tue 21:18] =>  0:05
:END:
Given two positive integers ~x~ and ~y~, an integer is /powerful/ if it is equal to 
$x^i+y^j$ for some integers $i\ge 0$ and $j\ge 0$.

Return a list of all /powerful/ integers that have values less than or equal to ~bound~.

You may return the answer in any order. In your answer, each value should occur at most once.

Constraints:
1. 1 <= x <= 100
2. 1 <= y <= 100
3. 0 <= bound <= 10^6
****** Examples:
#+name: 970 powerful integers example
#+caption: 970 powerful integers example
#+begin_example
Input: x = 2, y = 3, bound = 10
Output: [2,3,4,5,7,9,10]
Explanation: 
2 = 2^0 + 3^0
3 = 2^1 + 3^0
4 = 2^0 + 3^1
5 = 2^1 + 3^1
7 = 2^2 + 3^1
9 = 2^3 + 3^0
10 = 2^0 + 3^2

Input: x = 3, y = 5, bound = 15
Output: [2,4,6,8,10,14]
#+end_example

***** Tackling process

****** Algorithm
:LOGBOOK:
CLOCK: [2020-04-14 Tue 21:18]--[2020-04-14 Tue 21:28] =>  0:10
:END:
The minimum number we can get is 2 when ~i==j==0~.

For ~x~, we can get an ~i~ s.t. $x^{i}\le bound-1 < x^{i+1}$.
For ~y~, we can get an ~j~ s.t. $y^{j}\le bound-1 < y^{j+1}$.
Then we brute force all possibilities.
****** Code
:LOGBOOK:
CLOCK: [2020-04-14 Tue 21:28]--[2020-04-14 Tue 21:40] =>  0:12
:END:
#+name: 970 powerful integers my solution
#+caption: 970 powerful integers my solution
#+begin_src ein-python :session localhost :results output code
from typing import List, Set
from math import log

def powerful_integers(x: int, y: int, bound: int) -> List[int]:
    def get_max_power(num: int, bound: int) -> int:
        if num == 1:
            return 0
        return int(log(bound, num))

        # the following code is a bit slow
        # b = bound - 1
        # i=0
        # while b >= x**i:
        #     i += 1
        # return i
    
    res: Set[int] = set()
    i = get_max_power(x, bound)
    j = get_max_power(y, bound)

    for x_i in range(0, i+1):
        for y_j in range(0, j+1):
            s = x**x_i + y**y_j
            if  s <= bound:
                res.add(s)
    return list(res)
print(powerful_integers(1,1,10))
#+end_src

#+RESULTS: 970 powerful integers my solution
#+begin_src none
[2]
#+end_src

****** Complexity
:LOGBOOK:
CLOCK: [2020-04-14 Tue 21:50]--[2020-04-14 Tue 21:53] =>  0:03
:END:
Time complexity:
$O(\log^{2}bound)$, where $\log{bound}$ determines ~i~ and ~j~.

Space complexity: 
$O(\log^{2}bound)$, where $\log{bound}$ determines ~i~ and ~j~. This is used for the result ~res~.

***** Thoughts
:LOGBOOK:
CLOCK: [2020-04-14 Tue 21:53]--[2020-04-14 Tue 21:55] =>  0:02
:END:
The initial code was slower than using the ~log~ function provided by Python.
#+caption: powerful-integers-code-compare
#+name: powerful-integers-code-compare
#+begin_src ein-python :session localhost :results output code 
def get_max_power(num: int, bound: int) -> int:
    if num == 1:
        return 0
    return int(log(bound, num))

    # the following code is a bit slow
    # b = bound - 1
    # i=0
    # while b >= x**i:
    #     i += 1
    # return i
#+end_src

#+caption: powerful-integers-code-compare-results

#+RESULTS: powerful-integers-code-compare-

****** Leetcode solution
:LOGBOOK:
CLOCK: [2020-04-14 Tue 21:55]--[2020-04-14 Tue 22:15] =>  0:20
:END:
The solution calculates the upper bound for ~i~ and ~j~ beforehand.
It is obvious that $0\le i, j < \lceil \log_{2}{(10^6-1)} \rceil = 20$.
#+name: 970 powerful integers leetcode solution
#+caption: 970 powerful integers leetcode solution
#+begin_src ein-python :session localhost :results output code
class Solution(object): 
    def powerfulIntegers(self, x, y, bound):
        ans = set()
        # 2**20 > bound
        for i in range(20):
            for j in range(20):
                v = x**i + y**j
                if v <= bound:
                    ans.add(v)
        return list(ans)
#+end_src

Time complexity:
$O(\log^{2}bound)$, where $\log{bound}$ determines ~i~ and ~j~.

Space complexity: 
$O(\log^{2}bound)$, where $\log{bound}$ determines ~i~ and ~j~.

**** DONE 949 Largest time for given digits :algorithm:brute_force:backtracking:
***** Basic info
:LOGBOOK:
CLOCK: [2020-04-15 Wed 08:33]--[2020-04-15 Wed 08:35] =>  0:02
:END:
Given an array of 4 digits, return the largest 24 hour time that can be made.

The smallest 24 hour time is 00:00, and the largest is 23:59. Starting from 00:00,
a time is larger if more time has elapsed since midnight.

Return the answer as a string of length 5. If no valid time can be made, return an empty string.

Constraints:
1. A.length == 4
2. 0 <= A[i] <= 9
****** Examples:
#+name: 949 Largest time for given digits example
#+caption: 949 Largest time for given digits example
#+begin_example
Input: [1,2,3,4]
Output: "23:41"

Input: [5,5,5,5]
Output: ""
#+end_example

***** Tackling process

****** Algorithm
:LOGBOOK:
CLOCK: [2020-04-15 Wed 08:35]--[2020-04-15 Wed 09:00] =>  0:25
:END:
Possible combinations:
hour first digit: 0, hour second digit: 0-9
hour first digit: 1, hour second digit: 0-9
hour first digit: 2, hour second digit: 0-3

minute first digit: 0-5
minute second digit: 0-9

We first sort the list in reverse (large to small), then we try to put a large number as close to the left of the end string as possible, given that it fits the rules above.
****** Code
:LOGBOOK:
CLOCK: [2020-04-15 Wed 09:12]--[2020-04-15 Wed 09:14] =>  0:02
:END:
#+name: 949 Largest time for given digits my solution
#+caption: 949 Largest time for given digits my solution
#+begin_src ein-python :session localhost :results output code
from typing import List

def largest_time_from_digits(A: List[int]) -> str:
    hour_first_vals = set([0, 1, 2])
    hour_second_vals = {
        0: set(range(10)),
        1: set(range(10)),
        2: set(range(4))
    }

    minute_first_digit_vals = set(range(6))
    minute_second_digit_vals = set(range(10))

    sorted_list = sorted(A)
    # we first test the first hour digit
    first_h_d = -1
    for e in sorted_list:
        if e in hour_first_vals:
            # because e is sorted
            # this guarantees it gets the largest number possible
            first_h_d = e
    if first_h_d == -1:
        return ""

    sorted_list.remove(first_h_d)
    second_h_d_range = hour_second_vals[first_h_d]
    second_h_d = -1
    for e in sorted_list:
        if e in second_h_d_range:
            second_h_d = e
    if second_h_d == -1:
        return ""

    sorted_list.remove(second_h_d)
    first_m_d = -1
    for e in sorted_list:
        if e in minute_first_digit_vals:
            first_m_d = e
            
    if first_m_d == -1:
        return ""

    sorted_list.remove(first_m_d)
    return "{}{}:{}{}".format(first_h_d, second_h_d, first_m_d, sorted_list[0])
print(largest_time_from_digits([1,2,3,4]))
print(largest_time_from_digits([5,5,5,5]))
print(largest_time_from_digits([0,0,0,0]))
print(largest_time_from_digits([2,0,6,6]))
print(largest_time_from_digits([1,1,1,1]))
#+end_src

#+RESULTS: 949 Largest time for given digits my solution
#+begin_src none
23:41

00:00

11:11
#+end_src

#+name: 949 Largest time for given digits my solution 2
#+caption: 949 Largest time for given digits my solution 2
#+begin_src ein-python :session localhost :results output code
from typing import List

def largest_time_from_digits(A: List[int]) -> str:
    hour_first_vals = set([0, 1, 2])
    hour_second_vals = {
        0: set(range(10)),
        1: set(range(10)),
        2: set(range(4))
    }

    minute_first_digit_vals = set(range(6))
    minute_second_digit_vals = set(range(10))

    sorted_list = sorted(A)
    # we first test the first hour digit
    first_h_d = -1
    for e in sorted_list:
        if e in hour_first_vals:
            # because e is sorted
            # this guarantees it gets the largest number possible
            first_h_d = e
    if first_h_d == -1:
        return ""

    sorted_list.remove(first_h_d)
    second_h_d_range = hour_second_vals[first_h_d]
    second_h_d = -1
    for e in sorted_list:
        if e in second_h_d_range:
            second_h_d = e
    if second_h_d == -1:
        return ""

    sorted_list.remove(second_h_d)
    first_m_d = -1
    for e in sorted_list:
        if e in minute_first_digit_vals:
            first_m_d = e
            
    if first_m_d == -1:
        return ""

    sorted_list.remove(first_m_d)
    return "{}{}:{}{}".format(first_h_d, second_h_d, first_m_d, sorted_list[0])
print(largest_time_from_digits([1,2,3,4]))
print(largest_time_from_digits([5,5,5,5]))
print(largest_time_from_digits([0,0,0,0]))
print(largest_time_from_digits([2,0,6,6]))
print(largest_time_from_digits([1,1,1,1]))
#+end_src
****** Complexity
Time complexity:

Space complexity: 

***** Thoughts
:LOGBOOK:
CLOCK: [2020-04-15 Wed 09:17]--[2020-04-15 Wed 09:18] =>  0:01
:END:
This question can be solved by brute force, but I was trying to find a more elegant solution.
I think [[*Backtrack]] would do.

****** Leetcode solution
:PROPERTIES:
:CUSTOM_ID: 949_leetcode_solution
:END:

#+name: 949 Largest time for given digits leetcode solution
#+caption: 949 Largest time for given digits leetcode solution
#+begin_src ein-python :session localhost :results output code
import itertools
def largest_time_from_digits(A):
    ans = -1
    for h1, h2, m1, m2 in itertools.permutations(A):
        hours = 10 * h1 + h2
        mins = 10 * m1 + m2
        time = 60 * hours + mins
        if 0 <= hours < 24 and 0 <= mins < 60 and time > ans:
            ans = time

    return "{:02}:{:02}".format(*divmod(ans, 60)) if ans >= 0 else ""
print(largest_time_from_digits([2,0,6,6]))
#+end_src

#+RESULTS: 949 Largest time for given digits leetcode solution
#+begin_src none
06:26
#+end_src

Time complexity:
$O(1)$

Space complexity: 
$O(1)$

**** DONE 941 Valid mountain array
***** Basic info
:LOGBOOK:
CLOCK: [2020-04-16 Thu 07:39]--[2020-04-16 Thu 07:39] =>  0:00
CLOCK: [2020-04-16 Thu 07:38]--[2020-04-16 Thu 07:38] =>  0:00
CLOCK: [2020-04-16 Thu 07:33]--[2020-04-16 Thu 07:36] =>  0:03
:END:
Given an array ~A~ of integers, return ~true~ if and only if it is a /valid mountain array/.

~A~ is a mountain array iff:
1. ~A.length>=3~
2. There exists some ~i~ with ~0<i<A.length-1~ such that:
   1. ~A[0]<A[1]<...A[i-1]<A[i]~
   2. ~A[i]>A[i+1]>...>A[A.length-1]~

Constraints:
1. 0 <= A.length <= 10000
2. 0 <= A[i] <= 10000 

****** Examples:
#+name: 941 Valid mountain array example
#+caption: 941 Valid mountain array example
#+begin_example
Input: [2,1]
Output: false

Input: [3,5,5]
Output: false

Input: [0,3,2,1]
Output: true
#+end_example

***** Tackling process

****** Algorithm
:LOGBOOK:
CLOCK: [2020-04-16 Thu 07:40]--[2020-04-16 Thu 07:47] =>  0:07
:END:
We scan the elements from both ends of the array. Two ends should converge at the same point.
****** Code
:LOGBOOK:
CLOCK: [2020-04-16 Thu 07:47]--[2020-04-16 Thu 07:55] =>  0:08
:END:
#+name: 941 Valid mountain array my solution
#+caption: 941 Valid mountain array my solution
#+begin_src ein-python :session localhost :results output code
from typing import List

def valid_mountain_array(A: List[int]) -> bool:
    peak_left_pos = None
    for i in range(len(A)):
        if i > 0:
            if A[i] > A[i-1]:
                peak_left_pos = i
            else:
                break


    peak_right_pos = None
    for j in range(-1, -len(A)-1, -1):
        if j < -1:
            if A[j] > A[j+1]:
                peak_right_pos = j
            else:
                break
            
    try:
        if peak_left_pos - peak_right_pos == len(A):
            return True
    except TypeError:
        pass
    return False
print(valid_mountain_array([0,1,2,3,3,2,0]))
print(valid_mountain_array([0,1,2,5,3,2,0]))
print(valid_mountain_array([0,1,2,3,2,0]))
print(valid_mountain_array([0,1,23,20,2,2,0]))
print(valid_mountain_array([1]))
print(valid_mountain_array([]))
#+end_src

#+RESULTS: 941 Valid mountain array my solution
#+begin_src none
False
True
True
False
False
False
#+end_src

****** Complexity
Time complexity:
$O(N)$, ~N==len(A)~.

Space complexity: 
$O(1)$.

***** Thoughts
:LOGBOOK:
CLOCK: [2020-04-16 Thu 08:01]--[2020-04-16 Thu 08:03] =>  0:02
:END:
There is still hard parts in this problem that stopped me from getting it done quickly and just scanning the array from left to right.

After typing the Leetcode algorithm, I think the problem lies in my lack of use of ~while~ loop, as well as clear condition checking in this case.
Also, I always find it hard to compare the two adjacent elements in an array as I do not know how to handle when ~i==0~, and I need to compare ~A[i-1]~ with ~A[i]~.

****** Leetcode solution
:LOGBOOK:
CLOCK: [2020-04-16 Thu 08:03]--[2020-04-16 Thu 08:09] =>  0:06
:END:
Walk up from left to right until we can't, i.e. that has to be the peak.
We should ensure the peak is not the first or last element. Then we walk down.
If we reach the end, the array is valid, otherwise it is not.
#+name: 941 Valid mountain array leetcode solution
#+caption: 941 Valid mountain array leetcode solution
#+begin_src ein-python :session localhost :results output code
def valid_mountain_array(A):
    n = len(A)
    i = 0

    # walk up
    while i+1 < N and A[i] < A[i+1]:
        i += 1

    # peak can't be first or last
    if i==0 or i==N-1:
        return False

    # walk down
    while i+1 < N and A[i] > A[i+1]:
        i+=1

    return i==N-1
#+end_src

Time complexity:
$O(N)$.

Space complexity: 
$O(1)$.

**** DONE 925 Long pressed name
***** Basic info
:LOGBOOK:
CLOCK: [2020-04-16 Thu 09:11]--[2020-04-16 Thu 09:14] =>  0:03
:END:
Your friend is typing his ~name~ into a keyboard. Sometimes, when typing a character ~c~,
the key might get /long pressed/, and the character will be typed 1 or more times.

You examine the ~typed~ characters of the keyboard. Return ~True~ if it is possible that
it was your friends name, withe some characters (possibly none) being long pressed.

Constraints:
1. name.length <= 1000
2. typed.length <= 1000
3. The characters of name and typed are lowercase letters.

****** Examples:
#+name: 925 Long pressed name example
#+caption: 925 Long pressed name example
#+begin_example
Input: name = "alex", typed = "aaleex"
Output: true
Explanation: 'a' and 'e' in 'alex' were long pressed.

Input: name = "saeed", typed = "ssaaedd"
Output: false
Explanation: 'e' must have been pressed twice, but it wasn't in the typed output.

Input: name = "leelee", typed = "lleeelee"
Output: true

Input: name = "laiden", typed = "laiden"
Output: true
Explanation: It's not necessary to long press any character.
#+end_example

***** Tackling process
:LOGBOOK:
CLOCK: [2020-04-16 Thu 09:14]--[2020-04-16 Thu 09:18] =>  0:04
:END:
If ~name.length~ == ~typed.length~, then ~name==typed~ must be true for the program to return ~True~.
****** Algorithm
:LOGBOOK:
CLOCK: [2020-04-16 Thu 09:18]--[2020-04-16 Thu 09:25] =>  0:07
CLOCK: [2020-04-16 Thu 09:14]--[2020-04-16 Thu 09:14] =>  0:00
:END:
1. If ~name.length > typed.length~, then the program must return ~False~.
2. If ~name.length~ == ~typed.length~, then ~name==typed~ must be true for the program to return ~True~.
3. If ~name.length < typed.length~, then we check the following:
   1. If ~name~ and ~typed~ contains different characters, then the program must return ~False~.
   2. We check if the character in ~typed~ corresponds to the character in ~name~.
****** Code
:LOGBOOK:
CLOCK: [2020-04-16 Thu 09:47]--[2020-04-16 Thu 09:49] =>  0:02
CLOCK: [2020-04-16 Thu 09:25]--[2020-04-16 Thu 09:44] =>  0:19
:END:
#+name: 925 Long pressed name my solution
#+caption: 925 Long pressed name my solution
#+begin_src ein-python :session localhost :results output code
from collections import Counter

def is_long_pressed_name(name: str, typed: str) -> bool:
    name_len = len(name)
    typed_len = len(typed)

    # If ~name.length > typed.length~, then the program must return ~False~.
    if name_len > typed_len:
        return False
    # If ~name.length~ == ~typed.length~, then ~name==typed~ must be true for the program to return ~True~.
    if name_len == typed_len:
        return name == typed

    if set(name) != set(typed):
        return False

    name_count = Counter(name)
    typed_count = Counter(typed)
    for k, v in name_count.items():
        if v > typed_count[k]:
            return False

    pos_typed = 0
    pos_name = 0
    while pos_typed < typed_len and pos_name < name_len:
        if typed[pos_typed] == name[pos_name]:
            pos_typed += 1
            pos_name += 1
        else:
            if pos_typed == 0:
                return False
            else:
                if typed[pos_typed]==typed[pos_typed-1]:
                    pos_typed += 1
                else:
                    return False
                
    return True
print(is_long_pressed_name("aleex", "aleeexx"))
print(is_long_pressed_name("aleexl", "aleeexx"))
print(is_long_pressed_name("aleexl", "aleeexxe"))
print(is_long_pressed_name("aleexxx", "aleeexxe"))
print(is_long_pressed_name("kikcxmvzi", "kiikcxxmmvvzz"))
#+end_src

#+RESULTS: 925 Long pressed name my solution
#+begin_src none
True
False
False
False
True
#+end_src

****** Complexity
Time complexity:

Space complexity: 

***** Thoughts
:LOGBOOK:
CLOCK: [2020-04-16 Thu 10:40]--[2020-04-16 Thu 11:07] =>  0:27
:END:
For a string like S = 'aabbbbccc', we can group it into blocks groupify(S) = [('a', 2), ('b', 4), ('c', 3)], that consist of a key 'abc' and a count [2, 4, 3].

Then, the necessary and sufficient condition for typed to be a long-pressed version of name is that the keys are the same, and each entry of the count of typed is at least the entry for the count of name.

For example, 'aaleex' is a long-pressed version of 'alex': because when considering the groups [('a', 2), ('l', 1), ('e', 2), ('x', 1)] and [('a', 1), ('l', 1), ('e', 1), ('x', 1)], they both have the key 'alex', and the count [2,1,2,1] is at least [1,1,1,1] when making an element-by-element comparison (2 >= 1, 1 >= 1, 2 >= 1, 1 >= 1).

****** Leetcode solution

#+name: 925 Long pressed name leetcode solution
#+caption: 925 Long pressed name leetcode solution
#+begin_src ein-python :session localhost :results output code
def is_long_pressed_name(name: str, typed: str) -> bool:
    import itertools
    name_count = [(k, len(list(grp))) for k, grp in itertools.groupby(name)]
    typed_count = [(k, len(list(grp))) for k, grp in itertools.groupby(typed)]
    if len(name_count) != len(typed_count):
        return False
    return all(k1 == k2 and v1<=v2 for (k1,v1), (k2,v2) in zip(name_count, typed_count))

print(is_long_pressed_name("aleex", "aleeexx"))
print(is_long_pressed_name("aleexl", "aleeexx"))
print(is_long_pressed_name("aleexl", "aleeexxe"))
print(is_long_pressed_name("aleexxx", "aleeexxe"))
print(is_long_pressed_name("kikcxmvzi", "kiikcxxmmvvzz"))
#+end_src

#+RESULTS: 925 Long pressed name leetcode solution
#+begin_src none
True
False
False
False
False
#+end_src

Time complexity:

Space complexity: 

**** DONE 914 X of a kind in a deck of cards
***** Basic info
:LOGBOOK:
CLOCK: [2020-04-16 Thu 11:16]--[2020-04-16 Thu 11:22] =>  0:06
:END:
In a deck of cards, each card has an integer written on it.

Return ~true~ if and only if you can choose ~x>=2~ such that it is possible to split the 
entire deck into 1 or more groups of cards, where:
1. Each group has exactly ~x~ cards.
2. All the cards in each group have the same integer.
   
Constraints:
1. 1 <= deck.length <= 10^4
2. 0 <= deck[i] < 10^4
****** Examples:
#+name: 914 X of a kind in a deck of cards example
#+caption: 914 X of a kind in a deck of cards example
#+begin_example
Input: deck = [1,2,3,4,4,3,2,1]
Output: true
Explanation: Possible partition [1,1],[2,2],[3,3],[4,4].

Input: deck = [1,1,1,2,2,2,3,3]
Output: false
Explanation: No possible partition.

Input: deck = [1]
Output: false
Explanation: No possible partition.

Input: deck = [1,1]
Output: true
Explanation: Possible partition [1,1].

Input: deck = [1,1,2,2,2,2]
Output: true
Explanation: Possible partition [1,1],[2,2],[2,2].
#+end_example

***** Tackling process

****** Algorithm
:LOGBOOK:
CLOCK: [2020-04-16 Thu 11:25]--[2020-04-16 Thu 11:35] =>  0:10
:END:
We count the number of appearances of each number using ~collections.Counter~, store it in ~count~.
We then get the smallest number ~divisor~ in ~count~ and check if ~for k, num in count: num%divisor == 0~ holds true for all.
We return ~False~ if it does not hold.
Return ~True~.
****** Code
:LOGBOOK:
CLOCK: [2020-04-16 Thu 11:50]--[2020-04-16 Thu 12:05] =>  0:15
:END:
#+name: 914 X of a kind in a deck of cards my solution
#+caption: 914 X of a kind in a deck of cards my solution
#+begin_src ein-python :session localhost :results output code
from typing import List

def has_groups_size_x(deck: List[int]) -> bool:
    if len(deck) < 2:
        return False

    from collections import Counter

    def get_factors(x):
        for i in range(2, x//2+1):
            if x % i == 0:
                yield i

        yield x

    count = Counter(deck)
    divisor = max(2, sorted(count.items(), key=lambda kv: kv[1])[0][1])
    div_factors = get_factors(divisor)
    for factor in div_factors:
        for k, num in count.items():
            if num % factor != 0:
                break
        else:
            return True

    return False

print(has_groups_size_x([1]))
print(has_groups_size_x([1,1]))
print(has_groups_size_x([1,2]))
print(has_groups_size_x([1,1,1,2,2,3,3]))
print(has_groups_size_x([1,1,1,1,2,2,2,2,2,2]))
print(has_groups_size_x([0,0,0,0,0,1,1,2,3,4]))
#+end_src

#+RESULTS: 914 X of a kind in a deck of cards my solution
#+begin_src none
False
True
False
False
True
False
#+end_src

****** Complexity
:LOGBOOK:
CLOCK: [2020-04-16 Thu 14:13]--[2020-04-16 Thu 14:22] =>  0:09
:END:
Time complexity:
Not sure. At least $O(N)+f(N)$.

Space complexity: 
$O(N)$.
***** Thoughts

****** Leetcode solution
:PROPERTIES:
:CUSTOM_ID: 914_leetcode_solution
:END:
:LOGBOOK:
CLOCK: [2020-04-16 Thu 14:23]--[2020-04-16 Thu 14:27] =>  0:04
:END:
The same idea as mine, but vastly simplified the solution.
We only need to find the greatest common divisor of all $Count_i$, $i$ is the card.
#+name: 914 X of a kind in a deck of cards leetcode solution
#+caption: 914 X of a kind in a deck of cards leetcode solution
#+begin_src ein-python :session localhost :results output code
def has_group_size_x(deck):
    # from fractions import gcd
    from math import gcd
    from collections import Counter

    vals = Counter(deck).values()
    return reduce(gcd, vals) >= 2

print(has_groups_size_x([1]))
print(has_groups_size_x([1,1]))
print(has_groups_size_x([1,2]))
print(has_groups_size_x([1,1,1,2,2,3,3]))
print(has_groups_size_x([1,1,1,1,2,2,2,2,2,2]))
print(has_groups_size_x([0,0,0,0,0,1,1,2,3,4]))
#+end_src

#+RESULTS: 914 X of a kind in a deck of cards leetcode solution
#+begin_src none
False
True
False
False
True
False
#+end_src

Time complexity:

Space complexity: 

**** 874 Walking robot simulation
***** Basic info


****** Examples:
#+name: 874 Walking robot simulation example
#+caption: 874 Walking robot simulation example
#+begin_example

#+end_example

***** Tackling process

****** Algorithm

****** Code
#+name: 874 Walking robot simulation my solution
#+caption: 874 Walking robot simulation my solution
#+begin_src ein-python :session localhost :results output code

#+end_src

****** Complexity
Time complexity:

Space complexity: 

***** Thoughts


****** Leetcode solution

#+name: 874 Walking robot simulation leetcode solution
#+caption: 874 Walking robot simulation leetcode solution
#+begin_src ein-python :session localhost :results output code

#+end_src

Time complexity:

Space complexity: 

**** 869 Lemonade change
***** Basic info


****** Examples:
#+name: 869 Lemonade change example
#+caption: 869 Lemonade change example
#+begin_example

#+end_example

***** Tackling process

****** Algorithm

****** Code
#+name: 869 Lemonade change my solution
#+caption: 869 Lemonade change my solution
#+begin_src ein-python :session localhost :results output code

#+end_src

****** Complexity
Time complexity:

Space complexity: 

***** Thoughts


****** Leetcode solution

#+name: 869 Lemonade change leetcode solution
#+caption: 869 Lemonade change leetcode solution
#+begin_src ein-python :session localhost :results output code

#+end_src

Time complexity:

Space complexity: 

*** Techniques
**** Custom sort in Python
When using the ~sort()~ function in Python, we can do advanced custom sort.

I usually use a lambda function but it never occured to me that I can actually use a fully-fledged function to sort a list.

In [[937 Reorder data in log files]], the leetcode solution uses a full function to custom sort the list.

For example, given a list of student names and ids in the form of ~["Firstname, Lastname, id"]~, and we are requested to sort them
by id, firstname and lastname, then we can write something like this.
#+name: custom sort example
#+begin_src python
from typing import List
def sort_students(students: List[str]) -> List[str]:
    def f(std):
        # we return the key for the student
        fn, ln, id_ = std.split(",")
        return (id_, fn, ln)
    return sorted(students, key=f)
return sort_students(["Jeg, Name, 123", "Jeg, Name, 223"])
#+end_src

#+RESULTS: custom sort example
| Jeg, Name, 123 | Jeg, Name, 223 |

Also, we need to note that ~return (1)~ (the number) is different from ~return (1,)~ (a tuple that only has the number 1 as its element)
#+name: return (1)
#+begin_src python :exports both
return (1)
#+end_src

#+RESULTS: return (1)
: 1

#+name: return (1,)
#+begin_src python :exports both
return (1,)
#+end_src

#+RESULTS: return (1,)
| 1 |

**** BFS
**** DFS
**** ~str.zfill~ in Python
Return a copy of the string /left/ filled with ASCII '0' digits to make a string of length ~width~.
Could be used in handling binary numbers.
#+begin_example
>>> "42".zfill(5)
'00042'
>>> "-42".zfill(5)
'-0042'
#+end_example
**** ~zip()~ in Python
See [[867 Transpose matrix]].

~zip~ "makes an iterator that aggregates elements from each of the iterables".
Returns an iterator of tuples, where the i-th tuple contains the i-th element from each of the argument sequences of iterables.
#+name: Using the ~zip~ function.
#+begin_src python
x = [1, 2, 3]
y = [3, 4, 5]
return list(zip([x,y]))
#+end_src

#+RESULTS: Using the ~zip~ function.
| (1 2 3) |
| (3 4 5) |

#+name: Using the ~zip~ function 2.
#+begin_src python
x = [1, 2, 3]
y = [3, 4, 5]
return list(zip(x,y))
#+end_src

#+RESULTS: Using the ~zip~ function 2.
| 1 | 3 |
| 2 | 4 |
| 3 | 5 |

#+name: unzip
#+begin_src python
x = [1, 2, 3]
y = [3, 4, 5]
return list(zip(*zip(x,y)))
#+end_src

#+RESULTS: unzip
| 1 | 2 | 3 |
| 3 | 4 | 5 |
**** ~sum() in Python~
:LOGBOOK:
CLOCK: [2020-01-27 Mon 15:44]--[2020-01-27 Mon 15:47] =>  0:03
:END:
~sum(iterable, /, start=0)~

Sums start and the items of an iterable from left to right and returns the total. The iterables items are normally numbers, and the start value is not allowed to be a string.

~sum()~ can sum up boolean values as well.

#+caption: python-sum-function
#+name: python-sum-function
#+begin_src ein-python :session localhost :results output code 
lst1 = [1,2,3]
lst2 = [2,2,3]
sum(e1==e2 for e1, e2 in zip(lst1, lst2))
#+end_src

#+caption: python-sum-function-results
#+RESULTS: python-sum-function
#+begin_src none
2
#+end_src
**** Converting a matrix to a list using ~itertools~
#+caption: convert-matrix-using-itertools
#+name: convert-matrix-using-itertools
#+begin_src ein-python :session localhost :results output code 

import itertools

matrix = [[1,2],[1,2],[3,4]]

print(list(itertools.chain(*matrix)))
#+end_src

#+RESULTS: convert-matrix-using-itertools
#+begin_src none
[1, 2, 1, 2, 3, 4]
#+end_src

#+caption: convert-matrix-using-itertools-results
**** Unpacking argument lists
Just like the spread operator in ReactJS.
The reverse situation occurs when the arguments are already in a list or tuple but need to be unpacked for a function call requiring separate positional arguments. For instance, the built-in range() function expects separate start and stop arguments. If they are not available separately, write the function call with the *-operator to unpack the arguments out of a list or tuple:
#+begin_example
>>> list(range(3, 6))            # normal call with separate arguments
[3, 4, 5]
>>> args = [3, 6]
>>> list(range(*args))            # call with arguments unpacked from a list
[3, 4, 5]
#+end_example
**** ~list.pop()~ tips
~list.pop(idx)~ must be carefully used.
#+begin_src python :results output code
lst = [1,2,3]
one, two = lst.pop(0), lst.pop(1)
print(one)
print(two)
#+end_src

#+RESULTS:
#+begin_src python
1
3
#+end_src
**** Insert a number into a sorted list
Insert a number into a /sorted list/.
#+begin_src python :results output
def insert_number(num, sorted_nums: List[int]) -> List[int]:

    # sorted_nums can be empty or 
    # all elements in it are larger than num
    has_inserted = False
    for i, s in enumerate(sorted_nums):
        if num >= s:
            sorted_nums.insert(i, num)
            has_inserted = True
            break
    if not has_inserted:
        sorted_nums.append(num)
    return sorted_nums
#+end_src
**** Toggle bit of positive integers in Python to find complement
:LOGBOOK:
CLOCK: [2020-04-14 Tue 10:29]--[2020-04-14 Tue 10:31] =>  0:02
:END:
[[https://docs.python.org/3/library/stdtypes.html#bitwise-operations-on-integer-types][Bitwise Operations on integer types]]

See [[1009 Complement of base 10 integer]] [[136 Single number]] for related questions.

Assume the positive number ~n~ has ~x~ bits, then $2^{x-1} \le n \le 2^{x+1}-1$, and eventually $2^{x+1}-1 < val ==2^{x+1}$.
No matter how we toggle the bits in ~n~, it will still be less than $2^{x+1}$.

Notice this is different from the unary operator ~~x~, as it gets the inversion of ~x~ in [[https://en.wikipedia.org/wiki/Two%2527s_complement][Two's complement]] , which is ~-(x+1)~, and applies to all integers (integral numbers).
#+caption: toggle-bit-of-positive-integers-in-python
#+name: toggle-bit-of-positive-integers-in-python
#+begin_src ein-python :session localhost :results output code 
def toggle_bit(n: int) -> int:
    val = 0
    i = 0
    while val <= n:
        n ^= 1<<i # toggle one bit
        i += 1 # move the bit to be toggled to the left by one digit
        val = 2**i # calculate the new val to be compared with n
    return n
#+end_src

#+RESULTS: toggle-bit-of-positive-integers-in-python
#+begin_src none
#+end_src

#+caption: toggle-bit-of-positive-integers-in-python-results
**** Python scopes and namespaces
:LOGBOOK:
CLOCK: [2020-04-14 Tue 14:32]--[2020-04-14 Tue 16:10] =>  1:38
:END:
[[https://docs.python.org/3/tutorial/classes.html#python-scopes-and-namespaces][Python scopes and namespaces doc]].

- Namespace
  - /namespace/ is a mapping from names to objects.
  - most namespaces are implemented as Python dictionaries.
  - examples include:
    - the set of built-in names (e.g. ~abs()~, ~ValueError~)
    - the global names in a module
    - the local names in a function invocation
      
There is absolutely no relation between names in different namespaces.
For instance, two different modules may both define a function ~maximize~ without confution - users of the modules must prefix it with the module name.

/Attribute/ refers to any name following a dot. In the expression ~modname.funcname~, ~modname~ is a module object and ~funcname~ is an attribute of it.

Attributes can be read-only or writable. In the latter case, ~del modname.someattribute~ will remove the attribute ~someattribute~ from the /object/ named ~modname~.

Namespaces are created at different moments and have different lifetimes
The statements executed by the top-level invocation of the interpreter, either read from a script file or interactively, are considered part of a module called ~__main__~, so they have their own global namespace. The built-in names also live in a module ~builtins~.

The local namespace for a function is created when the function is called, and deleted/forgot when the function returns or raises an exception that is not handled within the function.

A /scope/ is a textual region of a Python program where a namespace is directly accessible.
"Directly accessible" here means that an unqualified reference to a name attempts to find the name in the namespace.

Although scopes are determined statically, they are used dynamically. At any time during execution, there are at least /three/ nested scopes whose namespaces are directly accessible:
1. the innermost scope, which is searched first, contains the local names (innermost scope)
2. the scopes of any [[enclosing function]], which are searched starting with the nearest enclosing scope, contains *non-local*, but also *non-global* names. (there can be no enclosing function so that we only get /three/ nested scopes. Also, the innermost scope can only directly read from this scope, but [[shadowing-example][not try to modify it]])
3. the next-to-last scope, contains the current module's global names (middle scope)
4. the outermost scope (searched last) is the namespace containing built-in names (outermost scope)

#+name: enclosing function
#+caption: enclosing function
#+begin_src python :results output
def enclosing_function(args):

    # msg is non-local, but also non-global
    msg = "hello"
    def enclosed_function():
        # enclosed_function has direct access to args and msg
        print(msg)
        for a in args:
            print(a)

    enclosed_function()

enclosing_function("abc")
#+end_src

#+RESULTS: enclosing function
: hello
: a
: b
: c

If a name is declared global, then all references and assignments of it go directly to the middle scope containing the module's global names.
To rebind variables found outside of the innermost scope, the ~nonlocal~ statement can be used; if not declared nonlocal, those variables (attributes) are read-only (an attempt to write to such a variable will simply create a /new/ local variable (i.e. [[shadowing-example][shadowing]]) in the innermost scope, leaving the identically named outer variable unchanged, and this happens at compile time, meaning that any reference to that variable before the write would be invalid and give the ~UnboundLocalError~).

When we say we want to assign an object to a name that is from the enclosing scope (not global scope), there are two interpretations.
1. We want to assign an object to the name so that the change is persistent after the enclosed function has finished, and we can access the new assigned object via the name in the enclosing scope.
2. We want to assign an object to the name so that the change is empheral, i.e. the assignment will be gone after the enclosed function has finished, and we can only access the old object via the name in the enclosing scope.
   
To achieve 1, we must declare the variable as ~nonlocal~ in the enclosed scope because only then, it always refers to the object from the enclosing scope.

To achieve 2, we must let go the the convenience of being able to read the variable's value in the enclosing scope and assign it a new value.

Finally, the ~global~ statement can be used to indicate that particular variables live in the global scope and should be rebound there (i.e. the changes made there will be persistent); the ~nonlocal~ statement indicates that particular variables live in an enclosing scope and should be rebound there.
#+caption: shadowing-example
#+name: shadowing-example
#+begin_src ein-python :session localhost :results output code 
def outer_func():
    msg = "hello"
    def inner_func():
        # can directly read msg
        print(msg) # hello
        # cannot modify outer msg
        # uncommenting this line will give 
        # UnboundLocalError: local variable 'msg' referenced before assignment
        # because we try print(msg) in the previous line before we assign it a value
        #msg = "bye"
        print(msg) # bye

    inner_func()
    print(msg) # hello

outer_func()    
#+end_src

#+RESULTS: shadowing-example
#+begin_src none
hello
hello
hello
#+end_src

#+caption: shadowing-example-results

#+caption: global-nonlocal-example
#+name: global-nonlocal-example
#+begin_src ein-python :session localhost :results output code 
def scope_test():
    def do_local():
        # shadows outer spam
        spam = "local spam"

    def do_nonlocal():
        # modifies outer spam
        nonlocal spam
        spam = "nonlocal spam"

    def do_global():
        # modifies global spam
        # there is no global spam before this function is run
        # so it creates a new name spam and give it the string "global spam"
        global spam
        spam = "global spam"

    # for the following do_ functions
    # this spam is not local nor global
    spam = "test spam"
    do_local()
    print("After local assignment:", spam)
    do_nonlocal()
    print("After nonlocal assignment:", spam)
    do_global()
    print("After global assignment:", spam)

scope_test()
print("In global scope:", spam)
#+end_src

#+RESULTS: global-nonlocal-example
#+begin_src none
After local assignment: test spam
After nonlocal assignment: nonlocal spam
After global assignment: nonlocal spam
In global scope: global spam
#+end_src

#+caption: global-nonlocal-example-results
**** ~nonlocal~ and ~global~
:LOGBOOK:
CLOCK: [2020-04-14 Tue 12:26]--[2020-04-14 Tue 12:31] =>  0:05
:END:
[[https://docs.python.org/3/reference/simple_stmts.html#grammar-token-global-stmt][Simple statements]]

See also [[Python scopes and namespaces]].
**** Get digits of a number in a list
#+caption: get digits of a number in a list
#+name: get digits of a number in a list
#+begin_src ein-python :session localhost :results output code 
num = 123
print(list(map(int, str(num))))
#+end_src

#+RESULTS: get digits of a number in a list
#+begin_src none
[1, 2, 3]
#+end_src

#+caption: get digits of a number in a list-results
**** Python ~itertools~
:LOGBOOK:
CLOCK: [2020-04-15 Wed 10:14]--[2020-04-15 Wed 11:06] =>  0:52
CLOCK: [2020-04-15 Wed 09:27]--[2020-04-15 Wed 09:40] =>  0:13
:END:
Used by [[#949_leetcode_solution]], [[#812_leetcode_solution]], [[#1260_my_solution]], [[*925 Long pressed name]].
See official doc [[https://docs.python.org/3/library/itertools.html][here]].

All infinite iterators.
#+caption: Infinite iterators
#+name: Infinite iterators
#+begin_src ein-python :session localhost :results output code 
from itertools import count, cycle, repeat

# count(start, [step])
inf_count = count(10)
for i in range (10):
    print(next(inf_count))

# cycle(iterable)
for i, e in enumerate(cycle("ABCD")):
    if i > 8: break
    print(e)

# repeat(elem, [n])
for i in repeat(10, 3):
    print(i)
#+end_src

#+RESULTS: Infinite iterators
#+begin_src none
10
11
12
13
14
15
16
17
18
19
A
B
C
D
A
B
C
D
A
10
10
10
#+end_src

#+caption: Infinite iterators-results

A subset of iterators terminating on the shortest input sequence. 
#+caption: iterators terminating on the shortest input sequence
#+name: iterators terminating on the shortest input sequence
#+begin_src ein-python :session localhost :results output code 
import itertools
import operator

# accumulate(p [,func])
# Python 3.8 supports initial parameter
# for v in itertools.accumulate([1,2,3], operator.mul, initial=None):

# amortize a 5% loan of 1000 with 4 annual payments of 90
cashflows = [1000, -90, -90, -90, -90]
print(list(itertools.accumulate(cashflows, lambda bal, pmt: bal*1.05 + pmt)))

# chain(*iterables)
print(list(itertools.chain(*["ABC", "DEF"])))

# chain.from_iterable(iterable)
print(list(itertools.chain.from_iterable(["ABC", "DEF"])))

# conbinations(iterable, r)
# return r length subsequences of elements from the input iterable.
# if the input iterable is sorted, the combination tuples will be produced in sorted order.
# special case of permutations
print(list(itertools.combinations([2,3,1],2)))

# compress(data, selectors)
print(list(itertools.compress("ABCDEF", [1,0,1,0,1,1])))

# permutations(iterable, r=None)
# return successive r length permutations of elements in the iterable
# if r is not specified or None, then r=len(iterable)
print(list(itertools.permutations([2,3,1],2)))

# product(*iterables, repeat=1)
# Cartesian product of input iterables
print("product")
print(list(itertools.product(*["ABCD", "xy"])))
print(list(itertools.product(["ABCD", "xy"], repeat=2)))
print(list(itertools.product([0,1,2])))
print(list(itertools.product(range(2), repeat=3)))


# takewhile(predicate, iterable)
# make an iterator that returns elements from the iterable as long as the predicte is true
# as soon as the predicte becomes false, the iterator stops
print(list(itertools.takewhile(lambda pmt: pmt<10, [10,1,9,11])))

# tee(iterable, n=2)
# return n independent iterators from a single iterable.
print(list(itertools.tee([1,2,3], 2)[0]))

#+end_src

#+RESULTS: iterators terminating on the shortest input sequence
#+begin_src none
[1000, 960.0, 918.0, 873.9000000000001, 827.5950000000001]
['A', 'B', 'C', 'D', 'E', 'F']
['A', 'B', 'C', 'D', 'E', 'F']
[(2, 3), (2, 1), (3, 1)]
['A', 'C', 'E', 'F']
[(2, 3), (2, 1), (3, 2), (3, 1), (1, 2), (1, 3)]
product
[('A', 'x'), ('A', 'y'), ('B', 'x'), ('B', 'y'), ('C', 'x'), ('C', 'y'), ('D', 'x'), ('D', 'y')]
[('ABCD', 'ABCD'), ('ABCD', 'xy'), ('xy', 'ABCD'), ('xy', 'xy')]
[(0,), (1,), (2,)]
[(0, 0, 0), (0, 0, 1), (0, 1, 0), (0, 1, 1), (1, 0, 0), (1, 0, 1), (1, 1, 0), (1, 1, 1)]
[]
[1, 2, 3]
#+end_src

#+caption: iterators terminating on the shortest input sequence-results
**** Backtrack                                                 :algorithm:
:LOGBOOK:
CLOCK: [2020-04-15 Wed 21:20]--[2020-04-15 Wed 21:30] =>  0:10
CLOCK: [2020-04-15 Wed 20:23]--[2020-04-15 Wed 20:48] =>  0:25
CLOCK: [2020-04-15 Wed 19:11]--[2020-04-15 Wed 19:43] =>  0:32
CLOCK: [2020-04-15 Wed 18:49]--[2020-04-15 Wed 19:03] =>  0:14
CLOCK: [2020-04-15 Wed 14:36]--[2020-04-15 Wed 14:56] =>  0:20
:END:
[[https://cs.lmu.edu/~ray/notes/backtracking/]]
*Backtracking* is an approach to solving /constraint-satisfaction/ problems without trying all possibilities.

The Python backtracker engine.
#+caption: python-backtracker-engine
#+name: python-backtracker-engine
#+begin_src ein-python :session localhost :results output code 
from typing import T, List, Callable 

#def solve(values: List[T], safe_up_to: Callable, size: int, all_solutions: List[List[T]]) -> List[T]:
def solve(values: List[T], safe_up_to: Callable, size: int) -> List[T]:
    """Finds /a/ solution to a backtracking problem.

values     -- a sequence of values to try, in order. For a map coloring
                problem, this may be a list of colors, such as ['red',
                'green', 'yellow', 'purple']
    safe_up_to -- a function with two arguments, solution and position, that
                returns whether the values assigned to slots 0..pos in
                the solution list, satisfy the problem constraints.
    size       -- the total number of slots you are trying to fill

Return the solution as a list of values.
    """
    # prebuild the solution list as a variable in the enclosing function
    solution = [None] * size

    # recursive function to find a possible solution
    def extend_solution(position):
        # loop through all possible candidate values
        for value in values:
            # fill the current position with value
            # note we are not changing the variable solution
            # hence this is not a rebind and we do not need to
            # declare solution as nonlocal
            solution[position] = value
            # check if solution so far still satisfies conditions
            if safe_up_to(solution, position):
                # current solution satisfies conditions
                # check if we can return the solution
                # or need to continue with the next position
                # position >= size-1 seems to be an over kill
                # because position inevitably reaches size-1 if a solution exists
                # as long as extend_solution(position+1) does not return None
                # the whole function returns solution
                # if (position >= size-1  or extend_solution(position+1)) and (solution not in all_solutions):
                if (position >= size-1) or extend_solution(position+1):
                    return solution
        return None

    return extend_solution(0)
#+end_src

#+caption: python-backtracker-engine-results

#+RESULTS: python-backtracker-engine

#+caption: eight-queens-with-backtracking
#+name: eight-queens-with-backtracking
#+begin_src ein-python :session localhost :results output code :noweb yes
<<python-backtracker-engine>>
def no_conflicts(board, up_to_column):
    # see if any queens in columns to the left of the up_to_column interfere with
    # the queen in up_to_column. Return False as soon as you find one that does.
    for col in range(up_to_column):
        if (board[col] == board[up_to_column]  # same row
            or board[col] == board[up_to_column] + up_to_column - col  # diagonal
            or board[col] == board[up_to_column] + col - up_to_column):  # diagonal
            return False
    return True

all_solutions = []
ans = solve(range(4), no_conflicts, 4)
while ans:
    all_solutions.append(solve(range(4), no_conflicts, 4))
    ans = solve(range(4), no_conflicts, 4)
    print(all_solutions)
#+end_src

#+RESULTS: eight-queens-with-backtracking
#+begin_src none
[[1, 3, 0, 2], [2, 0, 3, 1]]
#+end_src
#+caption: eight-queens-with-backtracking-results


949 Largest time for given digits
#+caption: 949 with backtracking
#+name: 949 with backtracking
#+begin_src ein-python :session localhost :results output code :noweb yes
<<python-backtracker-engine>>
from typing import Tuple

def is_valid_time(solution, position):
    """
    This function checks if at position, the solution matches the following requirements:
    1. It is not in failed_paths
    2. It is not in all_solutions, i.e. it is not a solution that we already found
    3. It contains a valid number of each digits, i.e. if time_digits=[1,1,2,3], we do not want a path starting with [1,1,1,None]
    4. It fits the constraints of time, e.g. first digit of hour can only be 0, 1, 2
    """

    if tuple([position] + solution)in failed_paths:
        return False

    if tuple(solution) in all_solutions:
        return False

    # A list is an object, so need to copy it.
    local_time_digits = time_digits.copy()

    # this makes sure that there's no replacement
    # i.e. if time_digits=[1,1,2,3], we do not want a path starting with [1,1,1,None]
    def valid_time_digits(solution, position):
        for e in solution[:position+1]:
            try:
                local_time_digits.remove(e)
            except ValueError:
                failed_paths.add(tuple([position] + solution))
                return False
        return True
    
    if not valid_time_digits(solution, position):
        failed_paths.add(tuple([position] + solution))
        return False


    hour_first_vals = set([0, 1, 2])
    hour_second_vals = {
        0: set(range(10)),
        1: set(range(10)),
        2: set(range(4))
    }

    minute_first_digit_vals = set(range(6))
    minute_second_digit_vals = set(range(10))


    if ((position == 0 and solution[position] in hour_first_vals) \ 
        or (position == 1 and solution[position] in hour_second_vals[solution[position-1]]) \ 
        or (position == 2 and solution[position] in minute_first_digit_vals) \ 
        or (position == 3 and solution[position] in minute_second_digit_vals)): 
        return True
    failed_paths.add(tuple([position] + solution))
    return False

# set() gives us O(1) time checking existence
# correspondingly, we have to convert list to tuple when storing them in these sets.
time_digits = [2,0,0,4]

all_solutions = set()
failed_paths = set()
ans = solve(time_digits, is_valid_time, 4)
while ans:
    all_solutions.add(tuple(ans))
    ans = solve(time_digits, is_valid_time, 4)

def time_key(time_list: Tuple[int]) -> int:
    return sum([t*(10**(3-i)) for i, t in enumerate(time_list)])

largest_time = ""
if all_solutions:
    print(all_solutions)
    sorted_all_times = sorted(all_solutions, key=time_key, reverse=True)
    print(sorted_all_times)
    largest_time = "{}{}:{}{}".format(*sorted_all_times[0])
    print(largest_time)
#+end_src

#+RESULTS: 949 with backtracking
#+begin_src none
{(0, 0, 2, 4), (0, 2, 0, 4), (2, 0, 4, 0), (0, 0, 4, 2), (0, 4, 0, 2), (0, 2, 4, 0), (0, 4, 2, 0), (2, 0, 0, 4)}
[(2, 0, 4, 0), (2, 0, 0, 4), (0, 4, 2, 0), (0, 4, 0, 2), (0, 2, 4, 0), (0, 2, 0, 4), (0, 0, 4, 2), (0, 0, 2, 4)]
20:40
#+end_src

#+caption: 949 with backtracking-results
**** Looping lists and make comparisons
:LOGBOOK:
CLOCK: [2020-04-16 Thu 09:10]--[2020-04-16 Thu 09:10] =>  0:00
CLOCK: [2020-04-16 Thu 09:07]--[2020-04-16 Thu 09:10] =>  0:03
:END:
See [[*941 Valid mountain array]] for thoughts.
#+caption: looping lists and make comparisons
#+name: looping lists and make comparisons
#+begin_src ein-python :session localhost :results output code 
from typing import T, List

def loop_list(a: List[T]) -> None:
    def comp(a, b) -> bool:
        """Compare a and b"""
        pass
    i = 0
    n = len(a)

    while i+1<n and comp(a[i], a[i+1]):
        # do something
        i+=1
#+end_src

#+caption: looping lists and make comparisons-results

#+RESULTS: looping lists and make comparisons
**** Python ~fractions~
Used in [[#914_leetcode_solution]], but the ~fractions.gcd()~ is now deprecated since python 3.5, use ~math.gcd()~ instead.
See official doc [[https://docs.python.org/3/library/fractions.html][here]].

The ~fractions~ module provides support for rational number arithmetic.
**** Python ~reduce()~
:LOGBOOK:
CLOCK: [2020-04-16 Thu 14:46]--[2020-04-16 Thu 14:55] =>  0:09
:END:
Used in [[#914_leetcode_solution]].
See official doc [[https://docs.python.org/3/library/functools.html?highlight=reduce#functools.reduce][here]].

~functools.reduce(func, iterable[,initializer])~.
Apply ~func~ of two arguments cumulatively to the items of ~iterable~, from left to right,
so as to reduce the iterable to a single value.
For example, ~reduce(lambda x, y: x+y, [1,2,3,4,5])~ calculates ((((1+2)+3)+4)+5).
The left argument ~x~ is the accumulated value, and the right argument, ~y~, is the update value from the ~iterable~.
If the optional ~initializer~ is present, it is placed before the items of the iterable in the calculation, and serves as a default when the ~iterable~ is empty.
If ~initializer~ is not given and ~iterable~ contains only one item, the first item is returned.

See [[*Python ~itertools~ ]] for ~itertools.accumulate())~ for an iterator tht yields all intermediate values.
#+name: functools reduce
#+begin_src python :results output
from functools import reduce
from operator import mul

lst = [1,2,3,4,5]
factorial = reduce(mul, lst)
print(factorial)
#+end_src

#+RESULTS: functools reduce
: 120
**** Complexity of Python operations
[[https://www.ics.uci.edu/~pattis/ICS-33/lectures/complexitypython.txt][Complexity of Python operations]]
